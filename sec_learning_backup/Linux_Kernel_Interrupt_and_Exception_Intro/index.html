<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Exo 2:300,300italic,400,400italic,700,700italic|Caveat:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"post","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="run_maths &#x3D; function() {     if (document.querySelector(&#39;[class*&#x3D;&quot;cmath&quot;]&#39;) !&#x3D;&#x3D; null) {       if (typeof (mjax_path)&#x3D;&#x3D;&#39;undefined&#39;) { mjax_path&#x3D;&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@2">
<meta property="og:type" content="website">
<meta property="og:title" content="结合源码分析 Linux Kernel 的中断系统原理 (基于 Intel 平台)">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="run_maths &#x3D; function() {     if (document.querySelector(&#39;[class*&#x3D;&quot;cmath&quot;]&#39;) !&#x3D;&#x3D; null) {       if (typeof (mjax_path)&#x3D;&#x3D;&#39;undefined&#39;) { mjax_path&#x3D;&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/vetor_num.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/apic.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/apic_single_processor.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/apic_multi_xeon.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/apic_multi_p6.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/local_apic_arch.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/lvt.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/icr.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/irr_isr.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/tpr.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/ppr.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/local_apic_flow.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/irq_map.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/pic/xxx.png">
<meta property="article:published_time" content="2022-08-18T14:09:58.039Z">
<meta property="article:modified_time" content="2022-08-18T14:09:58.038Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Intro/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>结合源码分析 Linux Kernel 的中断系统原理 (基于 Intel 平台) | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lovin' Tech with Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about-me-(关于我)">

    <a href="/sec_about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me (关于我)</a>

  </li>
        <li class="menu-item menu-item-library-(知识库)">

    <a href="/sec_learning" rel="section"><i class="fa fa-duotone fa-book fa-fw"></i>Library (知识库)</a>

  </li>
        <li class="menu-item menu-item-music-(独立音乐人)">

    <a href="/sec_music" rel="section"><i class="fa fa-music fa-fw"></i>Music (独立音乐人)</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">结合源码分析 Linux Kernel 的中断系统原理 (基于 Intel 平台)
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
          <li>LINUX_KERNEL_INTERRUPT_AND_EXCEPTION_INTRO</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<!--导入样式表-->
<link rel="stylesheet" type="text/css" href="style/index.css">

<!--导入网页脚本-->
<script src="script/index.js"></script>

<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>

<!--支持矩阵显示-->
<script type="text/javascript">
  run_maths = function() {
    if (document.querySelector('[class*="cmath"]') !== null) {
      if (typeof (mjax_path)=='undefined') { mjax_path='https://cdn.jsdelivr.net/npm/mathjax@2'; }
      if (typeof (mjax_config)=='undefined') { mjax_config='AM_CHTML'; }
      smjax = document.createElement ('script');
      smjax.setAttribute('src',`${mjax_path}/MathJax.js?config=${mjax_config}`);
      smjax.setAttribute('async',true);
      document.getElementsByTagName('head')[0].appendChild(smjax);
    }
  };
  if (document.readyState === 'loading') {  
    window.addEventListener('DOMContentLoaded', run_maths); 
  } else { 
    run_maths(); 
  }
</script>
</head>

<body onload="load_page()">

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：May.25 2022</i></font></h4>
</div>
<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>
<br>
<div class="div_catalogue">
  <div align="center">
    <h1> 目录 </h1>
    <p>
    <font size="3px">有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_load_catalogue_alert" id="load_catalogue_alert">正在加载目录...</div>
  <div class="div_catalogue_container" id="catalogue_container">
  </div>
</div><br>

<!-- Start your post here -->
<h2 class="title">基本概念</h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们下面理清楚几个概念。

  <h3 class="title">Interrupt 与 Exception</h3>
  <ul>
    <li><def>Hardware Interrupt</def>: 我们将有外部硬件设备产生的中断信号称为硬件中断，由于它可以随时发生 (但仍然按照 CPU 时钟周期来产生)，因此也被称为 <def>Asynchronous Interrupt</def>;</li>
    <li>
      <def>Software Interrupt</def>: 软件中断由 CPU 执行的指令产生，由于它伴随着 CPU 指令的执行而产生，因此也被称为 <def>Synchronous Interrupt</def>。具体可以分为两种情况:
      <ol>
        <li><def>Exception</def>: 当处理器在执行指令的过程中发现异常事件 (e.g. 页表不存在, 除 0 错误等) 的时候被触发，由 CPU 控制单元发出;</li>
        <li><def>Sysenter</def>: 程序可以通过执行一些指令来产生软件中断 (e.g. x86 平台下的 <code>int</code> 指令)</li>
      </ol>
    </li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;其中，对于 Exception，Intel 平台下又有如下的分类 <cite>intel_document_volume_3a_c6</cite>:

  <ul>
    <li>
      <def>Fault</def>: 该类异常通常可以被纠正，纠正后程序可以继续运行。当 Fault 异常发生时，处理器会记录下产生 Fault 异常的指令的地址 (i.e. 当前 <code>CS</code> 和 <code>EIP</code> 寄存器的值)，作为异常处理程序的返回地址。在运行完异常处理程序后，处理器将返回原先产生 Fault 异常的指令并重新运行;
    </li>
    <li>
      <def>Trap</def>: 该类异常通常是由于处理器运行了 <def>Trapping Instruction</def> 引起的，在运行完异常处理程序后，程序可以被继续运行。值得的注意的是此时异常程序返回后执行的是紧跟在 Trapping Instruction 后面的指令，这与 Fault 异常有所区别;
    </li>
    <li>
      <def>Abort</def>: 该类异常代表着处理器无法精确地获取导致异常的指令的地址，因此产生 Abort 异常后，程序将无法恢复。
    </li>
  </ul>

  <noteblock>
  为了阐述方便，我们下面的行文中，将把上面介绍的 Interrupt 与 Exception 统称为中断。
  </noteblock>

  <h3 class="title">Interrupt Service Routine</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当中断发生时，CPU 会转移到相关的中断处理函数处，我们将该处理函数称为 <def>Interrupt Service Routine</def>。为了定位各个中断对应的 ISRs，CPU 使用了一张 <def>中断向量表 (Interrupt Vector Table)</def>，其中的每一条表项即 <def>中断向量(Interrupt Vector)</def>，记录了各个 ISR 的 <note>物理地址</note>。CPU 会使用一个专用寄存器来存储中断向量表的位置。我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_13_Interrupt/index.html">中断和异常的处理与抢占式多任务</a> 一文曾经讨论过 x86 架构下这一部分的内容，此处不再进行赘述，我们在下文中将继续基于 x86 平台进行分析。

  <h3 class="title">Vector Number</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Intel 处理器中，每一个中断都有一个全局唯一的硬件中断号，称为 <def>Vector Number</def>。当中断发生时，处理器就是通过对应的硬件中断号在中断向量表中找到对应的中断向量的。Intel 处理器限制硬件中断号的范围为 0~255 (8 bits)，其中 0~31 (低 5 bits) 是 Intel 预留的处理器自身相关的 Interrupt 和 Exception 硬件中断号，剩余的 32~255 可用于用户自定义，通常被用于外部硬件中断。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Intel 0~255 号中断分布具体如下所示:

  <div class="img" title="Intel 中断 Vector Number 分布情况" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/vetor_num.png" width="80%" />
  </div>

  <h3 class="title">Hardware Interrupt</h3>
  <h4 class="title">APIC 架构</h4>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Intel 平台的底层中断系统采用的是 <def>Advanced Programmable Interrupt Controller (APIC)</def> 架构，顶层架构设计如 <imgref>apic_arch_overview</imgref> 所示。对于每一个 CPU 核心来说，其都拥有一个 Local APIC，其负责将在总线上探测到的发送给当前 CPU 核心的中断信息，以及该 CPU 核心本地产生的中断信息发送给 CPU 核心，而在全局则有一个 I/O APIC，其接收来自外围设备的中断信号，然后将相关的中断信息转发给相应的 Local APIC 进行后续处理。

  <div class="img" title="APIC 架构 Overview" label="apic_arch_overview">
    <img src="./pic/apic.png" width=600px />
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是从 Intel 官方编程手册 <cite>intel_document_volume_3a_c10</cite> 中摘抄的 APIC 架构相关的说明图。

  <div class="img" title="Intel 至强、奔腾和 P6 处理器在单处理器下的 APIC 架构" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/apic_single_processor.png" width="80%" />
  </div>

  <div class="img" title="Intel 至强处理器在多处理器下的 APIC 架构" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/apic_multi_xeon.png" width="80%" />
  </div>

  <div class="img" title="Intel P6 处理器在多处理器下的 APIC 架构" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/apic_multi_p6.png" width="80%" />
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以发现，在 Intel 至强和奔腾处理器中，I/O APIC 和 Local APIC，以及 Local APIC 之间使用的是 System Bus (e.g. PCI 总线) 进行连接，而在 Intel P6 系列处理器中，则采用的是 3-Wire APIC 总线进行连接。

  <h4 class="title">Local APIC 中断处理结构</h4>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们对 Local APIC 与中断处理相关的结构进行具体分析。

  <div class="img" title="Local APIC 架构" label="local_apic_arch">
    <img src="./pic/local_apic_arch.png" width="90%" />
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如 <imgref>local_apic_arch</imgref> 所示，Local APIC 可以接收以下几种类型的中断信号，主要分为本地和外部两种类型:

  <div class="table" title="Local APIC 接收到的中断类型">
  <table>
    <tr>
      <th>中断类型</th>
      <th>描述</th>
    </tr>
    <tr>
      <td align="center" colspan="2"><h3>本地中断源</h3></td>
    </tr>
    <tr>
      <td><b>CPU Core 本地连接的 I/O 设备产生的中断</b></td>
      <td>APIC 架构允许 I/O 设备通过和处理器的 <code>LINT[1:0]</code> 引脚相连来产生本地中断信号，也可以在这两个引脚上连接 8259 等中断控制芯片来控制外部设备的中断</td>
    </tr>
    <tr>
      <td><b>APIC 计时器产生的中断</b></td>
      <td>本地的 APIC 计时器在计数器到达设置的值后将会触发中断信号</td>
    </tr>
    <tr>
      <td><b>Performance monitoring counter 产生的中断</b></td>
      <td>Intel P6，奔腾和至强处理器可以被设置为当 performance-monitoring 计数器溢出的时候，向处理器发送中断信号</td>
    </tr>
    <tr>
      <td><b>温度传感器产生的中断</b></td>
      <td></td>
    </tr>
    <tr>
      <td><b>APIC Internal Error 产生的中断</b></td>
      <td>当对 Local APIC 的操作产生错误 (e.g. 访问一个不存在的寄存器) 时产生的中断信号</td>
    </tr>
    <tr>
      <td align="center" colspan="2"><h3>外部中断源</h3></td>
    </tr>
    <tr>
      <td><b>外部连接的 I/O 设备</b></td>
      <td>外部连接的 I/O 设备会把它们产生的中断信号发送给 I/O APIC，后者会把中断信号转换为 Interrupt Message，通过 System Bus/APIC Bus 发送给选定 CPU Core 对应的 Local APIC</td>
    </tr>
    <tr>
      <td><b>Interrupt-processor Interrupts (IPIs)</b></td>
      <td>Intel 处理器允许 CPU Core 在 System Bus 上将中断信息发送给其它 CPU Core(s)</td>
    </tr>
  </table>
  </div>

  <h5 class="title">Local Vector Table (LVT)</h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;针对本地中断，Local APIC 使用的是 <def>Local Vector Table (LVT)</def> 进行处理，具体如下所示。在收到对应的本地中断信号后，Local APIC 会在 LVT 中查询相关的后续动作，包括通告 CPU Core 的中断类型 (e.g. NMI, SMI, Fixed, etc.)，中断 Vector Number (p.s. 如果需要的话) 等内容。

  <div class="img" title="Local Vector Table" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/lvt.png" width="600px" />
  </div>

  <h5 class="title">Interrupt Command Register (ICR)</h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;而针对外部中断，包括 IPI 和 外部 I/O 设备中断，它们是通过在系统总线上向 Local APIC 发送 Interrupt Message 来实现的中断通告。就 IPI 来说，CPU Core 可以通过向其本地的 <def>Interrupt Command Register (ICR)</def> 写入相应的信息，来实现 Interrupt Message 的发送。ICR 的具体格式如下所示: 

  <div class="img" title="Local Vector Table" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/icr.png" width="600px" />
  </div>

  <queblock>
  什么是 NMI, SMI, Fixed, INIT 中断?
  </queblock>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在上面介绍的 LVT 和 ICR 中，我们可以看到与中断类型相关的 <code>Delivery Mode</code> 字段，其描述了最终向 CPU Core 发送的中断类型，下面我们对各种中断类型进行介绍:

  <ul>
    <li><b>NMI</b>: </li>
    <li><b>SMI</b>: </li>
    <li><b>Fixed</b>: </li>
    <li><b>INIT</b>: </li>
  </ul>

  <h5 class="title">Interrupt Pending Resgiters</h5>

  <div class="img" title="Interrupt Pending Resgiters" source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">
    <img src="./pic/irr_isr.png" width="600px" />
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当 Local APIC 接收 (receive) 并且接受 (accept) 了 Fixed 类型的中断时，它会将其 pend 在对应 CPU Core 的 <def>Interrupt Pending Resgiters</def> 中，其包含两个寄存器分别是 <def>Interrupt Request Register (IRR)</def> 和 <def>In-service Register (ISR)</def>，它们都是 256-bits 的寄存器，使用按位编码指代被 pending 的中断 Vector Number。当 Loal APIC 接收到中断源信号，并且确认中断类型为 Fixed 类型中断，获取了对应 Vector Number 后，它会置位 IRR/ISR 中对应的比特位，以代表对应 Vector Number 的中断处于 pending 状态，等待 CPU Core 运行相应的中断处理程序。当 CPU Core 准备好处理下一个中断时，IRR 中优先级最高 (i.e. Vector Number 最大) 的中断对应的比特位会被清除，ISR 中对应的比特位会被置位，然后 CPU 会运行 ISR 中标识的优先级最高的中断对应的处理程序。(优先级相关说明见 <ref>priority_registers</ref>)

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当 CPU 完成中断处理程序后，它会清除 ISR 中对应的比特位，并且向 <def>End of Interrupt (EOI)</def> 寄存器中执行写入操作，以告示中断处理的结束。

  <h5 class="title">Interrupt/Processor 优先级寄存器</h5>
  <label class="title">priority_registers</label>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Intel 处理器对中断的 Vector Number 进行了优先级的划分。上文说到 Intel 处理器一共支持 256 个中断，也即 8-bits。Vector Number 的 <code>[7:4]</code> 称为中断的 <def>Interrupt-priority Class</def>，是中断分级的大类; <code>[3:0]</code> 即中断在其 Interrupt-priority Class 中的相对位置，是中断分级的子类。值得注意的是，由于 Intel 把 0~31 号中断划分给 Intel 处理器自用，因此 Interrupt-priority Class 的合法取值范围为 2(<code>0010</code>)~15(<code>1111</code>)，取值越大，优先级越高。

  <div 
    class="img" 
    label="tpr"
    title="Task-Priority Register" 
    source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html"
  >
    <img src="./pic/tpr.png" width="600px" />
  </div>

  <div 
    class="img"
    label="ppr"
    title="Processor-Priority Register" 
    source="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html"
  >
    <img src="./pic/ppr.png" width="600px" />
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Local APIC 中，有两个与中断优先级相关的寄存器 —— <def>Task-Priority Register (TPR)</def> 和 <def>Processor-Priority Register (PPR)</def>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TPR 用于被操作系统软件设置，其包含的值代表着当前操作系统允许被中断的 Vector Number 的下限，低于该值的中断将被操作系统暂时封锁不予处理。因此 TPR 是一个可写的寄存器。如 <imgref>tpr</imgref> 所示，TPR 寄存器中采用了和中断 Vector Number 一样的分级机制，分为 <code>[7:4]</code> 的 Task-Priority Class 和 <code>[3:0]</code> 的 Task-Priority Sub-Class。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;PPR 的值代表着当前处理器实际允许被中断的 Vector Number 的下限，其是基于 TPR 和 ISRV 的值产生的，其中 ISRV 的值指的是 ISR 寄存器中被置位的优先级最高的中断对应的 Vector，PPR 是一个只读寄存器，具体的值产生方法如下:

  <ul>
    <li>
      <code>PPR[7:4]</code>: 等于 <code>TPR[7:4]</code> 和 <code>ISRV[7:4]</code> 中更大的那一个;
    </li>
    <li>
      <code>PPR[3:0]</code> 产生规则如下:
      <ul>
        <li>如果 <code>TPR[7:4]</code> > <code>ISRV[7:4]</code>，那么 <code>PPR[3:0]</code> = <code>TPR[3:0]</code>;</li>
        <li>如果 <code>TPR[7:4]</code> < <code>ISRV[7:4]</code>，那么 <code>PPR[3:0]</code> = 0;</li>
        <li>如果 <code>TPR[7:4]</code> = <code>ISRV[7:4]</code>，那么 <code>PPR[3:0]</code> 是 model-specific 的</li>
      </ul>
    </li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;只有当中断 Vector 代表的优先级大于 PPR 中存储的值时，CPU Core 才会被中断并且对中断予以处理。当然，我们上面的说明针对的是 Delivery Mode 为 Fixed 的中断。

  <h4 class="title">Local APIC 中断处理流程</h4>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Local APIC 处理中断的流程如下所示:

  <div class="img" title="Local APIC 中断处理流程">
    <img src="./pic/local_apic_flow.png" width="500px" />
  </div>
</div>

<h2 class="title">中断相关内核定义</h2>
<div class="div_learning_post">
  <h3 class="title">Generic IRQ Layer</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;从计算机系统架构的角度来看，中断系统在底层的异构性主要体现在两方面:

  <ol>
    <li><b>中断控制器的异构性</b>: 不同的平台上的中断控制器各有千秋，我们上面看到的 APIC 架构是 x86 下的中断控制器结构;</li>
    <li><b>中断编号的异构性</b>: 不同的底层平台会使用不同的编号方法，支持的中断数量也不尽相同;</li>
    <li><b>中断线电平逻辑的异构性</b>: 不同的外围设备的中断器件产生的中断电平逻辑各有千秋，比如有 <def>Level</def> (电平触发型), <def>Edge</def> (边缘触发型) 等等，软件对不同的中断电平逻辑的相应要有所不同，因此产生异构性</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于底层系统的异构性，因此在 Linux 中提出了 <def>Generic IRQ Layer</def> 的概念，其基本目的是为了屏蔽底层系统的异构性，向内核的其它代码提供一个统一的中断接口，以保证内核代码的可移植性。我们下面从上述两个异构性出发，结合源码对内核底层中断的抽象进行阐述。

  <div 
    class="img"
    title="内核对「中断控制器」和「中断号」的抽象"
    label="interrupt_abstraction"
  >
    <img src="./pic/irq_map.png" width=80%>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<imgref>interrupt_abstraction</imgref> 展示了 Linux Generic IRQ Layer 对底层中断平台的抽象，包括中断控制器、中断编号和中断电平处理逻辑，我们下面分别进行说明。

  <h3 class="title">对中断控制器的抽象</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;针对不同的底层平台，内核有着不同的底层代码分支，用于具体实现 CPU 与中断控制器之间的交互 (e.g. 屏蔽/取消屏蔽某个中断，设置中断优先级，以及在 SMP 平台上的亲和度等)。为了兼容不同平台上的不同的中断控制器，内核使用了结构体 <code>irq_chip</code> 对中断控制器进行统一的描述，利用该结构体向内核的其它部分提供了操作中断控制器的接口。这个结构体是在 <code>include/linux/irq.h</code> <cite>linuxsrc_include_linux_irq_h</cite> 中定义的，其定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* struct irq_chip - hardware interrupt chip descriptor</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @parent_device:	pointer to parent device for irqchip</span></span><br><span class="line"><span class="comment">* @name:		name for /proc/interrupts</span></span><br><span class="line"><span class="comment">* @irq_startup:	start up the interrupt (defaults to -&gt;enable if NULL)</span></span><br><span class="line"><span class="comment">* @irq_shutdown:	shut down the interrupt (defaults to -&gt;disable if NULL)</span></span><br><span class="line"><span class="comment">* @irq_enable:		enable the interrupt (defaults to chip-&gt;unmask if NULL)</span></span><br><span class="line"><span class="comment">* @irq_disable:	disable the interrupt</span></span><br><span class="line"><span class="comment">* @irq_ack:		start of a new interrupt</span></span><br><span class="line"><span class="comment">* @irq_mask:		mask an interrupt source</span></span><br><span class="line"><span class="comment">* @irq_mask_ack:	ack and mask an interrupt source</span></span><br><span class="line"><span class="comment">* @irq_unmask:		unmask an interrupt source</span></span><br><span class="line"><span class="comment">* @irq_eoi:		end of interrupt</span></span><br><span class="line"><span class="comment">* @irq_set_affinity:	Set the CPU affinity on SMP machines. If the force</span></span><br><span class="line"><span class="comment">*			argument is true, it tells the driver to</span></span><br><span class="line"><span class="comment">*			unconditionally apply the affinity setting. Sanity</span></span><br><span class="line"><span class="comment">*			checks against the supplied affinity mask are not</span></span><br><span class="line"><span class="comment">*			required. This is used for CPU hotplug where the</span></span><br><span class="line"><span class="comment">*			target CPU is not yet set in the cpu_online_mask.</span></span><br><span class="line"><span class="comment">* @irq_retrigger:	resend an IRQ to the CPU</span></span><br><span class="line"><span class="comment">* @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ</span></span><br><span class="line"><span class="comment">* @irq_set_wake:	enable/disable power-management wake-on of an IRQ</span></span><br><span class="line"><span class="comment">* @irq_bus_lock:	function to lock access to slow bus (i2c) chips</span></span><br><span class="line"><span class="comment">* @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips</span></span><br><span class="line"><span class="comment">* @irq_cpu_online:	configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment">* @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment">* @irq_suspend:	function called from core code on suspend once per</span></span><br><span class="line"><span class="comment">*			chip, when one or more interrupts are installed</span></span><br><span class="line"><span class="comment">* @irq_resume:		function called from core code on resume once per chip,</span></span><br><span class="line"><span class="comment">*			when one ore more interrupts are installed</span></span><br><span class="line"><span class="comment">* @irq_pm_shutdown:	function called from core code on shutdown once per chip</span></span><br><span class="line"><span class="comment">* @irq_calc_mask:	Optional function to set irq_data.mask for special cases</span></span><br><span class="line"><span class="comment">* @irq_print_chip:	optional to print special chip info in show_interrupts</span></span><br><span class="line"><span class="comment">* @irq_request_resources:	optional to request resources before calling</span></span><br><span class="line"><span class="comment">*				any other callback related to this irq</span></span><br><span class="line"><span class="comment">* @irq_release_resources:	optional to release resources acquired with</span></span><br><span class="line"><span class="comment">*				irq_request_resources</span></span><br><span class="line"><span class="comment">* @irq_compose_msi_msg:	optional to compose message content for MSI</span></span><br><span class="line"><span class="comment">* @irq_write_msi_msg:	optional to write message content for MSI</span></span><br><span class="line"><span class="comment">* @irq_get_irqchip_state:	return the internal state of an interrupt</span></span><br><span class="line"><span class="comment">* @irq_set_irqchip_state:	set the internal state of a interrupt</span></span><br><span class="line"><span class="comment">* @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine</span></span><br><span class="line"><span class="comment">* @ipi_send_single:	send a single IPI to destination cpus</span></span><br><span class="line"><span class="comment">* @ipi_send_mask:	send an IPI to destination cpus in cpumask</span></span><br><span class="line"><span class="comment">* @irq_nmi_setup:	function called from core code before enabling an NMI</span></span><br><span class="line"><span class="comment">* @irq_nmi_teardown:	function called from core code after disabling an NMI</span></span><br><span class="line"><span class="comment">* @flags:		chip specific flags</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span>	*<span class="title">parent_device</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*name;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*irq_startup)</span><span class="params">(struct irq_data *data)</span></span>;</span><br><span class="line">    <span class="keyword">void</span>		(*irq_shutdown)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_enable)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_disable)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_ack)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_mask)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_mask_ack)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_unmask)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_eoi)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>		(*irq_set_affinity)(struct irq_data *data, <span class="keyword">const</span> struct cpumask *dest, <span class="keyword">bool</span> force);</span><br><span class="line">    <span class="keyword">int</span>		(*irq_retrigger)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">int</span>		(*irq_set_type)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> flow_type);</span><br><span class="line">    <span class="keyword">int</span>		(*irq_set_wake)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> on);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_bus_lock)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_bus_sync_unlock)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_cpu_online)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_cpu_offline)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_suspend)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_resume)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_pm_shutdown)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_calc_mask)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);</span><br><span class="line">    <span class="keyword">int</span>		(*irq_request_resources)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_release_resources)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>		(*irq_get_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> *state);</span><br><span class="line">    <span class="keyword">int</span>		(*irq_set_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>		(*irq_set_vcpu_affinity)(struct irq_data *data, <span class="keyword">void</span> *vcpu_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>		(*ipi_send_single)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line">    <span class="keyword">void</span>		(*ipi_send_mask)(struct irq_data *data, <span class="keyword">const</span> struct cpumask *dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>		(*irq_nmi_setup)(struct irq_data *data);</span><br><span class="line">    <span class="keyword">void</span>		(*irq_nmi_teardown)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	flags;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到在结构体 <code>irq_chip</code> 中，定义了很多函数指针。在不同的平台的代码实现中，会实现这个函数集合的子集。如下所示是 x86 多核平台下的 <code>irq_chip</code> 实现，分别有上文介绍的 I/O APIC 版本和 Local APIC 版本。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/kernel/apic/io_apic.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> <span class="title">ioapic_chip</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">  .name			= <span class="string">&quot;IO-APIC&quot;</span>,</span><br><span class="line">  .irq_startup		= startup_ioapic_irq,</span><br><span class="line">  .irq_mask		= mask_ioapic_irq,</span><br><span class="line">  .irq_unmask		= unmask_ioapic_irq,</span><br><span class="line">  .irq_ack		= irq_chip_ack_parent,</span><br><span class="line">  .irq_eoi		= ioapic_ack_level,</span><br><span class="line">  .irq_set_affinity	= ioapic_set_affinity,</span><br><span class="line">  .irq_retrigger		= irq_chip_retrigger_hierarchy,</span><br><span class="line">  .irq_get_irqchip_state	= ioapic_irq_get_chip_state,</span><br><span class="line">  .flags			= IRQCHIP_SKIP_SET_WAKE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> <span class="title">lapic_chip</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">  .name		= <span class="string">&quot;local-APIC&quot;</span>,</span><br><span class="line">  .irq_mask	= mask_lapic_irq,</span><br><span class="line">  .irq_unmask	= unmask_lapic_irq,</span><br><span class="line">  .irq_ack	= ack_lapic_irq,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <h3 class="title">对中断编号的抽象</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;底层的中断控制器会用唯一的 <def>Hardware IRQ</def> 编号来标识各个中断 <cite>wikipedia_irq</cite>，我们在上面看到了 Intel 处理器编号的 256 个中断。在不同的底层平台上，Hardware IRQ 的数量和分配情况有所不同。为了实现 Linux 的可移植性，内核将底层平台的各个 Hardware IRQ 编号一一映射到 <def>Linux IRQ</def> 实例上去，所有的外部设备的驱动程序都是基于 Linux IRQ 来绑定和注册它们的中断处理程序的。Linux IRQ 的具体实现是结构体 <code>struct irq_desc</code>，它是在 <code>include/linux/irqdesc.h</code> <cite>linuxsrc_include_linux_irqdesc_h</cite> 中定义的，具体定义如下所示。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* struct irq_desc - interrupt descriptor</span></span><br><span class="line"><span class="comment">* @irq_common_data:	per irq and chip data passed down to chip functions</span></span><br><span class="line"><span class="comment">* @kstat_irqs:		irq stats per cpu</span></span><br><span class="line"><span class="comment">* @handle_irq:		highlevel irq-events handler</span></span><br><span class="line"><span class="comment">* @action:		the irq action chain</span></span><br><span class="line"><span class="comment">* @status_use_accessors: status information</span></span><br><span class="line"><span class="comment">* @core_internal_state__do_not_mess_with_it: core internal status information</span></span><br><span class="line"><span class="comment">* @depth:		disable-depth, for nested irq_disable() calls</span></span><br><span class="line"><span class="comment">* @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers</span></span><br><span class="line"><span class="comment">* @tot_count:		stats field for non-percpu irqs</span></span><br><span class="line"><span class="comment">* @irq_count:		stats field to detect stalled irqs</span></span><br><span class="line"><span class="comment">* @last_unhandled:	aging timer for unhandled count</span></span><br><span class="line"><span class="comment">* @irqs_unhandled:	stats field for spurious unhandled interrupts</span></span><br><span class="line"><span class="comment">* @threads_handled:	stats field for deferred spurious detection of threaded handlers</span></span><br><span class="line"><span class="comment">* @threads_handled_last: comparator field for deferred spurious detection of theraded handlers</span></span><br><span class="line"><span class="comment">* @lock:		locking for SMP</span></span><br><span class="line"><span class="comment">* @affinity_hint:	hint to user space for preferred irq affinity</span></span><br><span class="line"><span class="comment">* @affinity_notify:	context for notification of affinity changes</span></span><br><span class="line"><span class="comment">* @pending_mask:	pending rebalanced interrupts</span></span><br><span class="line"><span class="comment">* @threads_oneshot:	bitfield to handle shared oneshot threads</span></span><br><span class="line"><span class="comment">* @threads_active:	number of irqaction threads currently running</span></span><br><span class="line"><span class="comment">* @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers</span></span><br><span class="line"><span class="comment">* @nr_actions:		number of installed actions on this descriptor</span></span><br><span class="line"><span class="comment">* @no_suspend_depth:	number of irqactions on a irq descriptor with</span></span><br><span class="line"><span class="comment">*			IRQF_NO_SUSPEND set</span></span><br><span class="line"><span class="comment">* @force_resume_depth:	number of irqactions on a irq descriptor with</span></span><br><span class="line"><span class="comment">*			IRQF_FORCE_RESUME set</span></span><br><span class="line"><span class="comment">* @rcu:		rcu head for delayed free</span></span><br><span class="line"><span class="comment">* @kobj:		kobject used to represent this struct in sysfs</span></span><br><span class="line"><span class="comment">* @request_mutex:	mutex to protect request/free before locking desc-&gt;lock</span></span><br><span class="line"><span class="comment">* @dir:		/proc/irq/ procfs entry</span></span><br><span class="line"><span class="comment">* @debugfs_file:	dentry for the debugfs file</span></span><br><span class="line"><span class="comment">* @name:		flow handler name for /proc/interrupts output</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> __percpu	*kstat_irqs;</span><br><span class="line">  <span class="keyword">irq_flow_handler_t</span>	handle_irq;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">/* IRQ action list */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		status_use_accessors;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		core_internal_state__do_not_mess_with_it;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		depth;		<span class="comment">/* nested irq disables */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		wake_depth;	<span class="comment">/* nested wake enables */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		tot_count;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		irq_count;	<span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		last_unhandled;	<span class="comment">/* Aging timer for unhandled count */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		irqs_unhandled;</span><br><span class="line">  <span class="keyword">atomic_t</span>		threads_handled;</span><br><span class="line">  <span class="keyword">int</span>			threads_handled_last;</span><br><span class="line">  <span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">  <span class="keyword">cpumask_var_t</span>		pending_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		threads_oneshot;</span><br><span class="line">  <span class="keyword">atomic_t</span>		threads_active;</span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>       wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_actions;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		no_suspend_depth;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		cond_suspend_depth;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span></span><br><span class="line">  <span class="keyword">int</span>			parent_irq;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;内核在初始化的时候会为每一个中断源创建一个 <code>irq_desc</code> 实例，这些 <code>irq_desc</code> 实例会被存储在一个同样名为 <code>irq_desc</code> 的数组中，我们后面把这个数组称为 <def>IRQ Decriptor Table</def>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在结构体 <code>irq_desc</code> 中，类型为 <code>irq_data</code> 的成员 <code>irq_data</code> 存储了描述该中断源的底层信息，包括 Linux IRQ 编号，Hardware IRQ 编号，以及指向存储着中断控制器操作的 <code>irq_chip</code> 实例的指针。它是在 <code>include/linux/irq.h</code> <cite>linuxsrc_include_linux_irq_h</cite> 中定义的，具体的定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* struct irq_data - per irq chip data passed down to chip functions</span></span><br><span class="line"><span class="comment">* @mask:		precomputed bitmask for accessing the chip registers</span></span><br><span class="line"><span class="comment">* @irq:		interrupt number</span></span><br><span class="line"><span class="comment">* @hwirq:		hardware interrupt number, local to the interrupt domain</span></span><br><span class="line"><span class="comment">* @common:		point to data shared by all irqchips</span></span><br><span class="line"><span class="comment">* @chip:		low level interrupt hardware access</span></span><br><span class="line"><span class="comment">* @domain:		Interrupt translation domain; responsible for mapping</span></span><br><span class="line"><span class="comment">*			between hwirq number and linux irq number.</span></span><br><span class="line"><span class="comment">* @parent_data:	pointer to parent struct irq_data to support hierarchy</span></span><br><span class="line"><span class="comment">*			irq_domain</span></span><br><span class="line"><span class="comment">* @chip_data:		platform-specific per-chip private data for the chip</span></span><br><span class="line"><span class="comment">*			methods, to allow shared chip implementations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> &#123;</span></span><br><span class="line">  u32			mask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		irq;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		hwirq;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	*<span class="title">common</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		*<span class="title">chip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		*<span class="title">parent_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">void</span>			*chip_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <h3 class="title">中断处理逻辑</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于不同的设备来说，它们可能有着不同的中断触发类型 (e.g. <def>Level</def> (电平触发型), <def>Edge</def> (边缘触发型), etc) <cite>kerneldoc_irq</cite>。因此，在中断处理逻辑中，我们有必要对所谓 <def>Flow Management</def> 加以区分。因此，对于每一个 Linux IRQ，内核使用 <code>irq_desc</code> 中类型为 <code>irq_flow_handler_t</code> 的 <code>handle_irq</code> 成员来存储对应于该中断线上设备中断触发类型的 High-level 处理函数。内核在 <code>kernel/irq/chip.c</code> <cite>linuxsrc_kernel_irq_chip_c</cite> 中提供了以下几个对应与不同中断触发类型的 High-level 处理函数。这些函数针对不同的中断线电平逻辑有着不同的 High-level 中断处理逻辑，但是它们的核心都是调用中断处理函数。我们在后面将会看到。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handle_level_irq()      <span class="comment">// For level-triggered interrupts</span></span><br><span class="line">handle_edge_irq()       <span class="comment">// For edge-triggered interrupts</span></span><br><span class="line">handle_fasteoi_irq()    <span class="comment">// For interrupts that only need an EOI at the end of the handler</span></span><br><span class="line">handle_simple_irq()     <span class="comment">// For simple interrupts</span></span><br><span class="line">handle_percpu_irq()     <span class="comment">// For per-CPU interrupts</span></span><br><span class="line">handle_bad_irq()        <span class="comment">// For spurious interrupts</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在上面用于处理中断线电平的 High-level 的函数的包装下，当中断源发生中断时，由设备驱动注册在当前中断源上的中断处理函数需要被调用。<code>irq_desc</code> 中类型为 <code>struct irqaction*</code> 的成员 <code>action</code> 指向了一条存储着 <code>struct irqaction</code> 的链表。这些 <code>struct irqaction</code> 代表着中断描述符，各个中断描述符中存储着由各个设备驱动定义好并绑定在当前中断线上的中断处理逻辑。<code>struct irqaction</code> 是在 <code>include/linux/interrupt.h</code> <cite>linuxsrc_include_linux_interrupt_h</cite> 中定义的，其定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* struct irqaction - per interrupt action descriptor</span></span><br><span class="line"><span class="comment">* @handler:	interrupt handler function</span></span><br><span class="line"><span class="comment">* @name:	name of the device</span></span><br><span class="line"><span class="comment">* @dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment">* @percpu_dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment">* @next:	pointer to the next irqaction for shared interrupts</span></span><br><span class="line"><span class="comment">* @irq:	interrupt number</span></span><br><span class="line"><span class="comment">* @flags:	flags (see IRQF_* above)</span></span><br><span class="line"><span class="comment">* @thread_fn:	interrupt handler function for threaded interrupts</span></span><br><span class="line"><span class="comment">* @thread:	thread pointer for threaded interrupts</span></span><br><span class="line"><span class="comment">* @secondary:	pointer to secondary irqaction (force threading)</span></span><br><span class="line"><span class="comment">* @thread_flags:	flags related to @thread</span></span><br><span class="line"><span class="comment">* @thread_mask:	bitmask for keeping track of @thread activity</span></span><br><span class="line"><span class="comment">* @dir:	pointer to the proc/irq/NN/name entry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">  <span class="keyword">irq_handler_t</span>		handler;</span><br><span class="line">  <span class="keyword">void</span>			*dev_id;</span><br><span class="line">  <span class="keyword">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span></span><br><span class="line">  <span class="keyword">irq_handler_t</span>		thread_fn;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		irq;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_flags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_mask;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，当我们在一个 <caode>irq_desc</code> 的 <code>action</code> 链表上挂载多个 <code>irqaction</code> 时，此时中断线将是共享的，即 <def>Shared IRQ</def>，否则则是 <def>Specified IRQ</def>。如果是共享中断线，则在中断事件发生之后，在这条中断线上注册的中断处理函数将需要检查是否是自己的设备发生了中断。我们在后面将会看到相关的代码。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在让我们串起来。当某个中断源发生中断时，基于 Linux IRQ 编号，内核基于该下标可以在 <code>irq_desc</code> 数组中找到对应的 <code>irq_desc</code> 结构。此时 <code>irq_desc</code> 中的 <code>handle_irq</code> 指针指向的函数就会被调用，该函数会在正确处理对应中断线电平逻辑的情况下，调用在该中断线上的中断处理函数，这些中断处理函数是在中断描述符 <code>irqaction</code> 中被描述的。对于各条中断线，它们相应的中断处理函数被组织成一条链表的形式，挂在 <code>irq_desc</code> 结构的成员 <code>action</code> 上。
</div>

<h2 class="title">与中断相关的内核接口</h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Generic IRQ Layer 提供了各种各样的接口，方便设备驱动用于实现与中断相关的操作。理解这些接口将有助于我们后续对设备驱动的学习，在本节中我们将对这些接口进行阐述。

  <h3 class="title">注册中断处理函数</h3>

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/interrupt.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* request_irq - Add a handler for an interrupt line</span></span><br><span class="line"><span class="comment">* @irq:	The interrupt line to allocate</span></span><br><span class="line"><span class="comment">* @handler:	Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment">*		Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment">*		If NULL, the default primary handler is installed</span></span><br><span class="line"><span class="comment">* @flags:	Handling flags</span></span><br><span class="line"><span class="comment">* @name:	Name of the device generating this interrupt</span></span><br><span class="line"><span class="comment">* @dev:	A cookie passed to the handler function</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This call allocates an interrupt and establishes a handler; see</span></span><br><span class="line"><span class="comment">* the documentation for request_threaded_irq() for details.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __must_check</span><br><span class="line">request_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>request_irq</code> 用于初始化一个 <code>irqactioin</code> 实例，并且绑定到由参数 <code>irq</code> 指定的 <code>irq_desc</code> 上去; 类型为 <code>irq_handler_t</code> 的参数 <code>handler</code> 指向了由设备驱动程序定义的中断处理函数; <code>flags</code> 是一个与中断管理相关的 bitmask，这个 bitmask 的各个位是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/interrupt.h#L65">include/linux/interrupt.h</a> 中定义的，其中比较重要的位包括:

  <ul>
    <li><code>IRQF_SHARED</code>: 表示当前注册的中断处理函数允许和其它中断处理函数一起共享中断线;</li>
    <li><code>IRQF_TIMER</code>: 标记当前中断是一个定时器中断;</li>
    <li><code>IRQF_PERCPU</code>: 标识当前中断是 per-CPU 的中断;</li>
    <li><code>IRQF_NOBALANCING</code>: 标识将当前注册的中断排除在 IRQ Balancing 策略之外;</li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于允许共享中断线的中断处理函数来说，在使用 <code>request_irq</code> 注册中断处理函数时，参数 <code>dev</code> 是必不可少的 (i.e. 不能设置为 <code>NULL</code>，可以指向驱动模块程序中的任意地址) <cite>ldd_sharedirq</cite>。其原因是，在共享中断线的情况下，在 <code>irq_desc</code> 的 <code>action</code> 链表上将会存在多个 <code>irqaction</code>，这个 <code>dev</code> 值将被用作区分这些 <code>irqaction</code> 的唯一凭据。当共享中断线上发生中断信号时，这些 <code>irqaction</code> 所代表的中断处理函数都会被调用，因此允许共享中断线的中断处理函数必须首先检查是否是自己的设备发生了中断，若是，再继续后续的中断处理。那么这些中断处理函数找到自己设备的方法就是这个 <code>dev</code> 值。考虑这样一种情况，我们在一条中断线上启用了两个使用同个驱动程序的外围设备，那么这两个设备会在对应的 <code>irq_desc</code> 的 <code>action</code> 链表上注册两个 <code>irqaction</code>，这两个 <code>irqaction</code> 的区别在于它们的 <code>dev</code> 值是有区别的，并且这个 <code>dev</code> 值是由驱动程序自己维护的。当中断来临时，本质上同一个中断处理程序会被调用两次，但是两次调用传入的 <code>dev</code> 值是不同的，因此前后两次处理的设备是不同的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当我们调用 <code>request_irq</code> 向一条中断线上注册一个允许共享中断的 <code>irqaction</code> 时，只有如下两个条件之一得到满足，才能注册成功 <cite>ldd_sharedirq</cite>。<code>request_irq</code> 注册成功将返回 0 值。

  <ol>
    <li>这条中断线上没有注册任何 <code>irqaction</code></li>
    <li>这条中断线上注册的 <code>irqaction</code> 都允许共享中断线</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;另外，传入 <code>request_irq</code> 的另一个重要参数是中断处理函数 <code>handler</code>。中断处理函数的类型被定义为 <code>irqreturn_t</code>，其函数原型如下:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">irqreturn_t</span> <span class="params">(*<span class="keyword">irq_handler_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个函数会在中断到来的时候被调用。其中传入的第一个 <code>int</code> 参数是 Linux IRQ 编号，第二个参数是我们上面介绍过的 <code>dev</code>。<code>irqreturn_t</code> 的返回值是一个枚举类型，在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/irqreturn.h#L11">include/linux/irqreturn.h</a> 中被定义，具体定义如下:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* enum irqreturn</span></span><br><span class="line"><span class="comment">* @IRQ_NONE		interrupt was not from this device or was not handled</span></span><br><span class="line"><span class="comment">* @IRQ_HANDLED		interrupt was handled by this device</span></span><br><span class="line"><span class="comment">* @IRQ_WAKE_THREAD	handler requests to wake the handler thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line">  IRQ_NONE		= (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">  IRQ_HANDLED		= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">  IRQ_WAKE_THREAD		= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当允许共享中断线的中断处理程序检测到不是自己的设备产生了中断时，它应该返回 <code>IRQ_NONE</code>; 如果中断被正确处理，它应该返回 <code>IRQ_HANDLED</code>; 如果中断程序尝试唤醒一个 <def>中断处理线程 (Threaded Interrupt Handler)</def>，它应该返回 <code>IRQ_WAKE_THREAD</code>，我们将在 <ref>threaded_interrupt_handler</ref> 中对此部分进行介绍。

  <h3 class="title">解注册中断处理函数</h3>

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/irq/manage.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	free_irq - free an interrupt allocated with request_irq</span></span><br><span class="line"><span class="comment">*	@irq: Interrupt line to free</span></span><br><span class="line"><span class="comment">*	@dev_id: Device identity to free</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	Remove an interrupt handler. The handler is removed and if the</span></span><br><span class="line"><span class="comment">*	interrupt line is no longer in use by any driver it is disabled.</span></span><br><span class="line"><span class="comment">*	On a shared IRQ the caller must ensure the interrupt is disabled</span></span><br><span class="line"><span class="comment">*	on the card it drives before calling this function. The function</span></span><br><span class="line"><span class="comment">*	does not return until any executing interrupts for this IRQ</span></span><br><span class="line"><span class="comment">*	have completed.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	This function must not be called from interrupt context.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	Returns the devname argument passed to request_irq.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span> *<span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">  <span class="keyword">if</span> (WARN_ON(desc-&gt;affinity_notify))</span><br><span class="line">    desc-&gt;affinity_notify = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  action = __free_irq(desc, dev_id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!action)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  devname = action-&gt;name;</span><br><span class="line">  kfree(action);</span><br><span class="line">  <span class="keyword">return</span> devname;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(free_irq);</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>free_irq</code> 用于释放一个由 <code>request_irq</code> 分配的 <code>irqaction</code>。其中传入的参数 <code>irq</code> 是 Linux IRQ 编号。如果释放的 <code>irqaction</code> 是一个共享中断线的中断处理程序，<code>dev_id</code> 用于指明具体取消的 <code>irqaction</code> 是哪一个。

  <h3 class="title">注册 Threaded 中断处理线程</h3>
  <label class="title">threaded_interrupt_handler</label>

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/interrupt.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	request_threaded_irq - allocate an interrupt line</span></span><br><span class="line"><span class="comment">*	@irq: Interrupt line to allocate</span></span><br><span class="line"><span class="comment">*	@handler: Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment">*		  Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment">*		  If NULL and thread_fn != NULL the default</span></span><br><span class="line"><span class="comment">*		  primary handler is installed</span></span><br><span class="line"><span class="comment">*	@thread_fn: Function called from the irq handler thread</span></span><br><span class="line"><span class="comment">*		    If NULL, no irq thread is created</span></span><br><span class="line"><span class="comment">*	@irqflags: Interrupt type flags</span></span><br><span class="line"><span class="comment">*	@devname: An ascii name for the claiming device</span></span><br><span class="line"><span class="comment">*	@dev_id: A cookie passed back to the handler function</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	This call allocates interrupt resources and enables the</span></span><br><span class="line"><span class="comment">*	interrupt line and IRQ handling. From the point this</span></span><br><span class="line"><span class="comment">*	call is made your handler function may be invoked. Since</span></span><br><span class="line"><span class="comment">*	your handler function must clear any interrupt the board</span></span><br><span class="line"><span class="comment">*	raises, you must take care both to initialise your hardware</span></span><br><span class="line"><span class="comment">*	and to set up the interrupt handler in the right order.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	If you want to set up a threaded irq handler for your device</span></span><br><span class="line"><span class="comment">*	then you need to supply @handler and @thread_fn. @handler is</span></span><br><span class="line"><span class="comment">*	still called in hard interrupt context and has to check</span></span><br><span class="line"><span class="comment">*	whether the interrupt originates from the device. If yes it</span></span><br><span class="line"><span class="comment">*	needs to disable the interrupt on the device and return</span></span><br><span class="line"><span class="comment">*	IRQ_WAKE_THREAD which will wake up the handler thread and run</span></span><br><span class="line"><span class="comment">*	@thread_fn. This split handler design is necessary to support</span></span><br><span class="line"><span class="comment">*	shared interrupts.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	Dev_id must be globally unique. Normally the address of the</span></span><br><span class="line"><span class="comment">*	device data structure is used as the cookie. Since the handler</span></span><br><span class="line"><span class="comment">*	receives this value it makes sense to use it.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	If your interrupt is shared you must pass a non NULL dev_id</span></span><br><span class="line"><span class="comment">*	as this is required when freeing the interrupt.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	Flags:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	IRQF_SHARED		Interrupt is shared</span></span><br><span class="line"><span class="comment">*	IRQF_TRIGGER_*		Specify active edge(s) or level</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">    <span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment">  * otherwise we&#x27;ll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment">  * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment">  * logic etc).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and</span></span><br><span class="line"><span class="comment">  * it cannot be set along with IRQF_NO_SUSPEND.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">      (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">      ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  desc = irq_to_desc(irq);</span><br><span class="line">  <span class="keyword">if</span> (!desc)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">      WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!thread_fn)</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    handler = irq_default_primary_handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  action = kzalloc(<span class="keyword">sizeof</span>(struct irqaction), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!action)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  action-&gt;handler = handler;</span><br><span class="line">  action-&gt;thread_fn = thread_fn;</span><br><span class="line">  action-&gt;flags = irqflags;</span><br><span class="line">  action-&gt;name = devname;</span><br><span class="line">  action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">  retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    kfree(action);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">    irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">    kfree(action-&gt;secondary);</span><br><span class="line">    kfree(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">  <span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">    * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">    * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">    * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    disable_irq(irq);</span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">    enable_irq(irq);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(request_threaded_irq);</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由设备驱动通过 <code>request_irq</code> 注册的中断处理程序运行在 <def>Hard IRQ Context</def> 中: 当前 CPU 核心抢占和中断均被 Disabled。在这种环境下，CPU core 的运行将被中断处理程序完全接管，我们并不希望 CPU 长时间地运行在这种状态下，换句话说设备驱动中断处理程序的设计应该保证 <note>原子性</note> (i.e. 不阻塞) 且 <note>快速</note> (i.e. 不要做太多工作，尤其是耗时的工作)。然而，有一些设备 (e.g. 网卡) 产生的中断，系统要做的处理逻辑并不简单，这导致了中断处理程序的处理时间波动范围大的问题。内核应用了所谓 Split-handler 的设计思路，将中断处理逻辑拆分为 <def>top half</def> 和 <def>bottom half</def> 两部分，前者负责处理 interrupt critical 的操作，包括对外部设备的寄存器的读写、调度相关 bottom-half 处理逻辑等操作；后者负责处理 interrupt non-critical 和 deferrable work 的操作，比如处理由 top-half 产生的数据、与 Process Context 进行交互，以及访问用户地址空间等。内核提供了如 <def>Softirq</def>, <def>Tasklets</def> 和 <def>Workqueue</def> 三种 Deferred Work 的机制，我们在后面将进行介绍。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;除此之外，内核在中断系统中提供了一种可以在 Threaded Context 中运行中断处理程序的机制 —— <def>Threaded Interrupt Handler</def>。驱动程序可以使用 <code>request_threaded_irq</code> 接口来申请一个可 threaded 的中断处理程序，该接口的函数原型如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *	request_threaded_irq - allocate an interrupt line</span></span><br><span class="line"><span class="comment">  *	@irq: Interrupt line to allocate</span></span><br><span class="line"><span class="comment">  *	@handler: Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment">  *		  Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment">  *		  If NULL and thread_fn != NULL the default</span></span><br><span class="line"><span class="comment">  *		  primary handler is installed</span></span><br><span class="line"><span class="comment">  *	@thread_fn: Function called from the irq handler thread</span></span><br><span class="line"><span class="comment">  *		    If NULL, no irq thread is created</span></span><br><span class="line"><span class="comment">  *	@irqflags: Interrupt type flags</span></span><br><span class="line"><span class="comment">  *	@devname: An ascii name for the claiming device</span></span><br><span class="line"><span class="comment">  *	@dev_id: A cookie passed back to the handler function</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *	This call allocates interrupt resources and enables the</span></span><br><span class="line"><span class="comment">  *	interrupt line and IRQ handling. From the point this</span></span><br><span class="line"><span class="comment">  *	call is made your handler function may be invoked. Since</span></span><br><span class="line"><span class="comment">  *	your handler function must clear any interrupt the board</span></span><br><span class="line"><span class="comment">  *	raises, you must take care both to initialise your hardware</span></span><br><span class="line"><span class="comment">  *	and to set up the interrupt handler in the right order.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *	If you want to set up a threaded irq handler for your device</span></span><br><span class="line"><span class="comment">  *	then you need to supply @handler and @thread_fn. @handler is</span></span><br><span class="line"><span class="comment">  *	still called in hard interrupt context and has to check</span></span><br><span class="line"><span class="comment">  *	whether the interrupt originates from the device. If yes it</span></span><br><span class="line"><span class="comment">  *	needs to disable the interrupt on the device and return</span></span><br><span class="line"><span class="comment">  *	IRQ_WAKE_THREAD which will wake up the handler thread and run</span></span><br><span class="line"><span class="comment">  *	@thread_fn. This split handler design is necessary to support</span></span><br><span class="line"><span class="comment">  *	shared interrupts.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *	Dev_id must be globally unique. Normally the address of the</span></span><br><span class="line"><span class="comment">  *	device data structure is used as the cookie. Since the handler</span></span><br><span class="line"><span class="comment">  *	receives this value it makes sense to use it.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *	If your interrupt is shared you must pass a non NULL dev_id</span></span><br><span class="line"><span class="comment">  *	as this is required when freeing the interrupt.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *	Flags:</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *	IRQF_SHARED		Interrupt is shared</span></span><br><span class="line"><span class="comment">  *	IRQF_TRIGGER_*		Specify active edge(s) or level</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params">	 <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params">	 <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这个接口中，参数 <code>handler</code> 传入的是运行在 Interrupt Context 中的 Primary Interrupt Handler，参数 <code>thread_fn</code> 传入的是运行在 Threaded Context 的中断函数逻辑。按照这种方式注册的中断函数，当中断发生时，<code>handler</code> 所代表的 Primary Interrupt Handler 将首先被调用，在该函数返回 <code>IRQ_WAKE_THREAD</code> 后，<code>thread_fn</code> 所定义的后续中断处理逻辑将被调度，并在 Threaded Context 中被执行。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Theaded Interrupt Handler 有两种玩法。一种是在 Primary Interrupt Handler 中完成 Interrupt-critical 的工作，然后唤醒 Threaded Handler 进行处理，这种处理方式与 Deferred Work 的机制类似，对应的中断源将在 Primary Interrupt Handler 执行完成后被手动 Unmasked 恢复；第二种是把所有的中断处理逻辑都放到 Threaded Handler 中，Primary Interrupt Handler 中只会对中断源进行确认 (i.e. 考虑 Shared IRQ 的情况) 以及唤醒 Threaded Handler，在这种情况下，对应的中断源需要被 Masked 直至 Threaded Handler 完成其处理逻辑。为了实现对中断源的持续 Masked，我们可以通过以下其中一种方式予以实现:

  <ul>
    <li>在 Primary Interrupt Handler 中，在调度 Theaded Interrupt Handler 之前手动 Mask 掉中断，不要 Unmask 它;</li>
    <li>在使用 <code>request_threaded_irq</code> 注册时，在参数 <code>irqflags</code> 中使用 <code>IRQF_ONESHOT</code> 标记进行标识</li>
  </ul>

  <h3 class="title">控制接口</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Generic IRQ Layer 还提供了若干的用于控制各个 Linux 中断源的接口，下面进行介绍。

  <div>
    <code>void disable_irq(unsigned int irq)</code>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>disable_irq</code> 关闭了指定 Linux IRQ 所代表的中断线的响应。这是一个阻塞的函数调用，这个函数会等待当前指定的中断线上正在运行的 Handler 运行结束后，再完成对中断线的屏蔽。实际上，<code>disable_irq</code> 底层调用了 <code>irq_chip</code> 结构体的 <code>irq_disable</code> 函数完成了对中断线的屏蔽，它实现的是全局的对某条中断线的屏蔽。
</div>

<h2 class="title">Deferred Work</h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TODO
</div>

<div class="div_ref" id="ref_container"></div>

</body>
<!--引用其它章节-->
<!-- 
<ref></ref> 
-->

<!--引用文献-->
<!-- 
<cite></cite> 
-->

<!--关键词-->
<!-- 
<def></def> 
-->

<!--醒目注意-->
<!-- 
<note></note> 
-->

<!--表格-->
<!--
<table border="1" align="center" bgcolor="#FFFFFF">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--矩阵公式-->
<!--
<div class="cmath" align="center">
  `((1, 0),(1, 0))`
</div><br>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=80%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
          <li>LINUX_KERNEL_INTERRUPT_AND_EXCEPTION_INTRO</li>
        
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar_2.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
