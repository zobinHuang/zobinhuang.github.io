<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Exo 2:300,300italic,400,400italic,700,700italic|Caveat:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"post","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     p{margin-left: 15px; margin-right: 15px;}     #table th{text-align:center;}     #table td{text-align:center;}     .div_licence{font-size: 16px; wo">
<meta property="og:type" content="website">
<meta property="og:title" content="数据结构：树">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     p{margin-left: 15px; margin-right: 15px;}     #table th{text-align:center;}     #table td{text-align:center;}     .div_licence{font-size: 16px; wo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/xxx.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_2.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/full_binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/half_full_binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/complete_binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/seq_binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/link_binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/in_order_traversal.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/preorder_traversal.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/post_order_traversal.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_in_order_traversal.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_in_order_traversal.gif">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_in_order_traversal_2.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_3.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/build_binary_tree.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_insert.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_delete.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_rebuild.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/binary_tree_convert.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/pic/ordered_binary_tree.png">
<meta property="article:published_time" content="2022-02-10T14:39:11.852Z">
<meta property="article:modified_time" content="2021-09-07T12:09:21.000Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/Basic_Tree/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>数据结构：树 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lovin' Tech with Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about-me-(关于我)">

    <a href="/sec_about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me (关于我)</a>

  </li>
        <li class="menu-item menu-item-library-(知识库)">

    <a href="/sec_learning/" rel="section"><i class="fa fa-duotone fa-book fa-fw"></i>Library (知识库)</a>

  </li>
        <li class="menu-item menu-item-music-(独立音乐人)">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>Music (独立音乐人)</a>

  </li>
        <li class="menu-item menu-item-thoughts-(想法)">

    <a href="/sec_thoughts/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Thoughts (想法)</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">数据结构：树
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
            <li><a href="/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/">DATA_STRUCTURE_AND_ALGORITHM_DATA_STRUCTURE</a></li>
          <li>BASIC_TREE</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    p{margin-left: 15px; margin-right: 15px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
</style>
<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
</head>

<body>

<div align="center" class="div_indicate_source">
<h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：Mar.5 2021</i></font></h4>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<!--标题-->
<h2>1. 树的一些术语</h2>
<div class="div_learning_post">
<p>
<h4>(1) 结点</h4>
&nbsp;&nbsp;&nbsp;&nbsp;① <b>根结点</b>：没有前驱，仅有后继的树结点
<br>&nbsp;&nbsp;&nbsp;&nbsp;② <b>分支结点</b>：有且仅有一个前驱，可以有多个后继的树结点
<br>&nbsp;&nbsp;&nbsp;&nbsp;③ <b>叶结点</b>：没有前驱，仅有后继的树结点

<h4>(2) 度与深度</h4>
&nbsp;&nbsp;&nbsp;&nbsp;① <b>结点的度</b>：该结点拥有的子树数目
<br>&nbsp;&nbsp;&nbsp;&nbsp;② <b>树的度</b>：最大的结点度
<br>&nbsp;&nbsp;&nbsp;&nbsp;③ <b>深度</b>：最大的层次数
</p>
</div>

<h2>2. 二叉树 (Binary Tree)</h2>
<div class="div_learning_post">
<div align="center">
  <img src="./pic/binary_tree.png" width=500px>
</div>

<h4>(1) 定义（递归定义）</h4>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;或为空（空二叉树，结点数为0），或由根的两棵互不相交的左、右子树组成，其左右子树又分别是二叉树。
</p>

<h4>(2) 性质</h4>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;(a) 在第i层上最多有 <span>`2^(i-1)`</span> 个结点（i从1开始）
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(b) 深度为 <span>`k`</span> 的二叉树，最多有 <span>`\sum_{i=1}^{k}2^k = (a_1(1-q^n))/(1-q) = (2^0(1-2^k))/(1-2) = 2^k-1`</span> 个结点
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(c) 设叶结点的个数为 <span>`n_0`</span>，度为2的结点个数为 <span>`n_2`</span>，则存在关系： <span>`n_0 = n_2 + 1`</span>，即叶结点比度为2的结点的个数多一个。证明如下：
</p>

<div align="center">
  <img src="./pic/binary_tree_2.png" width=300px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;设叶结点的个数为 <span>`n_0`</span>，有一个孩子的结点的个数为 <span>`n_1`</span>，有两个孩子的结点的个数为 <span>`n_2`</span>，结点总个数为 <span>`n`</span>，则可以得到条件：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>`n = n_0 + n_1 + n_2`</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>`n = 分支的个数 + 1`</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;设分支个数为 <span>`B`</span>，则可以得到条件：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>`B = 2n_2 + n_1`</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;综合上述三式，可以得到：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>`n = 2n_2 + n_1 + 1 = n_0 + n_1 + n_2`</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故 <span>`n_0 = n_2 + 1`</span>
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(d) <b>满二叉树 (full binary tree)</b>和<b>半满二叉树 (half-full binary tree)</b>：
</p>

<div align="center">
  <img src="./pic/full_binary_tree.png" width=300px>
</div>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;<b>满二叉树</b>：所有的结点要么有两个孩子，要么一个也没有。所有的叶结点都位于同一层。
</p>

<div align="center">
  <img src="./pic/half_full_binary_tree.png" width=300px>
</div>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;<b>半满二叉树</b>：深度为 <span>`K`</span> 的二叉树，<span>`K－1`</span> 层是满二叉树，<span>`K`</span> 层节点个数不足<span>`2^(K－1)`</span> 个。其中，<b>完全二叉树</b>是一种特殊的半满二叉树，这种半满二叉树最后一层节点从左至右依次排列，没有间断。
</p>

<div align="center">
  <img src="./pic/complete_binary_tree.png" width=300px>
</div>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;(e) 具有n个节点的完全二叉树，深度为 <span>`[\log_2n]+1`</span>，其中 <span>`[ ]`</span> 是取整符号。且如果对结点数为 <span>`n`</span> 的完全二叉树自上而下，从左至右依次编号，如上图所示，则节点 <span>`i`</span> 的父结点为 <span>`[i/2]`</span>，且：
<br>&nbsp;&nbsp;&nbsp;&nbsp;如果 <span>`2i\leqn`</span>，则节点 <span>`i`</span> 的左后继是 <span>`2i`</span>；如果 <span>`2i\geqn`</span>，则 <span>`i`</span>无左后继；
<br>&nbsp;&nbsp;&nbsp;&nbsp;如果 <span>`2i+1\leqn`</span>，则结点 <span>`i`</span> 的右后继是 <span>`2i+1`</span>；如果 <span>`2i+1\geqn`</span>，则结点 <span>`i`</span>无左后继。
</p>

<h4>(3) 二叉树的存储</h4>

<div align="center">
  <img src="./pic/seq_binary_tree.png" width=500px>
</div>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;(a) <b>顺序存储结构</b>：所有结点依次存放在一块连续的内存空间中，将完全二叉树从上到下，从左到右编号后，结点号码可作为数组的下标，从而将完全二叉树顺序存储下来。基于上面讨论的性质(e)，当给出任意结点 <span>`i`</span>，则可知道它的父结点为 <span>`[i/2]`</span>，两个孩子分别为 <span>`2i`</span> 和 <span>`2i＋1`</span> （如果存在的话）。一般的二叉树相对于同样深度的完全二叉树，缺失了部分结点，在顺序存储时，这些位置要空出来。以维持结点编号之间的父子换算关系。顺序存储结构只适合存满二叉树和完全二叉树，对其他树的存储将会造成空间的浪费。具体的实现方法是用一维数组来实现。
</p>

<div align="center">
  <img src="./pic/link_binary_tree.png" width=500px>
</div>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;(b) <b>链式存储结构</b>：如上图所示，也可以用链表实现二叉树，即二叉链表。
</p>

<h4>(4) 二叉树的遍历</h4>
<h5>(a) 基本概念</h5>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;二叉树的遍历即按某种次序访问树中每一个结点且每一个结点只访问一次。根据对根的访问顺序，可以有3种遍历方式：先序遍历（先根遍历），中序遍历（中根遍历），以及后序遍历（后根遍历），具体如下所示，忘记的时候可以自己推一推。
</p>

<div align="center">
  <img src="./pic/in_order_traversal.png" width=500px>
</div>

<div align="center">
  <img src="./pic/preorder_traversal.png" width=500px>
</div>

<div align="center">
  <img src="./pic/post_order_traversal.png" width=500px>
</div>

<h5>(b) 中序遍历算法的实现</h5>

<div align="center">
  <img src="./pic/binary_tree_in_order_traversal.png" width=300px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;<b>· 基本思路</b>：从根x开始，
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 找到B，但不访问B
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 根据B找到A，访问A
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. <b>回溯</b>B，访问B
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 根据B找到C，访问C
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. C访完了，<b>回溯</b>X
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 实现法一</b>：利用栈实现回溯
</p>

<div align="center">
  <img src="./pic/binary_tree_in_order_traversal.gif" width=500px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;利用栈实现的算法步骤：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 1</b>. 树（子树）根入栈，不访问
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 2</b>. 左子树入栈，左子树的各子树根依次入栈即反复进行步骤1
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 3</b>. 当左子树为空时，出栈，访问根结点
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 4</b>. 根节点右子树入栈（新树入栈，到步骤1去遍历右子树）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 5</b>. 当右子树为空时，出栈，访问（祖先）爷结点，将爷结点的右子树入栈（新树入栈，回到步骤1)
</p>

<div align="center">
  <img src="./pic/binary_tree_in_order_traversal_2.png" width=300px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;实际上，如上图所示，根据上面的5个步骤，若结点 <span>`A_1`</span> 的左子树为空，结点 <span>`A_1`</span> 就会作为栈顶元素会被 <b>①出栈</b> 并 <b>②访问</b>，随后就会 <b>③前往结点 <span>`A_1`</span> 的右子树</b>。而当结点 <span>`A_1`</span> 的右子树也为空时（即 <span>`A_2`</span> 不存在时），实际上对以 <span>`A_1`</span> 为根节点的子树的访问已经结束，需要回溯到 <span>`A_1`</span> 的父节点 <span>`A_0`</span>。结点 <span>`A_1`</span> 出栈后，此时栈中的栈顶实际上就变成了 <span>`A_1`</span>  的右子树根节点 <span>`A_2`</span> 的爷结点 <span>`A_0`</span>，因此接下来的操作是将栈顶元素（此时是 <span>`A_0`</span> ）<b>①出栈</b> <b>②访问</b> <b>③前往右子树</b>三步。此时我们发现规律，只要结点的左子树或者右子树不存在，对栈的操作都是 <b>①出栈</b> <b>②访问</b> <b>③前往右子树</b> 三步，因此我们可以将上面的 <b>STEP 3</b> 和 <b>STEP 5</b>合并，变成：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 1</b>. 树（子树）根入栈，不访问
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 2</b>. 左子树入栈，左子树的各子树根依次入栈即反复进行步骤1
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 3</b>. 当子树为空时，出栈，访问根结点
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>STEP 4</b>. 根节点右子树入栈（新树入栈，到步骤1去遍历右子树）
<br>&nbsp;&nbsp;&nbsp;&nbsp;根据上面的分析，下面我们来看看具体的实现方式：
</p>
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = tree-&gt;root;</span><br><span class="line"><span class="keyword">while</span>( !end_of(tree) )&#123;</span><br><span class="line">  <span class="keyword">if</span>( p != <span class="literal">NULL</span> )&#123;</span><br><span class="line">    push(<span class="built_in">stack</span>, p)</span><br><span class="line">    p = p-&gt;Lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p = pop(<span class="built_in">stack</span>); <span class="comment">//出栈</span></span><br><span class="line">    process(p);     <span class="comment">//访问</span></span><br><span class="line">    p = p-&gt;Rchild;  <span class="comment">//前往右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="div_learning_post">
<p>
&nbsp;&nbsp;&nbsp;&nbsp;此时我们就剩下一个遗留问题，上面代码中的 end_of(tree) 该如何实现呢？即如何判断树已经被我们遍历完了呢？
</p>

<div align="center">
  <img src="./pic/binary_tree_3.png" width=300px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;首先，是否能用 <b>栈空</b> 作为等价条件呢？若我们使用它作为结束条件，我们以上图的二叉树为例子，当结点A的左子树遍历完时，此时A会被 <b>①出栈</b>，<b>②访问</b>，遍历指针p会 <b>③前往右子树（即结点K）</b>，此时栈为空。当重新回到循环进入条件时，<b>栈空</b> 的条件成立，循环退出。但是很明显，A的右子树全部都没有被访问到，因此 <b>栈空</b> 不能简单地作为退出循环的条件。
<br>&nbsp;&nbsp;&nbsp;&nbsp;若要 使用 <b>栈空</b> 作为判断条件，最简单的解决办法就是在初始化的时候在栈中就加入一个假的元素，即在遍历的过程中，栈底一直是有一个假元素存在的，这样在经历上面A被弹出的情况时，仍然可以继续循环将A的右子树遍历完，最后在弹出K时，紧随其后的就会把这个假元素也弹出来（K的右子树为空），然后再退出循环。
<br>&nbsp;&nbsp;&nbsp;&nbsp;我们也可以使用另一种更简单的方法，基于我们上面的讨论我们发现，当A被弹出栈时，虽然栈已经为空，但是此时遍历指针p指向的是A的右子树根节点K；而当K被弹出栈时，此时栈也为空，且访问指针p指向的是K的右子树根节点，但是K已经没有右子树，所以p为nullptr。即当二叉树真正被遍历完时，需要同时满足 <b>栈空</b> 和 <b>访问节点为空</b> 两个条件，因此我们可以将循环退出条件做相应修改，得到：
</p>
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = tree-&gt;root;</span><br><span class="line"><span class="keyword">while</span>( p!=<span class="literal">nullptr</span> || !isEmpty(<span class="built_in">stack</span>) )&#123;</span><br><span class="line">  <span class="keyword">if</span>( p != <span class="literal">NULL</span> )&#123;</span><br><span class="line">    push(<span class="built_in">stack</span>, p)</span><br><span class="line">    p = p-&gt;Lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p = pop(<span class="built_in">stack</span>); <span class="comment">//出栈</span></span><br><span class="line">    process(p);     <span class="comment">//访问</span></span><br><span class="line">    p = p-&gt;Rchild;  <span class="comment">//前往右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 实现法二</b>：利用递归实现回溯
<br>&nbsp;&nbsp;&nbsp;&nbsp;使用递归的实现理解起来比较简单，如下所示：
</p>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">( root )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( root-&gt;Lchild != <span class="literal">NULL</span>)</span><br><span class="line">    inorder (root-&gt;Lchild);</span><br><span class="line">  process(root);</span><br><span class="line">  <span class="keyword">if</span>( root-&gt;Rchild != <span class="literal">NULL</span>)</span><br><span class="line">    inorder(root-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5>(c) 先序遍历算法的实现</h5>
<div class="div_learning_post">
<p>
&nbsp;&nbsp;&nbsp;&nbsp;基于上述对中序遍历算法的讨论，我们可以轻松得到先序遍历算法的实现如下：
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 实现法一</b>：利用栈实现回溯
</p>
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = tree-&gt;root;</span><br><span class="line"><span class="keyword">while</span>( p!=<span class="literal">nullptr</span> || !isEmpty(<span class="built_in">stack</span>) )&#123;</span><br><span class="line">  <span class="keyword">if</span>( p != <span class="literal">NULL</span> )&#123;</span><br><span class="line">    process(p);     <span class="comment">//访问</span></span><br><span class="line">    push(<span class="built_in">stack</span>, p)</span><br><span class="line">    p = p-&gt;Lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p = pop(<span class="built_in">stack</span>); <span class="comment">//出栈</span></span><br><span class="line">    p = p-&gt;Rchild;  <span class="comment">//前往右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="div_learning_post">
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 实现法二</b>：利用递归实现回溯
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">( root )</span></span>&#123;</span><br><span class="line">  process(root);</span><br><span class="line">  <span class="keyword">if</span>( root-&gt;Lchild != <span class="literal">NULL</span>)</span><br><span class="line">    preorder (root-&gt;Lchild);</span><br><span class="line">  <span class="keyword">if</span>( root-&gt;Rchild != <span class="literal">NULL</span>)</span><br><span class="line">    preorder(root-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>(d) 后序遍历算法的实现</h5>
<div class="div_learning_post">
<p>
&nbsp;&nbsp;&nbsp;&nbsp;和之前中序和前序算法不同，后续遍历的root节点要最后才能被访问，因此，若想访问某节点，就需要知道该节点的右节点是否已经被访问过。只有该节点的右节点为nullptr，或者已被访问过，那么该节点才能被访问，否则需要先将右节点访问完。为了判断该节点的右节点是否已经被访问过，需另外设一个记录指针tag来指示已经访问过的节点，如果之前访问过的节点tag恰为该节点的右节点，说明其右子树已经访问完，应该访问该节点。
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 实现法一</b>：利用栈实现回溯
</p>
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tnode_type *tag = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>( p != <span class="literal">NULL</span> || !isEmpty(<span class="built_in">stack</span>) )&#123;</span><br><span class="line">  <span class="keyword">if</span>( p != <span class="literal">NULL</span> )&#123;</span><br><span class="line">    push(<span class="built_in">stack</span>, p);</span><br><span class="line">    p = p-&gt;Lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p = gettop(<span class="built_in">stack</span>);<span class="comment">//弹栈前先判断栈顶节点的右孩子是否为空及其是否被访问</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rchild!=<span class="literal">NULL</span> &amp;&amp; p-&gt;Rchild!=tag) p = p-&gt;Rchild;<span class="comment">//当栈顶节点有右孩子并且没有被访问过，则移到栈顶节点的右孩子</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      process(p);</span><br><span class="line">      p=pop(<span class="built_in">stack</span>);</span><br><span class="line">      tag=p;</span><br><span class="line">      p=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 实现法二</b>：利用递归实现回溯
</p>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">( root )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( root-&gt;Lchild != <span class="literal">NULL</span>)</span><br><span class="line">    postorder (root-&gt;Lchild);</span><br><span class="line">  <span class="keyword">if</span>( root-&gt;Rchild != <span class="literal">NULL</span>)</span><br><span class="line">    postorder(root-&gt;Rchild);</span><br><span class="line">  process(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>

<h4>(5) 二叉树的建立</h4>
<div class="div_learning_post"> 

<div align="center">
  <img src="./pic/build_binary_tree.png" width=500px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;以上图为例，我们输入一串序列，其中用“_”（空格）代表空元素。下面以先序为例，列出二叉树具体构造方法：
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>思路一</b>：
</p>

</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_tree_preorder</span><span class="params">(tnode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*------------结点左子树的构建------------*/</span></span><br><span class="line">  <span class="comment">/*读取输入，若不为空则创建结点*/</span></span><br><span class="line">  <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    temp = create_node(ch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*将创建的结点（或空指针）挂载在左孩子下*/</span></span><br><span class="line">  root-&gt;Lchild = temp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*若左孩子不为空，则前往左孩子*/</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;Lchild != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    create_tree_preorder(root-&gt;Lchild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------结点右子树的构建------------*/</span></span><br><span class="line">  <span class="comment">/*读取输入，若不为空则创建结点*/</span></span><br><span class="line">  <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    temp = create_node(ch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*将创建的结点（或空指针）挂载在左右孩子下*/</span></span><br><span class="line">  root-&gt;Rchild = temp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*若左孩子不为空，则前往右孩子*/</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;Rchild != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    create_tree_preorder(root-&gt;Rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="div_learning_post"> 
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>思路二</b>：
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_tree_preorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  tnode* p;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    p = create_node(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;Lchild = create_tree_preorder();</span><br><span class="line">  p-&gt;Rchild = create_tree_preorder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>(5) 二叉树的插入和删除</h4>
<div class="div_learning_post"> 

<p>
&nbsp;&nbsp;&nbsp;&nbsp;<b>(a) 插入</b>：
</p>

<div align="center">
  <img src="./pic/binary_tree_insert.png" width=500px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;对于二叉树的插入，我们遵守的原则是保证插入后按照规定的遍历顺序遍历出来的树结点序列除了多了一个新结点外，其它结点在遍历顺序上连续且保持和原有不变。以上图为例，倘若我们采用中序遍历的方式，则插入前的遍历顺序是 <b>左 根 右</b>，那么在根节点的右孩子处插入新结点的话，我们应该把根节点原来的右子树挂载到新节点的左边，才能保证遍历顺序是 <b>左 根 右 new</b>。类比，如果插入的位置是在根节点的左孩子处，那么则需要把根节点原来的左子树挂载到新结点的右边，才能保证原有树遍历顺序保持连续且不变。
</p>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;<b>(b) 删除</b>：
</p>

<div align="center">
  <img src="./pic/binary_tree_delete.png" width=500px>
</div>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;对于二叉树的删除，我们遵守的原则是保证删除后二叉树的结点遍历顺序与删除前保持不变。以上图为例，倘若我们按照中序遍历的顺序，在删除之前，遍历顺序是 <b>爷 左 del 右</b>，我们在删除爷结点右子树的根，即del结点后，为了保证遍历顺序是 <b>爷 左 右</b>，则必须把从del上“剪”下来的左子保证树 <span>`T_L`</span> 挂在爷结点的右子树位置，把从del上“剪”下来的右子树 <span>`T_R`</span> 挂在 <span>`T_L`</span> 的右子树位置。类比，如果删除的位置是爷结点的左子树根节点del的话，则必须把从del上“剪”下来的右子树 <span>`T_R`</span> 挂在爷结点的左子树位置，把从del上“剪”下来的左子树 <span>`T_L`</span> 挂在 <span>`T_R`</span> 的左子树位置，才能保证删除后二叉树的结点遍历顺序与删除前保持不变。
</p>
</div>

<h4>(6) 二叉树的重构</h4>
<div class="div_learning_post"> 

<p>
&nbsp;&nbsp;&nbsp;&nbsp;在没有使用空格标明空孩子的情况下，我们无法根据单一序列来重构二叉树。只有在给出 <b>先序遍历序列</b>&<b>中序遍历序列</b> 或 <b>后序遍历序列</b>&<b>中序遍历序列</b> 的情况下（总之一定要有中序序列），我们才可以对一个二叉树进行重构。具体例子如下所示：
</p>

<div align="center">
  <img src="./pic/binary_tree_rebuild.png" width=500px>
</div>
</div>

<h4>(7) 树的二叉表示</h4>
<div class="div_learning_post"> 
<p>
&nbsp;&nbsp;&nbsp;&nbsp;如下图所示，是将非二叉树转化为二叉树的方法
</p>
<div align="center">
  <img src="./pic/binary_tree_convert.png" width=500px>
</div>
</div>

<h4>(8) 森林转化为二叉树</h4>
<div class="div_learning_post"> 
<p>
&nbsp;&nbsp;&nbsp;&nbsp;将森林转化为二叉树的原则是：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a) 先将森林的每颗树都转换为二叉树
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b) 选定其中的一颗树，将其它树的根结点以右孩子的方式串起来。
</p>
</div>

<h4>(9) 二叉排序树</h4>

<div align="center">
  <img src="./pic/ordered_binary_tree.png" width=300px>
</div>

<div class="div_learning_post">
&nbsp;&nbsp;&nbsp;&nbsp;<b>· 定义（递归定义）</b>：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a) 或为空树，或具有如下性质；
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b) 左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于或等于根结点的关键字；
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c) 左、右子树又各是一棵二叉排序树。
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>· 建立二叉排序树算法</b>：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于二叉排序树建立算法，算法的输入是一组无序元素，输出是一颗二叉排序树，算法（元素插入）的基本思路如下：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a) 先将新元素与根结点比较，若小于根节点，则插入左子树中；若大于等于根结点，则插入右子树中；
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b) 再将新元素与子树的根结点比较，直到某结点k，使得下面有一种情况发生：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新元素小于k，且k左子树为空，则成为k的左孩子；
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新元素大于等于k，且k右子树为空，则成为k的右孩子。
<br>&nbsp;&nbsp;&nbsp;&nbsp;具体代码如下所示：
</div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p = tree-&gt;root;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(new_node-&gt;data &lt; p-&gt;data)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Lchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      p-&gt;Lchild = new_node;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p = p-&gt;Lchild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      p-&gt;Rchild = new_node;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p = p-&gt;Rchild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<!--ref-->
<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>
1. 电子科技大学, <b>数据结构与算法 课程课件（2018秋季）</b>
</p>
</div>

</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
            <li><a href="/sec_learning_backup/Data_Structure_And_Algorithm_Data_Structure/">DATA_STRUCTURE_AND_ALGORITHM_DATA_STRUCTURE</a></li>
          <li>BASIC_TREE</li>
        
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar_2.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
