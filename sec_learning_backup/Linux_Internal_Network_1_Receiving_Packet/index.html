<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zobinhuang.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"hide","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#FF4136","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="全流程：Linux 内核是如何收包的？&lt;font color&#x3D;&quot;red&quot;&gt;[长文]&lt;&#x2F;font&gt;">
<meta property="og:url" content="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:locale">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/pic/xxx.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/pic/pci_pcie.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/pic/PCI_bar_1.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/pic/PCI_bar_2.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/pic/bus_address.png">
<meta property="article:published_time" content="2022-02-10T14:39:10.082Z">
<meta property="article:modified_time" content="2021-11-28T14:36:17.723Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="http://www.zobinhuang.com:10082/sec_learning_backup/Linux_Internal_Network_1_Receiving_Packet/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>全流程：Linux 内核是如何收包的？<font color="red">[长文]</font> | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Loves Tech & Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/sec_about/" rel="section"><i class="fa fa-address-card fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-知识库">

    <a href="/sec_learning/" rel="section"><i class="fa fa-book-open fa-fw"></i>知识库</a>

  </li>
        <li class="menu-item menu-item-每周大盘">

    <a href="/sec_weekly/" rel="section"><i class="fa fa-newspaper fa-fw"></i>每周大盘</a>

  </li>
        <li class="menu-item menu-item-进度">

    <a href="/sec_schedule/" rel="section"><i class="fa fa-calendar-alt fa-fw"></i>进度</a>

  </li>
        <li class="menu-item menu-item-独立音乐人">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>独立音乐人</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="cn">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">全流程：Linux 内核是如何收包的？<font color="red">[长文]</font>
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
          <li>LINUX_INTERNAL_NETWORK_1_RECEIVING_PACKET</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_concurrent_img{padding: 10px 10px; display: flex; align-items:center; justify-content:center;}
    @media(max-width: 768px) {
      .div_concurrent_img{flex-direction: column;}
    }
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_border{
      margin-bottom: 20px;
      padding: 10px 10px; 
      font-size: 16px; 
      word-spacing:0px;  
      border:1px solid black;
    }
    .div_learning_post_background{
      background-color:#E3E2E2;
      padding: 10px 40px; 
      font-size: 16px;
      word-spacing:0px;  
      border-radius: 15px;
      margin-bottom: 15px;
    }
    .div_learning_post_background p{
      margin: 0px;
    }
</style>

<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
<!--支持矩阵显示-->
<script type="text/javascript">
  run_maths = function() {
    if (document.querySelector('[class*="cmath"]') !== null) {
      if (typeof (mjax_path)=='undefined') { mjax_path='https://cdn.jsdelivr.net/npm/mathjax@2'; }
      if (typeof (mjax_config)=='undefined') { mjax_config='AM_CHTML'; }
      smjax = document.createElement ('script');
      smjax.setAttribute('src',`${mjax_path}/MathJax.js?config=${mjax_config}`);
      smjax.setAttribute('async',true);
      document.getElementsByTagName('head')[0].appendChild(smjax);
    }
  };
  if (document.readyState === 'loading') {  
    window.addEventListener('DOMContentLoaded', run_maths); 
  } else { 
    run_maths(); 
  }
</script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：Oct.31 2021</i></font></h4>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center" bgcolor="#FFFFFF">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--矩阵公式-->
<!--
<div class="cmath" align="center">
  `((1, 0),(1, 0))`
</div>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_xxx"><font color="blue"><b>xxx</b></font></a>：xxx
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#1_xxx"><font color="blue">xxx</font></a>：xxx
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_xxx"><font color="blue"><b>xxx</b></font></a>：xxx
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 3. <a href="#3_xxx"><font color="blue"><b>xxx</b></font></a>：xxx

  </div>
</div>

<!--标题-->
<h2><a name="1_xxx">x. xxx</a></h2>
<div class="div_learning_post">
  <h3><a name="1_xxx_1"></a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;
</div>

<h2><a name="2_driver">2. IGB 网卡驱动分析</a></h2>
<div class="div_learning_post">
  <h3><a name="2_driver_1">2.1 前置知识: PCI 与 PCIe 总线</a></h3>

  <h4>&nbsp;&nbsp;&nbsp;&nbsp;(a) PCI 总线结构</h4>
  <div align="center">
    <img src="./pic/pci_pcie.png" width=700px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上左图所示，PCI 是一种总线型的设计。系统中的北桥上方连接了 CPU 和 内存，管理的是 <font color="red"><b>存储域</b></font> 的地址空间，北桥下方连接的是PCI总线，管理的是 <font color="red"><b>PCI域</b></font> 的空间。也就是说，“CPU和内存”，“PCI总线上的设备” 这两者是独立寻址的。PCI 设备的定位方法是通过 <font color="red"><b>"总线(bus) + 设备(device) + 功能(function)"</b></font> 组成的，即在某条 PCI 总线上的某个 PCI 设备上的某个功能，根据这三者来定位 PCI 设备的方法被称为 <b>“PCI 寻址”</b>。一颗 PCI 设备树一共支持 256 条总线，一条总线上支持 32 个设备，一个设备上又支持 8 个功能。
  <br>&nbsp;&nbsp;&nbsp;&nbsp;总线发展到 PCIe 则变为一种端到端型的设计，如上右图所示，PCIe 设备通过 PCIe Switch 进行路由，不再是总线型的通信。另外与 PCI 有差别的就是，隔离 <font color="red"><b>存储域</b></font> 和 <font color="red"><b>PCI域</b></font> 的设备在 PCIe 标准中被定义为 <b>Root Complex</b>。而 <b>“PCIe 寻址”</b> 方法与 “PCI 寻址” 无太大差别，也是通过 <b>"总线(bus) + 设备(device) + 功能(function)"</b></font> 对设备进行定位。

  <h4>&nbsp;&nbsp;&nbsp;&nbsp;(b) PCI 设备内存</h4>
  <h5>&nbsp;&nbsp;&nbsp;&nbsp;1. PCI 设备内存类型 和 访问方式</h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;PCI 设备上的存储器分为两种：<b>寄存器</b> 和 <b>内存</b>，前者一般用于存储设备的配置参数，其中有些寄存器是 read-only 的，由厂商在出厂时写死的；后者一般用于存储设备处理的一些数据，比如 网卡上的网络数据包，SSD 中存储的数据 Cache 等。
  <br>&nbsp;&nbsp;&nbsp;&nbsp;Host 访问 PCI 设备上存储器的编址方式有两种：<b>内存空间 (Memory Space)</b> 和 <b>IO空间 (IO Space)</b>。前者即主机内存地址的寻址空间，即 PCI 设备会占据部分主机内存的地址空间；后者是 x86 特有的一个空间，是与内存空间相独立的一个空间。当外部设备的存储器映射到 IO 空间时，主机只能使用 <b>IO 端口操作函数</b> 对数据进行读写，如 inb(), inbw(), inl(); outb(), outw(), outl() 等，这被称为 <font color="red"><b>IO 端口 (IO Port)</b></font>；当外部设备的存储器映射到的是内存空间时，主机则可以使用访问内存的方式对外部设备存储器进行操作，这种方式被称为 <font color="red"><b>IO 内存 (IO Memory)</b></font><sup>[4]</sup>。
  </p>
  <h5>&nbsp;&nbsp;&nbsp;&nbsp;2. PCI Configuration Space</h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;PCI 标准规定了每个 PCI 设备功能都必须具备配置寄存器，即 256-Byte 的 Configuration Space Registers 的组织格式，如下表所示，具体各个寄存器的用途也在表中有所阐述。值得注意的是，我们分析的是 Header Type 为 0x00 的 PCI Configuration Space Register，即 PCI 设备卡的配置寄存器。此外还有诸如 Header Type 为 0x01 的 PCI 桥等的配置寄存器，此处不做介绍。
  </p>
  <table border="1" align="center">
    <caption>PCI Configuration Space Registers</caption>
    <tr>
      <th>register</th>
      <th>offset</th>
      <th>bits 31-24</th>
      <th>bits 23-16</th>
      <th>bits 15-8</th>
      <th>bits 7-0</th>
    </tr>
    <tr>
      <td>00</td>
      <td>00</td>
      <td colspan=2>Device ID<br><font color="red">&nbsp;&nbsp;&nbsp;&nbsp;用于标识硬件制造厂商，制造商必须向 PCI Special Interest Group 申请一个全球唯一的编号才能够出厂设备<sup>[3]</sup></font></td>
      <td colspan=2>Vendor ID<br><font color="red">&nbsp;&nbsp;&nbsp;&nbsp;用于表示厂商下的某个设备，由厂商自己决定，无需对外申请。Device ID 和 Vendor ID组成了唯一的 32 位的设备标识符，通常被称为 <b>签名(Signature)</b><sup>[3]</sup></font></td>
    </tr>
    <tr>
      <td>01</td>
      <td>04</td>
      <td colspan=2>Status</td>
      <td colspan=2>Command</td>
    </tr>
    <tr>
      <td>02</td>
      <td>08</td>
      <td>Class Code<br><font color="red">&nbsp;&nbsp;&nbsp;&nbsp;用于标识该外部设备属于哪个类。某些驱动程序可以支持多个相似的设备，这些设备的 <b>签名</b> 都不一样，驱动程序则能根据 Class Code 字段识别<sup>[3]</sup>。</font></td>
      <td>Subclass</td>
      <td>Prog IF</td>
      <td>Revision ID</td>
    </tr>
    <tr>
      <td>03</td>
      <td>0C</td>
      <td>BIST</td>
      <td>Header Type</td>
      <td>Latency Timer</td>
      <td>Cache Line Size</td>
    </tr>
    <tr>
      <td>04</td>
      <td>10</td>
      <td colspan=4>Base Address #0 (BAR0)</td>
    </tr>
    <tr>
      <td>05</td>
      <td>14</td>
      <td colspan=4>Base Address #1 (BAR1)</td>
    </tr>
    <tr>
      <td>06</td>
      <td>18</td>
      <td colspan=4>Base Address #2 (BAR2)</td>
    </tr>
    <tr>
      <td>07</td>
      <td>1C</td>
      <td colspan=4>Base Address #3 (BAR3)</td>
    </tr>
    <tr>
      <td>08</td>
      <td>20</td>
      <td colspan=4>Base Address #4 (BAR4)</td>
    </tr>
    <tr>
      <td>09</td>
      <td>24</td>
      <td colspan=4>Base Address #5 (BAR5)</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td colspan=4><font color="red">每一张 PCI 卡上的每一个功能都会有这六个 BAR 寄存器，BAR 寄存器的作用可以被理解为：<sup>[3]</sup><br>&nbsp;&nbsp;&nbsp;&nbsp;(1)
      PCI 制造商会在 BAR 寄存器中以某种方式 (下面会解释) 向操作系统说明它想要操作系统为它分配多少内存，以及这些内存要映射的是 <b>内存空间</b> 还是 <b>IO空间</b>。<br>&nbsp;&nbsp;&nbsp;&nbsp;(2) 操作系统在初始化 PCI 设备的时候会读取这几个 BAR 寄存器，并根据要求为这些设备分配相应内存空间，并且会将分配的内存空间初始地址写回到 BAR 寄存器中。</font></td>
    </tr>
    <tr>
      <td>0A</td>
      <td>28</td>
      <td colspan=4>Cardbus CIS Pointer</td>
    </tr>
    <tr>
      <td>0B</td>
      <td>2C</td>
      <td colspan=2>Subsystem ID</td>
      <td colspan=2>Subsystem Vendor ID</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td colspan=4><font color="red">Subsystem ID, Subsystem Vendor ID 这两个字段用来进一步识别设备。某些外设可能是一个通用的接口芯片，接上不同的子设备可能会是完全不同的用途，这个字段就用于继续标明子设备，以让驱动程序识别它所关心的实际设备。<sup>[3]</sup></font></td>
    </tr>
    <tr>
      <td>0C</td>
      <td>30</td>
      <td colspan=4>Expansion ROM base address</td>
    </tr>
    <tr>
      <td>0D</td>
      <td>34</td>
      <td colspan=3>Reserved</td>
      <td>Capabilities Pointer</td>
    </tr>
    <tr>
      <td>0E</td>
      <td>38</td>
      <td colspan=4>Reserved</td>
    </tr>
    <tr>
      <td>0F</td>
      <td>3C</td>
      <td>Max latency</td>
      <td>Min Grant</td>
      <td>Interrupt PIN</td>
      <td>Interrupt Line</td>
    </tr>
  </table>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这些寄存器中，有标注红字的寄存器都是值得我们去关注的。其中 ，BAR 寄存器的工作方式值得我们继续探讨，因为它与外部设备与主机内存的交互这件事情有比较大的关系。我们都知道：主机访问外部设备存储器有两种方式，即 I/O端口 和 I/O内存。我们通过上表红字还知道 PCI 设备会通过 BAR 寄存器以某种方式告知主机它想要的内存映射方法。我们下面来看一下 BAR 寄存器这 32 位的组成，并且通过例子来理解这是如何实现的。
  </p>
  <table border="1" align="center">
    <caption>Memory Space BAR Layout</caption>
    <tr>
      <th>bits 31-4</th>
      <th>bit 3</th>
      <th>bits 2-1</th>
      <th>bit 0</th>
    </tr>
    <tr>
      <td>16-Byte Aligned Base Address</td>
      <td>Prefetchable</td>
      <td>Type</td>
      <td>Always 0</td>
    </tr>
  </table>
  <table border="1" align="center">
    <caption>I/O Space BAR Layout</caption>
    <tr>
      <th>bits 31-2</th>
      <th>bit 1</th>
      <th>bit 0</th>
    </tr>
    <tr>
      <td>4-Byte Aligned Base Address</td>
      <td>Reserved</td>
      <td>Always 1</td>
    </tr>
  </table>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上图所示，如果 PCI 设备想要的内存映射方式是 I/O内存 方式，则最低位为0，若为 I/O端口 方式则反之。我们重点看 Memory Space 的情况。bits 2-1 的 Type 字段用于指定 该 BAR 寄存器映射区域的大小。若为 0x00，则代表这个寄存器是 32 位宽的，可以映射到 32 位内存空间中的任意位置；若为 0x02，则代表这个寄存器是 64 位宽的，可以映射到 64 位内存空间的任意位置，值得注意的是，若映射的是 64 位宽的空间，则需要消耗 2 个 BAR寄存器用于记录操作系统分配的内存的起始地址。
  <br>&nbsp;&nbsp;&nbsp;&nbsp;我们通过例子讲解一下 BAR 寄存器是如何工作的。
  </p>
  <h5>&nbsp;&nbsp;&nbsp;&nbsp;(i) 在 32 位内存空间中申请 4k Bytes 的内存空间</h5>
  <div align="center">
    <img src="./pic/PCI_bar_1.png" width=500px>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<b>Step 1</b>：如图中（1）所示，未初始化的BAR的低比特 [11~4] 都是0，高比特 [31~12] 都是不确定的值。在初始化阶段，操作系统会向整个 BAR 都写 1，来确定 BAR 的可操作的最低位是哪一位。在上图的例子中，当前可操作的最低位为12，因此当前 BAR 申请的地址空间大小为 <span>`2^12 = 4kB`</span>。如果可操作的最低位为 20，则该 BAR 申请的地址空间大小为 <span>`2^20 = 1MB`</span>。
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<b>Step 2</b>：完成初始化（写1操作）之后，软件便开始读取BAR的值，来确定每一个 BAR 对应的地址空间大小和映射类型，具体在上面已经阐述。
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<b>Step 3</b>：最后一步是，软件向 BAR 的高比特写入地址空间的起始地址（Start Address）。如图中所示，为0xF900_0000。注意到操作系统此时写入的只有高 20 位 (高 4 字节)的地址值，低 20 位 (低 4 字节)自动默认为 0。能这么操作的原因是申请的地址是 4kB 对齐的，因此低 12 位肯定为0。
  </p>
  <h5>&nbsp;&nbsp;&nbsp;&nbsp;(ii) 在 64 位内存空间中申请 64M Bytes 的内存空间</h5>
  <div align="center">
    <img src="./pic/PCI_bar_2.png" width=500px>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;原理同上，注意到此时我们是在 64 位的地址空间中申请内存，因此我们需要两个 BAR 寄存器来存储我们的起始地址。同样的，我们观察到此时操作系统写入的只有高 38 位 (高 6 字节半) 的地址，低 26 位是默认为 0 的，道理是一样的，我们申请的是 <span>`2^26 = 64MB`</span> 的空间，给出来的地址是 64MB 对齐的，所以低 26 位肯定是0。
  </p>

  <h3><a name="2_driver_2">2.2 PCI 初始化</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在编译驱动模块的时候，编译器将检测到名为 <code>MODULE_DEVICE_TABLE</code> 的宏，这是它将会 export 一份表格信息，这份表格信息描述了这个 PCI 设备驱动能够控制和处理的 PCI 设备 ID。我们可以在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L63">drivers/net/ethernet/intel/igb/igb_main.c</a> 里找到这份表格信息，以及相应的 export 操作，如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> <span class="title">igb_pci_tbl</span>[] =</span> &#123;</span><br><span class="line">  &#123; PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_1GBPS) &#125;,</span><br><span class="line">  &#123; PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_SGMII) &#125;,</span><br><span class="line">  &#123; PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* required last entry */</span></span><br><span class="line">  &#123;<span class="number">0</span>, &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(pci, igb_pci_tbl);</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;读者可能会好奇宏 <code>MODULE_DEVICE_TABLE</code> 是如何进行 export 的。对于 PCI 设备来说，<code>MODULE_DEVICE_TABLE</code> 宏将会生成一个名为 <code>__mod_pci_device_table</code> 的局部变量，这个局部变量将指向第二个参数，即一份表格。当内核在被构建的时候，<code>depmod</code> 程序会在所有模块中搜索符号 <code>__mod_pci_device_table</code>，检测到了之后就会把这份表格添加到映射文件 <code>/lib/modules/KERNEL_VERSION/modules.pcimap</code> 中。当 <code>depmod</code> 结束之后，所有的 PCI 设备连同他们的模块名字都被该文件列出。当内核告知热插拔系统一个新的 PCI 设备被发现时，热插拔系统使用 <code>modules.pcimap</code> 文件来找寻恰当的驱动程序。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，宏 <code>MODULE_DEVICE_TABLE</code> 是定义在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/include/linux/module.h#L238">linux/module.h</a> 下的。如果读者朋友感兴趣的话，下面是它的定义：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/module.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MODULE</span></span><br><span class="line"><span class="comment">/* Creates an alias so file2alias.c can find device table. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_DEVICE_TABLE(type, name)					\</span></span><br><span class="line">extern typeof(name) __mod_##type##__##name##_device_table		\</span><br><span class="line">  __attribute__ ((unused, alias(__stringify(name))))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !MODULE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_DEVICE_TABLE(type, name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 <code>igb</code> 网卡驱动来说，它的模块初始化函数 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L658">igb_init_module</a> 十分简短，如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  igb_init_module - Driver Registration Routine</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  igb_init_module is the first routine called when the driver is</span></span><br><span class="line"><span class="comment">*  loaded. All it does is register with the PCI subsystem.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">igb_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">  pr_info(<span class="string">&quot;%s\n&quot;</span>, igb_driver_string);</span><br><span class="line">  pr_info(<span class="string">&quot;%s\n&quot;</span>, igb_copyright);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IGB_DCA</span></span><br><span class="line">  dca_register_notify(&amp;dca_notifier);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ret = pci_register_driver(&amp;igb_driver);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(igb_init_module);</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看见，初始化函数的核心其实就是调用了 <code>pci_register_driver</code>，这个函数其实向内核中注册了一系列的指针，其中大部分指针是函数指针。内核利用这些驱动模块注册的函数来启动 PCI 设备。变量 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L222">igb_driver</a> 的定义如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">igb_driver</span> =</span> &#123;</span><br><span class="line">  .name     = igb_driver_name,</span><br><span class="line">  .id_table = igb_pci_tbl,</span><br><span class="line">  .probe    = igb_probe,</span><br><span class="line">  .remove   = igb_remove,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">  .driver.pm = &amp;igb_pm_ops,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  .shutdown = igb_shutdown,</span><br><span class="line">  .sriov_configure = igb_pci_sriov_configure,</span><br><span class="line">  .err_handler = &amp;igb_err_handler</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <h3><a name="2_driver_3">2.3 PCI 探针 (Probe)</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在系统上电的时候，内核的 PCI core 会在 <font color="blue">链路训练 (link training)</font> 阶段枚举系统中所有 PCI 总线上的所有 PCI 设备。对于各个找到的 PCI 设备，它会收集包括 vendor id，device id 在内的设备基本信息。然后，它会遍历所有的 PCI 驱动信息，找到适合当前枚举的这个 PCI 设备的驱动。这份被遍历的驱动信息就来自于上面我们介绍过的由宏 <code>MODULE_DEVICE_TABLE</code> 导出的表格。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;针对一个 PCI 设备，当 PCI core 找到一个合适的驱动程序后，它就会调用该驱动程序的一个叫做 <font color="blue">PCI 探针 (Probe)</font> 的函数。PCI 探针函数所会进行的操作如下所示：

  <div class="div_learning_post_border">
    <ol>
      <li>使能 PCI 设备</li>
      <li>请求 I/O 内存和 I/O 端口的映射范围</li>
      <li>设置 DMA 掩码</li>
      <li>注册驱动程序支持的 <code>ethtool</code> 函数</li>
      <li>开启所需的看门狗任务 (watchdog task)</li>
      <li>创建、初始化和注册 <code>net_device_ops</code> 结构体，这个结构体包含了各种函数指针，这些指针所指向的各个函数对应了对网络设备的各种操作，包括打开设备、向网络发送数据以及设置 MAC 地址等</li>
      <li>创建、初始化和注册 <code>net_device</code> 结构体，该结构体代表了一个网络设备</li>
    </ol>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;细心的读者会发现，上面我们展示过的 IGB 网卡驱动模块的初始化函数 <code>igb_init_module</code> 调用 <code>pci_register_driver</code> 注册的一系列函数指针中，就包括了这样一个探针函数 <code>igb_probe</code>。我们可以在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L3143">drivers/net/ethernet/intel/igb/igb_main.c:</a> 中找到这个探针函数的定义。下面我们就分布来分析这个探针函数。

  <h5><a name="2_driver_3_1">(1) PCI 初始化</a></h3>

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">igb_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  err = pci_enable_device_mem(pdev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  err = dma_set_mask_and_coherent(&amp;pdev-&gt;dev, DMA_BIT_MASK(<span class="number">64</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  err = pci_request_mem_regions(pdev, igb_driver_name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  pci_enable_pcie_error_reporting(pdev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  pci_set_master(pdev);</span><br><span class="line"> </span><br><span class="line">  pci_save_state(pdev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，<code>pci_enable_device_mem</code> 将会初始化设备，包括唤醒设备、使能相关内存区域等。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>dma_set_mask_and_coherent</code> 将会被用于设置 DMA 掩码。下面是有关于设备地址问题的一些补充：

  <div class="div_learning_post_border">
  <div align="center"><h4>Vitural & Physical & Bus Address 以及 DMA 动态映射</h4></div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_2_Computer_Arch/index.html#3_address_space">学习汇编之前需要理解的计算机组成原理</a> 中介绍过，从 CPU 的角度出发，它访问设备内存有两种方式：MMIO 和 PMIO，其中 MMIO 指的是 CPU 可以使用基于访问常规内存的方式来访问设备上的寄存器。我们又知道，内核和用户程序使用的都是 Virtual Memory 的方式来管理内存，当 CPU 收到一个 Virtual Memory Address 时，它将会基于页目录和页表，利用 <font color="blue">Memory Manage Unit (MMU)</font> 来将 Virtual Memory Address 转化为 Physical Memory Address，以最终访问实际内存位置。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果说 Virtual Memory Address Space 是 CPU 管理内存的方式，而 Physical Memory Address Space 是实际内存空间的话，<font color="blue">Bus Memory Address Space</font> 就是设备管理内存的方式。设备将自己的寄存器映射到了 MMIO 地址空间上，或者对主机内存进行 DMA 读取，所使用的地址都是 Bus Memory Address。将 Virtual Memory Address 映射到 Physical Memory Address 的处理单元是 MMU，而将 Bus Memory Address 映射到 Physical Memory Address 的处理单元则是 <font>Host Bridge</font> 或者 <font color="blue">IOMMU</font>。

  <div align="center">
    <img src="./pic/bus_address.png" width=90%>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在系统上电后的设备枚举 (enumeration) 阶段，内核会获取各个 I/O 设备的信息，包括它们请求使用 MMIO 方式映射的 Bus Memory Address，随后内核会配置 Host Bridge 进行相关映射。以 PCI 设备为例，借助上图来说，如果 PCI 设备有配置 BAR 寄存器的话，内核将会通过读取 BAR 寄存器来获取想要被映射的 Bus Memory Address [A]，然后通过配置主桥将地址 [A] 映射为一个 Physical Memory Address [B]。这个物理地址 [B] 会被存储在一个结构体中，并且会在系统的 <code>/proc/iomem</code> 文件中导出。当一个 Driver 声明自己对一个 Device 负责的时候，这个 Driver 通常会使用 <code>ioremap()</code> 来将 Phsical Memory Address [B] 映射到内核空间的一个 Virtual Memory Address [C] 中去，然后它就可以使用诸如 <code>ioread32(C)</code> 的方式来访问设备的 Bus Memory Address [A] 了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;假如一个设备支持 DMA 操作，那么相应控制的 Driver 将会使用 <code>kmalloc()</code> 或者其它类似的接口的方式申请一个 Buffer，Driver 将最后得到一个 Virtual Memory Address [X]。并且相应的将地址 [X] 映射为 Physical Memory Address [Y] 的页目录和页表表项也会准备就绪，因此从 CPU 侧访问物理内存的流程就被打通了。而对于 Device 侧访问内存的方向，<font color="blue">IOMMU</font> 将被用于将 Bus Memory Address [Z] 映射到物理内存地址 [Y]，因此当 Device 发起对 Bus Memory Space [Z] 的访问的时候，就能实际访问到物理地址 [Y]，这样一来 Device 侧访问内存的方向就也被打通了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在一些简单的系统中，设备 DMA 操作是可以直接访问 Phycial Memory Address 的。但是在其它的大部分系统中，都必须经过 IOMMU 的地址映射转换，也即存在 Bus Memory Address Space。对于 DMA 操作来说，IOMMU 的映射关系是由设备 Driver 配置的：Driver 会使用像 <code>dma_map_single()</code> 之类的接口，传入 Buffer 的内核空间 Virtual Memory Address [X]，这个接口将会在 IOMMU 上配置相关的映射关系，并且最终返回一个与 Virtual Memory Address [X], Physical Memory Address [Y] 对应的 Bus Memory Address [Z]。然后 Driver 会将 Bus Memory Address [Z] 告知 Device，这样 Device 就直到如何将数据通过 DMA 的方式放到系统内存 Buffer 中去了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在一些文档中，我们也会把设备用于访问 DMA Buffer 的 Bus Memory Address [Z] 叫做 <font color="blue">DMA Address</font>。默认来说，内核会假设一个设备支持 32-bits 的 DMA Address 寻址能力。假如我们的设备支持 64-bits 的 DMA Address 寻址能力，我们必须通过 <code>dma_set_mask_and_coherent</code> 显式地通知内核。
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于 IGB 网卡可以支持 64-bits 的 DMA Address，所以 <code>dma_set_mask_and_coherent</code> 传入了 <code>DMA_BIT_MASK(64)</code>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>pci_request_selected_regions</code> 向内存中申请了 PCI BAR 寄存器中请求的 MMIO 内存空间。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>pci_enable_pcie_error_reporting</code> 使能了 PCI Express Advance Error Reporting (p.s. 如果 PCI AER 被使能了的话)。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>pci_set_master</code> 使能了 DMA 操作。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>pci_save_state</code> 向设备上保存了 PCI Configuration Space。

  <h5><a name="2_driver_3_2">(2) Network Device 初始化</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们分析的 IGB Probe 函数，除了会做 PCI Specific 的初始化工作之外，更重要的工作是会做一些与网络设备相关的初始化工作，可以总结为如下几点，我们在本节进行逐点分析。

  <ol>
    <li>注册 <code>net_device_ops</code> 结构</li>
    <li>注册 <code>ethtool</code> 操作</li>
    <li>从网卡获取默认 MAC 地址</li>
    <li>设置 net_device 功能标志位 (feature flags)</li>
    <li>...</li>
  </ol>

  <div class="div_learning_post_border">
  <div align="center"><h4>注册 <code>net_device_ops</code> 结构</h4></div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，<code>net_device_ops</code> 结构体包含了各种函数指针，这些函数指针是 Kernel Networking Subsystem 需要的控制设备的函数。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">igb_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  netdev-&gt;netdev_ops = &amp;igb_netdev_ops;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;还是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L3213">/drivers/net/ethernet/intel/igb/igb_main.c</a> 中的 igb_probe 函数，如上所示，<code>net_device_ops</code> 类型的结构体变量 <code>igb_netdev_ops</code> 被装载到了 <code>net_device</code> 结构成员中。我们下面来看一下 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L2978">igb_netdev_ops</a> 变量的内容：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">igb_netdev_ops</span> =</span> &#123;</span><br><span class="line">  .ndo_open               = igb_open,</span><br><span class="line">  .ndo_stop               = igb_close,</span><br><span class="line">  .ndo_start_xmit         = igb_xmit_frame,</span><br><span class="line">  .ndo_get_stats64        = igb_get_stats64,</span><br><span class="line">  .ndo_set_rx_mode        = igb_set_rx_mode,</span><br><span class="line">  .ndo_set_mac_address    = igb_set_mac,</span><br><span class="line">  .ndo_change_mtu         = igb_change_mtu,</span><br><span class="line">  .ndo_do_ioctl           = igb_ioctl,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上所示，在内核中，抽象出了一系列的可以对网卡进行的操作，并且各个操作的具体实现随具体设备的变化而不同。像 <code>igb_open</code>，<code>igb_close</code> 这些具体实现都是由 Intel 针对自己的 NIC 产品开发出来的。我们在后面将会分析它们其中部分接口的具体内容。
  </div>

  <br>

  <div class="div_learning_post_border">
  <div align="center"><h4>注册 <code>ethtool</code> 操作</h4></div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>ethtool</code> 是一个命令行工具，用于获取和配置各种网络设备驱动和硬件的选项，常见的用法包括用于从网络 Device 上获取详细的收发数据情况。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>ethtool</code> 是基于 <code>ioctl()</code> 系统调用实现的。Device Driver 会注册一系列的为 <code>ethtool</code> 运行的函数，而内核将这些函数和 <code>ioctl()</code> 系统调用连接起来。当一个 <code>ioctl()</code> 系统调用被 <code>ethtool</code> 产生的时候，内核会找到相应 Driver 注册的 <code>ethtool</code> 结构体，并且执行相关的函数。这些函数可以做的事情包括修改 Driver 的一个软件标志位，通过操作 NIC 寄存器来调整 NIC 的工作模式等等。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;IGB 驱动通过在 <code>igb_probe</code> 中调用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L3214">igb_set_ethtool_ops</a> 来注册相关的 <code>ethtool</code> 操作函数，如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">igb_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  igb_set_ethtool_ops(netdev);</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;所有 <code>ethtool</code> 操作函数的具体定义都可以在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_ethtool.c">drivers/net/ethernet/intel/igb/igb_ethtool.c</a> 中被找到。我们还可以在其中找到相应的注册函数 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_ethtool.c#L3507">igb_set_ethtool_ops</a>，如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">igb_set_ethtool_ops</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  netdev-&gt;ethtool_ops = &amp;igb_ethtool_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以发现它实际上就是把一些具体实现挂载到了 <code>netdev</code> 结构体上去了，与我们在上面配置 <code>netdev_ops</code> 的时候如出一辙。下面是 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_ethtool.c#L3462">igb_ethtool_ops</a> 结构体变量的部分定义情况：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">igb_ethtool_ops</span> =</span> &#123;</span><br><span class="line">  .get_settings           = igb_get_settings,</span><br><span class="line">  .set_settings           = igb_set_settings,</span><br><span class="line">  .get_drvinfo            = igb_get_drvinfo,</span><br><span class="line">  .get_regs_len           = igb_get_regs_len,</span><br><span class="line">  .get_regs               = igb_get_regs,</span><br><span class="line">  <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，各个厂商的 Driver 会选择性地挑选一些 <code>ethtool</code> 操作函数予以实现。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在后面的 Monitoring 的一章将看到如何使用 <code>ethtool</code> 工具来获取底层的 Driver 和 Device 的统计数据。
  </div>

  <br>

  <div class="div_learning_post_border">
  <div align="center"><h4>NAPI (New API)</h4></div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;传统的系统中，当一个 Packet 被 NIC 以 DMA 的方式写入到系统内存 Buffer 后，NIC 会产生一个 <font color="blue">Interrupt Request (IRQ)</font> 来告知 CPU Packet 的到达。一共有三种类型的 IRQ: MSI-X, MSI 和 Legacy IRQs。虽然这种方法十分简单，但是如果每来一个 Packet 都必须触发一次 IRQ 的话，那么大量的 Packet 的到达将导致大量的 IRQs，这将会导致 CPU 能分配给应用程序的时钟周期将会急剧下降，造成严重的性能问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这种问题背景下，<font color="blue">New API (NAPI)</font> 应运而生。NAPI 允许设备驱动注册一个 <font color="blue">轮询函数 (poll)</font>，NAPI 子系统将可以使用这个轮询函数来 "收割" 若干个连续到达的 Packet。NAPI 子系统的运行模式如下：

  <div class="div_learning_post_background">
  <ol>
    <li>NAPI 被 Device Driver 使能，但是一开始是不工作的；</li>
    <li>当一个 Packet 到达的时候，NIC 将会以 DMA 的方式将 Packet 写入系统内存 Buffer；</li>
    <li>NIC 会产生一个 IRQ，这样一来相应的 Driver 中的 IRQ 响应函数将会被调用；</li>
    <li>在这个 IRQ 响应函数中，它基于软中断将会唤醒 NAPI 子系统。NAPI 子系统会启动一个新的轮询线程，这个线程利用先前注册的轮询函数来 "收割" 之后到达的 Packets；</li>
    <li>Device Driver 会暂时取消对之后来自 NIC 的 IRQs 的响应；</li>
    <li>当 NAPI 启动的轮询线程发现一段时间都没有新的 Packet 到达时，它将停止工作，并且恢复 Device Driver 对来自 NIC 的 IRQs 的响应；</li>
    <li>回到第 2 步</li>
  </ol>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以发现，NAPI 方式的网卡服务方案减少了 CPU 的开销，因为 CPU 为每一个到达的 Packet 都使用一次 IRQ 来进行服务 (p.s. IRQ 会导致严重的上下文切换开销)。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在理解了 NAPI 的工作原理之后，我们回到我们的驱动程序，来看看具体的注册流程。Device Driver 会把上面介绍的 poll 函数使用 <code>netif_napi_add</code> 接口注册到 NAPI 子系统中。Driver 在注册这个 poll 函数的时候，通常会同时指定一个权重 (weight)，大部分的 Driver 会把这个权重写死为 64。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;通常来说，NAPI poll 函数的注册也是在 Driver 的初始化过程中注册的。<code>netif_napi_add</code> 接口的调用链非常长，如下所示：

  <div class="div_learning_post_border">
    <ol>
      <li><code>igb_probe</code> 调用 <code>igb_sw_init</code></li>
      <li><code>igb_sw_init</code> 调用 <code>igb_init_interrupt_scheme</code></li>
      <li><code>igb_init_interrupt_scheme</code> 调用 <code>igb_alloc_q_vectors</code></li>
      <li><code>igb_alloc_q_vectors</code> 调用 <code>igb_alloc_q_vector</code></li>
      <li><code>igb_alloc_q_vector</code> 调用 <code>netif_napi_add</code></li>
    </ol>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;简单来说，这串调用链做了如下的事情：

  <ol>
    <li>如果 MSI-X 是被支持的话，<code>pci_enable_msix</code> 将会被调用来使能 MSI-X IRQ；</li>
    <li>大量的设定在这个阶段都会被配置，其中就包括了 Driver 和 Device 用来收发 Packet 所使用的 Transmit Queue 和 Receive Queue 的数量；</li>
    <li><code>igb_alloc_q_vector</code> 会在创建各条 Transmit Queue 和 Receive Queue 时被调用一次以进行创建操作；</li>
    <li>在每次调用 <code>igb_alloc_q_vector</code> 时，都会调用 <code>netif_napi_add</code> 来为这个 Queue 注册一个 poll 函数。</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们下面分析 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.3/source/drivers/net/ethernet/intel/igb/igb_main.c#L1178">igb_alloc_q_vector</a> 函数来观察 NAPI poll 函数是如何 callback 的，以及 NAPI poll 函数的私有数据是如何被注册的。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">igb_alloc_q_vector</span><span class="params">(struct igb_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> v_count, <span class="keyword">int</span> v_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> txr_count, <span class="keyword">int</span> txr_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> rxr_count, <span class="keyword">int</span> rxr_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* allocate q_vector and rings */</span></span><br><span class="line">  q_vector = kzalloc(size, GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!q_vector)</span><br><span class="line">          <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* initialize NAPI */</span></span><br><span class="line">  netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;

  </div>
</div>

<!--ref-->

<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>

<ol>
<li>Joe Damato, <a target="_blank" rel="noopener" href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></li>
<li>Stack Overflow, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31330039/when-linux-calls-pci-drivers-probe-function">when Linux calls PCI driver’s probe function?</a></li>
<li>Stack Exchange, <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/358817/how-does-the-base-address-registers-bars-in-a-pci-card-work#:~:text=Each%20function%20in%20a%20PCI,IO%20or%20Port%2Dmapped%20IO.">How does the Base Address Registers (BARs) in a PCI card work?</a></li>
<li>kernel.org, <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/core-api/dma-api-howto.html">Dynamic DMA mapping Guide</a></li>
<li>Dan Siemon, <a target="_blank" rel="noopener" href="https://www.coverfire.com/articles/queueing-in-the-linux-network-stack/">Queueing in the Linux Network Stack</a></p>
</div>

</li>
</ol>
</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
          <li>LINUX_INTERNAL_NETWORK_1_RECEIVING_PACKET</li>
        
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.weibo.com/u/2861056530" title="Weibo → https:&#x2F;&#x2F;www.weibo.com&#x2F;u&#x2F;2861056530" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HwangZobin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HwangZobin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021044371号 </a>
  </div>

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-guitar"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8LMT8RtOsi4JsbYHtNm2J7U-gzGzoHsz',
      appKey     : 'Q0cSe4rR8Iwr0Gs60rwWBsYa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
