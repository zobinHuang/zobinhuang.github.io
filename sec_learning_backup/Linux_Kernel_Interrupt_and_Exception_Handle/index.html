<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Exo 2:300,300italic,400,400italic,700,700italic|Caveat:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"post","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="Linux 内核对中断和异常的处理">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Handle/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Handle/pic/xxx.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Handle/pic/excep_handle.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Handle/pic/irq_desc.png">
<meta property="article:published_time" content="2022-02-10T14:39:11.190Z">
<meta property="article:modified_time" content="2021-12-12T14:39:16.280Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning_backup/Linux_Kernel_Interrupt_and_Exception_Handle/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Linux 内核对中断和异常的处理 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lovin' Tech with Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about-me">

    <a href="/sec_about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>
        <li class="menu-item menu-item-library">

    <a href="/sec_learning/" rel="section"><i class="fa fa-duotone fa-book fa-fw"></i>Library</a>

  </li>
        <li class="menu-item menu-item-production">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>Production</a>

  </li>
        <li class="menu-item menu-item-thoughts">

    <a href="/sec_thoughts/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Thoughts</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Linux 内核对中断和异常的处理
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
          <li>LINUX_KERNEL_INTERRUPT_AND_EXCEPTION_HANDLE</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_concurrent_img{padding: 10px 10px; display: flex; align-items:center; justify-content:center;}
    @media(max-width: 768px) {
      .div_concurrent_img{flex-direction: column;}
    }
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_border{
      margin-bottom: 20px;
      padding: 10px 10px; 
      font-size: 16px; 
      word-spacing:0px;  
      border:1px solid black;
    }
    .div_learning_post_background{
      background-color:#E3E2E2;
      padding: 10px 40px; 
      font-size: 16px;
      word-spacing:0px;  
      border-radius: 15px;
      margin-bottom: 15px;
    }
    .div_learning_post_background p{
      margin: 0px;
    }
</style>

<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
<!--支持矩阵显示-->
<script type="text/javascript">
  run_maths = function() {
    if (document.querySelector('[class*="cmath"]') !== null) {
      if (typeof (mjax_path)=='undefined') { mjax_path='https://cdn.jsdelivr.net/npm/mathjax@2'; }
      if (typeof (mjax_config)=='undefined') { mjax_config='AM_CHTML'; }
      smjax = document.createElement ('script');
      smjax.setAttribute('src',`${mjax_path}/MathJax.js?config=${mjax_config}`);
      smjax.setAttribute('async',true);
      document.getElementsByTagName('head')[0].appendChild(smjax);
    }
  };
  if (document.readyState === 'loading') {  
    window.addEventListener('DOMContentLoaded', run_maths); 
  } else { 
    run_maths(); 
  }
</script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：Dec.8 2021</i></font></h4>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center" bgcolor="#FFFFFF">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--矩阵公式-->
<!--
<div class="cmath" align="center">
  `((1, 0),(1, 0))`
</div>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_idt"><font color="blue"><b>Interrupt Descriptor Table</b></font></a>：介绍了处理 Interrupt 和 Exception 的基础设施 IDT;
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#1_idt_1"><font color="blue">IDT 中存储的门种类</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#1_idt_2"><font color="blue">IDT 的初始化</font></a>
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_exception_handler"><font color="blue"><b>Exception Handler</b></font></a>：介绍了 Exception Handler 的基本框架和思路;
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#2_exception_handler_1"><font color="blue">Exception Handler 的基本原理和功能</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#2_exception_handler_2"><font color="blue">Exception Handler 的注册</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#2_exception_handler_3"><font color="blue">Exception Handler 的基本流程</font></a>
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 3. <a href="#3_Interrupt_Handler"><font color="blue"><b>Interrupt Handler</b></font></a>：介绍了 Interrupt Handler 的基本框架和思路;
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#3_Interrupt_Handler_1"><font color="blue">I/O Interrupt</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) <a href="#3_Interrupt_Handler_1_1"><font color="blue">灵活性需求</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) <a href="#3_Interrupt_Handler_1_2"><font color="blue">实时性需求</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) <a href="#3_Interrupt_Handler_1_3"><font color="blue">Interrupt 的基本处理流</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) <a href="#3_Interrupt_Handler_1_4"><font color="blue">相关数据结构</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) <a href="#3_Interrupt_Handler_1_5"><font color="blue">Interrupt 相关结构的初始化过程</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6) <a href="#3_Interrupt_Handler_1_6"><font color="blue">注册 ISR</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#3_Interrupt_Handler_2"><font color="blue">Interprocessor Interrupt</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#3_Interrupt_Handler_3"><font color="blue">Deferrable Functions</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) <a href="#3_Interrupt_Handler_3_1"><font color="blue">Softirq</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) <a href="#3_Interrupt_Handler_3_2"><font color="blue">Tasklet</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) <a href="#3_Interrupt_Handler_3_3"><font color="blue">Work Queue</font></a>
  </div>
</div>

<br>

<div class="div_learning_post">
<p>
  &nbsp;&nbsp;&nbsp;&nbsp;注明：
  <ul>
    <li>本文的分析基于内核版本 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source">v5.14.18</a> 展开;</li>
    <li>本文的分析基于 IA32 架构</li>
    <li>本文使用 <font color="blue">进程环境</font> 一词来指代在基于某个特定的 TSS 结构下的 CPU 运行环境，进程的切换将导致进程环境的切换，而从用户态到内核态、陷入中断上下文等则不会改变进程环境;</li>
  </ul>
</div>

<!--标题-->
<h2><a name="1_idt">1. Interrupt Descriptor Table</a></h2>
<div class="div_learning_post">
  <h3><a name="1_idt_1">1.1 IDT 中存储的门种类</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在之前的文章中了解到，在 Intel 的语义下， Interrupt Descriptor Table (IDT) 中可以存储三类的门描述符：中断门，任务门和陷阱门。而在 Linux 的语义中，针对 IDT 中存储的门描述符，又做了如下区分:

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <th width="20%"><div align="center">门描述符种类</div></th>
      <th width="50%"><div align="center">功能</div></th>
      <th width="30%"><div align="center">插入函数</div></th>
    </tr>
    <tr>
      <td><div align="center">Interrupt Gate</div></td>
      <td>所有 <font color="red"><b>不可以</b></font> 被 User Mode 代码段引用的 Intel 中断门，即中断门中的特权级字段 DPL 为 0。Linux 中所有的 Interrupt Handler 都是由 Interrupt Gate 指向的，即仅限于内核可以访问</td>
      <td><div align="center"><code>set_intr_gate(n, addr)</code></div></td>
    </tr> 
    <tr>
      <td><div align="center">System Gate</div></td>
      <td>所有 <font color="red"><b>可以</b></font> 被 User Mode 代码段引用的 Intel 陷阱门，即陷阱门中的特权级字段 DPL 为 3。Linux 中 vector 为 4、5 和 128 的 Exception1 Hanlder 就是由 System Gate 指向的，所以它们可以被用户态程序访问，它们分别对应了 <code>into</code>、<code>bound</code> 和 <code>int $0x80</code> 三条指令</td>
      <td><div align="center"><code>set_system_gate(n,addr)</code></div></td>
    </tr>
    <tr>
      <td><div align="center">System Interrupt Gate</div></td>
      <td>所有 <font color="red"><b>可以</b></font> 被 User Mode 代码段引用的 Intel 中断门，即中断门中的特权级字段 DPL 为 0。Linux 中 vector 为 3 的 Exception1 Hanlder 就是由 System Interrupt Gate 指向的，所以它可以被用户态程序访问，它实际上对应了 <code>int3</code> 指令</td>
      <td><div align="center"><code>set_system_intr_gate(n,addr)</code></div></td>
    </tr>
    <tr>
      <td><div align="center">Trap Gate</div></td>
      <td>所有 <font color="red"><b>不可以</b></font> 被 User Mode 代码段引用的 Intel 陷阱门，即中断门中的特权级字段 DPL 为 0。Linux 中大部分的 Exception Handler 都是由 Interrupt Gate 指向的，即仅限于内核可以访问</td>
      <td><div align="center"><code>set_trap_gate(n,addr)</code></div></td>
    </tr>
    <tr>
      <td><div align="center">Task Gate</div></td>
      <td>所有 <font color="red"><b>不可以</b></font> 被 User Mode 代码段引用的 Intel 任务门，即陷阱门中的特权级字段 DPL 为 3。Linux 内核中对于 "Double Fault" 异常的 Exception Handler 就是用 Task Gate 来指向的</td>
      <td><div align="center"><code>set_system_intr_gate(n,addr)</code></div></td>
    </tr>
  </table>

  <h3><a name="1_idt_2">1.2 IDT 的初始化</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;IDT 在 BIOS 控制 CPU 的时候就会被初始化，此时 CPU 尚处实模式。在 Kernel 接过 CPU 的控制权后会在一个新的区域重新初始化 IDT，Kernel 不会使用任何的来自 BIOS 的 routine。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 kernel 刚初始化的时候，会调用 <code>setup_idt()</code> 函数来初始化 IDT，它会向 IDT 中的所有 256 个表项中都插入同一个 Interrupt Gate，指向同一个 Interrupt Handler —— <code>ignore_int()</code>。在相关中断发生之后，这个处理函数会干如下事情：

  <ol>
    <li>将当前大部分寄存器的值保存到 Kernel Stack 中;</li>
    <li>调用 <code>printk()</code> 函数来打印内核消息 “Unknown interrupt”;</li>
    <li>从 Kernel Stack 中恢复中断之前寄存器的值;</li>
    <li>执行 <code>iret</code> 指令，返回到中断前的代码段</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在正常情况下，<code>ignore_int()</code> 处理函数都不应该被调用。如果在系统日志中发现了 “Unknown interrupt” 一类的消息，则说明硬件可能发出了异常的中断，或者是内核并没有正确地插入用于处理某些中断的 Interrupt Handler 对应的门描述符。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在完成 IDT 的初始化之后，Kernel 会向 IDT 中将一些位置指向 <code>ignore_int()</code> 的门描述符，替换为指向真正用于处理某些中断/异常的 Handler 的门描述符。这一步初始化完成后，CPU 就能够正确处理 CPU Control Unit 发出的 Exception 和 Interrupt Controller 由相应 IRQ 转化形成的 Interrupt。
</div>

<h2><a name="2_exception_handler">2. Exception Handler</a></h2>
<div class="div_learning_post">
  <h3><a name="2_exception_handler_1">2.1 Exception Handler 的基本原理和功能</a></h3>

  <div align="center">
    <img src="./pic/excep_handle.png" width=80%>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;大部分 CPU Control Unit 发出的异常都会被 Kernel 所捕获并被认为有错误发生。如上图所示，当 Kernel 捕获到这些异常时，它会向产生该异常的进程发送 UNIX signal，来告知该进程有异常情况的发生。例如，如果一个用户程序执行了除以 0 的操作，那么 CPU Control Unit 将会拉起 "Divide error" 的异常，Kernel 中相关的 Exception Handler 将会向相应的进程发送 <code>SIGFPE</code> UNIX Signal。如果用户进程由相应的针对该信号的处理逻辑，则进行相应的 recover 操作，如果没有的话，该用户程序将被 abort。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Kernel 有时候还会把异常当作一种更高效的管理硬件的办法。“Page Fault” 是最经典的例子：对于线性地址中的一个页面，只有在进程第一次对该页面发起访问的时候，CPU 才回去尝试创建页表、填充页目录表项和页表项。当 CPU 第一次访问一个页面时，会产生指示相应的页目录和页表表项不存在的 Page Fault 异常，此时 Exception Handler 的工作就是去映射相应的物理页面到线性地址中，然后再重新回到原进程访问该页表的代码段继续执行。

  <h3><a name="2_exception_handler_2">2.2 Exception Handler 的注册</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;为了在系统运行起来之后能够正确的对来自 CPU 控制单元发出的异常进行处理，在内核初始化的时候就要做好 Exception Handler 的注册工作。这部分工作是由 <code>trap_init()</code> 来完成的，该函数是依赖于底层硬件架构的，因此每一种不同的架构下都会有自己的实现，但其实其本质的内容就是把各个 Exception 的 Vector 和相应的门描述符对应起来，在 IDT 中注册相应的表项。

  <h3><a name="2_exception_handler_3">2.3 Exception Handler 的基本流程</a></h3>

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">handler_name:</span></span><br><span class="line">  pushl <span class="number">$0</span>    <span class="comment">; only for some exceptions</span></span><br><span class="line">  pushl $do_handler_name</span><br><span class="line">  <span class="keyword">jmp</span> error_code</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上所示是每个被 IDT 门描述符指向的 Exception Handler 起始的三行汇编代码。值得说明的是，既然已经跳转到了 Exception Handler，那么我们现在就已经是在异常前的进程环境中切换到了 Kernel Stack 中在运行这三行代码了。我们对上面这三行代码进行解释：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，对于某些异常来说，CPU Control Unit 是会给出 Hardware Error Code 的，有些则不会。对于那些不会给出 Hardware Error Code 的异常，我们在 Exception Handler 中要首先向 Kernel Stack 中手动地压入全 0 的参数，以填充原本留给 Hardware Error Code 的位置。这就是第一行程序的作用。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;其次，我们在第二行代码中向 Kernel Stack 中压入了由高级程序语言 (i.e. C) 实现的 Exception Handle Function 的地址。我们在后面将会利用这个地址跳转到真正的 Exception Handler 以执行异常处理逻辑。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;最后，我们跳转到由汇编标号 <code>error_code</code> 指向的代码段，由于每个 Exception Handler 的该部分执行逻辑都相同，所以采用了这种公共代码段的形式。由汇编标号 <code>error_code</code> 指向的代码段的工作流程大致如下：

  <ol>
    <li>在 Kernel Stack 中保存可能会被由高级程序语言 (i.e. C) 实现的 Exception Handle Function 所使用的寄存器值;</li>
    <li>执行 <code>cld</code> 指令以设置 EFLAGS 寄存器中的 <code>DF</code> 标志位，该位用于设置在字符串操作指令中 <code>edi</code> 和 <code>esi</code> 的自增方向;</li>
    <li>将位于栈中 <code>esp+36</code> 位置的 Hardware Error Code 拷贝到 <code>edx</code> 寄存器中，同时把栈中的该位置替换为 Hardware Error Code - 1，这一步是为了将 0x80 Exception 和其它 Exception 区分开;</li>
    <li>将位于栈中 <code>esp+32</code> 位置的 Exception Handle Function 的地址拷贝到 <code>edi</code> 寄存器中，同时把栈中的该位置替换为当前 <code>es</code> 寄存器的值;</li>
    <li>在 <code>eax</code> 中存入当前 Kernel Stack 的栈顶地址 (<code>esp</code> 的值)，该地址只是了在第 1 步暂存了寄存器值之后的栈顶指针位置;</li>
    <li>将用户程序数据段的选择子装入 <code>ds</code> 和 <code>es</code> 寄存器中;</li>
    <li>根据 <code>edi</code> 寄存器中存储的地址调用 Exception Handle Function</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;折腾了这么一圈之后，我们就调用了真正的承载 Exception Handler 逻辑的 Exception Handle Function，同时我们并没有使用 Kernel Stack 来传输参数，而是使用了 <code>eax</code> 和 <code>edx</code> 寄存器来讲相关参数传递给 Exception Handle Function。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;回顾我们上面所说的，Exception Handler 的原理实际上是在给用户程序发送 UNIX signal。在 Exception Handle Function 中的主要逻辑实际上就是如此。在 Exception Handler 退出之后，当前的用户程序会检查自己是否收到 UNIX signal。UNIX signal 会被用户程序的 Signal Handler 进行处理 (p.s. 如果存在的话)，或者在内核态被处理，对于后者，通常的做法是直接 kill 当前进程。
</div>

<h2><a name="3_Interrupt_Handler">3. Interrupt Handler</a></h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 Interrupt 来说，Interrupt 到来的时候，很可能 CPU 当前运行的进程根本就不是真正想关心这个 Interrupt 的进程，因此我们不能像在处理 Exception 那样，往当前进程发送一个 UNIX signal 就了事，这样是没有意义的。因此，在本节中我们将讨论 Interrupt Handler 的基本思路和框架。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Interrupt Handler 的设计思路随着 Interrupt 的来源不同而有所变化，我们可以把 Kernel 收到的 Interrupt 归结为如下三个方面：

  <ol>
    <li><b>I/O Interrupt</b>: 当一个 I/O 设备有请求等待 CPU 处理的时候，它就会发出 Interrupt。对应该 Interrupt Vector 的 Interrupt Handler 就去要去与对应设备进行交互以采取后续相应的操作;</li>
    <li><b>Timer Interrupt</b>: 本地 APIC Timer 或者外部的 Timer 发出的 Interrupt，大多数该类 Interrupt 都被当作 I/O Interrupt 处理，我们在其它讨论 Timer 的文章中再对该类中断的处理措施进行学习;</li>
    <li><b>Interprocessor Interrupt</b>: 从一个 CPU 发出的前往另一个 CPU 的 Interrupt</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们下面分点分析 I/O Interrupt 和 Interprocessor Interrupt 的 Interrupt Handler 模型。

  <h3><a name="3_Interrupt_Handler_1">3.1 I/O Interrupt</a></h3>
  <h5><a name="3_Interrupt_Handler_1_1">(1) 灵活性需求</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，I/O Interrupt Handler 必须是 <font color="blue">灵活</font> 的，因为对于一个 I/O Interrupt Handler 来说，它可能需要面对多个不同的设备。我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Linux_Kernel_Interrupt_and_Exception_Intro/index.html#2_irqs_and_interrupt">IRQs 和 Interrupts</a> 中曾经分析过从硬件设备发出 IRQ 到 Kernel 执行相应的 Interrupt Handler 的过程，其本质是 PIC (APIC) 将在某条 IRQ line 上产生的 IRQ 转化成了 Interrupt Vector。然而，以 PCI 总线为例，多个设备是可以共享同一条 IRQ line 的。这样一来，引发对某个 Interrupt Handler 的调用的中断源就来自于不同的设备，因此 Interrupt Handler 的设计必须考虑对多个设备的兼容性问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Linux 内核中，实现上述灵活性有两种解决方案：

  <ol>
    <li><b>IRQ Sharing</b>: 在这种方案下，当一个 Interrupt Handler 被触发调用时，它会同时执行多个 <font color="blue">Interrupt Service Routines (ISRs)</font>。每一个 ISR 对应于在这条 IRQ line 上的单个设备，由于在全局看来根本无法得知是哪个设备发出的 IRQ，所以每个 ISR 都会去确认自己对应的设备是否有中断请求，以相应服务;</li>
    <li><b>IRQ Dynamic Allocation</b>: 在这种方案下，IRQ line 和 Device Driver 之间的联系是动态分配的：只有当用户程序想要访问某个 I/O 外围设备时，该设备所在的 IRQ line 才会和它的 Device Driver 之间建立联系;</li>
  </ol>

  <h5><a name="3_Interrupt_Handler_1_2">(2) 实时性需求</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当一个 Interrupt 到来的时候，并不是所有的对应于该 Interrupt 的服务逻辑都应该被马上执行。对于 I/O Interrupt 来说，它有一个很重要的考量就是如何更快地响应硬件的需求。我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Linux_Kernel_Interrupt_and_Exception_Intro/index.html#5_nested">对嵌套的支持</a> 中讨论过，当 CPU 进入 Interrupt Handler 时，其 Disable 其他中断的，其根源就是基于中断门的跳转会将 CPU 的 EFLAGS 寄存器中的 IT 位清零以禁止中断。在这种情况下，如果我们的 Interrupt Handler 需要执行很长时间的服务逻辑，那么 Disable 中断的时间就会变长，这样使得 CPU 对外部设备的响应速度就变得慢下来，这样就有可能造成数据的丢失等问题。再者，Interrupt Handler 所运行的进程环境所对应的进程必须在运行 Interrupt Handler 期间始终保持 TASK_RUNNING 的状态，否则就可能会导致系统死机的问题，所以在 Interrupt Handler 中是绝对不能执行任何的阻塞操作的，比如读取磁盘数据等 I/O 操作。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Linux 把一个 Interrupt Handler 要执行的服务逻辑分成了下面三个部分：

  <ol>
    <li><b>Critical</b>: 比如向 PCI 回送 Acknowledgement，重新对 PIC 或者 Device Controller 进行读写操作 和 更新处理器与 I/O 设备共同访问的数据结构 (e.g. 网卡数据包描述符环形缓冲区) 等操作，都属于 Critical 的部分。这类服务逻辑是必须在第一时间被执行的，因为它们涉及到和硬件的交互。通常来说这部分逻辑执行起来也是较为快速的。因此此部分是在 Interrupt Handler 中立即被执行的，执行的时候 Maskable Interrupt 是被 Disable 的状态;</li>
    <li><b>Noncritical</b>: 比如各种对仅有处理器会访问的数据的更新等操作，这类操作通常也可以完成的很快，所以它们也是在 Interrupt Handler 中立即被执行的，执行的时候 Maskable Interrupt 是被打开的状态;</li>
    <li><b>Noncritical Deferrable</b>: 比如在一个进程的地址空间内进行数据拷贝等操作，这类操作通常比较费时间，并且和硬件也没有过多的关系，所以并不需要也不适合在 Interrupt Handler 中进行操作;</li>
  </ol>

  <h5><a name="3_Interrupt_Handler_1_3">(3) Interrupt 的基本处理流程</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意，本小节讨论的是 CPU 如何通用的处理到达的 Interrupt，而不是关心具体某个 Driver 对 Interrupt 的响应。即我们讨论的是 Interrupt Handler，而不是 Interrupt Service Routine。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于每个 I/O Interrupt Hanlder 来说，它们遵循的框架大致如下：

  <ol>
    <li>将 Interrupt Vector 和各个寄存器的值保存在 Kernel Mode Stack 中;</li>
    <li>发送 Acknowledgement 给 PIC，以允许它恢复对相应 IRQ line 的中断信号的响应;</li>
    <li>执行与该 Interrupt Vector 相关的所有 ISRs;</li>
    <li>从 Interrupt Handler 中返回</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在旧版的 Kernel 代码中，使用了 <code>__do_IRQ()</code> 大一统地处理了所有的 Interrupt 逻辑，但是实际上，Interrupt Handler 的 Control Flow 不应该被统一定义。因为：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 <font color="blue">Level-based</font> 的 Interrupt Type，CPU 的中断线会持续地被拉高直到相应的中断源的 IRQ 被处理，这样一来，当 CPU 检测到中断线为高时，它就会 poll 与相应 Interrupt Vector 关联的设备，并且响应需要关注的设备的 IRQ。当 CPU 在和某个设备交互的时候，如果一个已经被 polled 过的设备又需要被关注了，它就会发出 IRQ，此时中断线会被拉高，故而 CPU 在 poll 完所有设备的时候如果发现中断线仍然为高，那么它就会转而再次 poll 一遍设备，以响应后到的 IRQ。直到中断线为复位水平，CPU 才会退出 Interrupt Handler。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;而对于 <font color="blue">Edge-based</font> 的 Interrupt Type，中断信号是以上升沿/下降沿的形式呈现的，因此 CPU 需要有限次数地 poll 与相应 Interrupt Vector 关联的设备，确认没有设备需要关注后再退出 Interrupt Handler。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可见，Interrupt Handler 的运作流程，是随着 Interrupt Type 的不同而改变的，因此利用大一统的 Interrupt Handle 流程来处理不同的 Interrupt Type 是不合理的。因此，在后来的 Kernel 中，处理 Interrupt 的思路就是：

  <ol>
    <li>首先定义不同的 Interrupt Type (我们可以在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/irq.h#L38">include/linux/irq.h</a> 找到这些 type 的相关定义)，针对每种 Interrupt Type，定义一个 Generic Interrupt Hanlder 以对应它们不同的处理逻辑。在系统的初始化阶段，针对每一个 Interrupt Vector，Kernel 会为它们指派相应的 Generic Interrupt Hanlde 以对该 IRQ line 上发生的 Interrupt 进行相应流程的处理;</li>
    <li>将 Interrupt Chip 抽象出来，形成一个结构体 (i.e. <code>irq_chip</code>)，可以理解为面向对象编程中的接口，这个结构体里面存取着用于操作底层 Interrupt Chip 的一些函数指针，比如屏蔽/取消屏蔽 IRQ line 等，每个底层 Interrupt Chip 都有自己的具体实现。基于这个结构体，在上面提到的 Generic Interrupt Hanlder 中，就可以使用该结构体提供的函数以操作底层的 Interrupt Chip。</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以发现，后来的 Kernel 对 Interrupt 的处理实际上就是把 Interrupt Type 和 Interrupt Chip 抽象出来，这样一来我们在优化内核代码的时候就可以有针对性地对某种 Interrupt Type 的 Generic Interrupt Handler 或者某个 Interrupt Chip 的代码进行优化。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面的章节我们就开始分析 Kernel 中处理 Interrupt 的细节。我们先从基本的数据结构开始。

  <h5><a name="3_Interrupt_Handler_1_4">(4) 相关数据结构</a></h5>
  <div align="center">
    <img src="./pic/irq_desc.png" width=400px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上图所示，每一个 Interrupt Vector 都会对应一个 <code>irq_desc</code> 结构变量 (该结构体在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/irqdesc.h#L55">include/linux/irqdesc.h</a> 中被定义)，它们存放在同名的 <code>irq_desc</code> 数组中。在每个 <code>irq_desc</code> 中：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先来看 <code>irq_data</code> 成员，它在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/irq.h#L161">include/linux/irq.h</a> 中被定义，包含了用于操作 Interrupt Chip 所需要用到的数据，并且是随着 Interrupt Chip 的不同会不同的数据，即 per interrupt chip data。值得注意的是，它其中的成员 <code>struct irq_chip *chip</code> 就指向了底层 Interrupt Chip 对应的 <code>struct irq_chip</code> 结构变量，后者我们在上面有提及，<code>struct irq_chip</code> 结构体里面存取着用于操作底层 Interrupt Chip 的一些函数指针，比如屏蔽/取消屏蔽 IRQ line 等，每个底层 Interrupt Chip 都有自己的具体实现。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;再来看 <code>irq_common_data</code> 成员，它在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/irq.h#L131">include/linux/irq.h</a> 中被定义，包含了当前 IRQ line 的一些数据，这部分数据不是依赖于具体的 Interrupt Chip 的，即 per irq data。其中比较重要的成员是 <code>status_use_accessors</code>，它记录了与当前 Interrupt Vector 对应的 IRQ line 的状态，它的值可以是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12.19/source/include/linux/irq.h#L77">include/linux/irq.h</a> 中定义的 <code>enum</code> 的组合值。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;回到 <code>irq_desc</code> 结构，类型为 <code>struct irqaction*</code> 的成员 <code>action</code> 指向与该 Interrupt Vector 相关联的所有 ISRs 的一条链，该成员指向链头。我们在后面会看到，在 Generic Interrupt Handler 将会 poll 这条链以执行各个 ISRs。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们把两类情况定义为 Kernel 无法处理的 Interrupt：

  <ul>
    <li>发生中断的某个 Vector 没有注册任何 ISRs 以处理 Interrupt;</li>
    <li>发生中断的某个 Vector 的注册的 ISRs 都无法辨认当前 Interrupt (它们都认为它们关联的设备没有 Interrupt 发生)</li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 <code>irq_desc</code> 中，<code>irq_desc</code> 中的成员 <code>irq_count</code> 记录了当前 Vector 对应的 IRQ line 出现的次数；成员 <code>irqs_unhandled</code> 记录了由于上述的两种情况而无法 Handle 的 Interrupt 出现的次数。Kernel 通过对比 <code>irq_count</code> 的值和 <code>irqs_unhandled</code> 的值，来判断当前 IRQ line 是否有异常的不停地发出 Kernel 无法处理的 Interrupt 的设备。如果有的话，Kernel 将会 Disable 该 IRQ line 发出的中断 (i.e. 通过配置 PIC (APIC) 实现)。另外，成员 <code>last_unhandled</code> 是一个老化 (aging) 计时器值，以在到期的时候释放 <code>irq_count</code> 的值和 <code>irqs_unhandled</code> 的值。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果当前 Vector 对应的 IRQ line 是 enabled 状态，成员 <code>depth</code> 为 0。每调用一次 <code>irq_disable()</code>，该值都会增加 1。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;成员 <code>handle_irq</code> 是一个函数指针，指向了我们上文描述的代表各种不同的 Interrupt Control Flow 的 Generic Interrupt Handler，内核中在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/irq/chip.c">kernel/irq/chip.c</a> 中提供了如下的 Generic Interrupt Handler:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handle_level_irq()</span><br><span class="line">handle_edge_irq()</span><br><span class="line">handle_fasteoi_irq()</span><br><span class="line">handle_simple_irq()</span><br><span class="line">handle_percpu_irq()</span><br><span class="line">handle_edge_eoi_irq()</span><br><span class="line">handle_bad_irq()</span><br></pre></td></tr></table></figure>
  <h5><a name="3_Interrupt_Handler_1_5">(5) Interrupt 相关结构的初始化过程</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在代表 Kernel 入口的 <code>start_kernel</code> 函数中，我们可以找到对 <code>early_irq_init</code> 的调用，后者是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/irq/irqdesc.c#L521">kernel/irq/irqdesc.c</a> 中被定义的，定义如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">early_irq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, initcnt, node = first_online_node;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">  init_irq_default_affinity();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let arch update nr_irqs and return the nr of preallocated irqs */</span></span><br><span class="line">  initcnt = arch_probe_nr_irqs();</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;NR_IRQS: %d, nr_irqs: %d, preallocated irqs: %d\n&quot;</span>,</span><br><span class="line">        NR_IRQS, nr_irqs, initcnt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))</span><br><span class="line">    nr_irqs = IRQ_BITMAP_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))</span><br><span class="line">    initcnt = IRQ_BITMAP_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initcnt &gt; nr_irqs)</span><br><span class="line">    nr_irqs = initcnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; initcnt; i++) &#123;</span><br><span class="line">    desc = alloc_desc(i, node, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    set_bit(i, allocated_irqs);</span><br><span class="line">    irq_insert_desc(i, desc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arch_early_irq_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TODO，看完 NUMA 架构之后再回来研究这部分代码。

  <h5><a name="3_Interrupt_Handler_1_6">(6) 注册 ISR</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TODO

  <h3><a name="3_Interrupt_Handler_2">3.2 Interprocessor Interrupt</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TODO

  <h3><a name="3_Interrupt_Handler_3">3.3 Deferrable Functions</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;正如我们前面所说的，我们的程序设计应该尽量保证 CPU 处在 Interrupt Hanlder 中执行各个 ISRs 的时间尽可能的短，因为我们不能长时间地 Disable 掉对 Interrupt 的响应，因此在我们上面对 Interrupt Handler 要执行的服务逻辑的三部分拆分中，我们可以得知 Kernel 会把一些耗时但不紧急的操作剥离各个 ISRs，即成为 Deferrable Functions，或者称为 Interrupt Handler 的 <font color="blue">Bottom Half</font>。Kernel 中有三种形式来实现 Deferrable Function：<font color="blue">softirq</font>、<font color="blue">tasklet</font>，和 <font color="blue">Work Queue</font>。这三种机制的区别大致如下：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，<font color="red">Interrupt Handler 是工作在 Interrupt Context 下的，即不可中断也不可睡眠；而 Softirq 和 Tasklet 机制是工作在 Atomic Context 下的，即可以被中断，但是不可以睡眠；最后 Work Queue 机制是工作在 Process Context 下的，即既可以被中断，也可以被睡眠。</font>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;其次，对于 Softirq 和 Tasklet 来说，它们对并行的支持也是不一样的：Softirq 可以并行的在多个 CPU cores 上被运行，即使它们是同一种 Softirq 类型，这意味着 Softirq 是可重入的 (reentrant)，即我们必须显式地使用锁机制来保护 Softirq 所使用的数据；而对于 Tasklet 来说，对于多个同种 Tasklet，内核是将它们序列化 (serialized) 进行执行的，也即对于同一种 Tasklet 不能被两个 CPU cores 同时执行，而对于不同种的 Tasklet 则没有这种要求。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;另外，Softirq 是在内核被编译时就静态指派好的，而 Tasklet 可以动态地被加载和卸载。

  <h5><a name="3_Interrupt_Handler_3_1">(1) Softirq</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先要介绍的是 softirq 机制。在 Interrupt Handler 中执行的 ISRs 中，如果对于某个 ISR 来说它有一些工作是 Deferrable 的，那么它就会调度 Softirq 以执行后续的相关工作。TODO：Softirq 的本质。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们下面首先关心一下 Softirq 的一些相关数据结构。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Kernel 中，定义一个 Softirq 的结构是 <code>softirq_action</code>，它在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L540">include/linux/interrupt.h</a> 中被定义的，它的定义如下所示：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span>	(*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到，它实际上就只有一个函数指针，指向当前的 Softirq 被执行的时候需要运行的函数。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;然后，在 Kernel 中，有一个 <code>static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp</code> 数组，在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L59">kernel/softirq.c</a> 中被定义，每一个在 Kernel 中注册的 Softirq 都会占用一个该数组的位置，定义数组最大长度的宏 <code>NR_SOFTIRQS</code> 一般来说是 32。Kernel 在 <code>softirq_vec</code> 位于如下的 11 个 Index 的元素上定义了相应的 Softirq，如下的这个枚举区域是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L513">include/linux/interrupt.h</a> 中被定义的。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">  TIMER_SOFTIRQ,</span><br><span class="line">  NET_TX_SOFTIRQ,</span><br><span class="line">  NET_RX_SOFTIRQ,</span><br><span class="line">  BLOCK_SOFTIRQ,</span><br><span class="line">  IRQ_POLL_SOFTIRQ,</span><br><span class="line">  TASKLET_SOFTIRQ,</span><br><span class="line">  SCHED_SOFTIRQ,</span><br><span class="line">  HRTIMER_SOFTIRQ,</span><br><span class="line">  RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">  NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，在 <code>softirq_vec</code> 数组中越是靠前，就会越先被执行，即优先级越高。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L702">kernel/softirq.c</a> 中定义的函数 <code>open_softirq</code> 用于将某个 Softirq 的执行函数对应到 <code>softirq_vec</code> 数组的对应位置上去，其定义如下所示，其中参数 <code>nr</code> 是 <code>open_softirq</code> 数组索引，<code>action</code> 是相关的 Softirq 执行函数。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;读者现在可能会好奇：好了，说了这么多，那怎么让 Softirq 对应的执行函数在需要的时候跑起来呢？以及如果需要被运行，它们是什么时候被运行的呢？我们下面来回答这些问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Kernel 代码中，有一个 <code>unsigned int __softirq_pending</code> 的专用于 Softirq 的 bitmask，这个结构每个 CPU core 独一份，专门用来指示当前时刻在当前 CPU core 下有哪些 Softirq 是待执行的。在 ISR 中，当我们需要标记一个 Softirq 的时候，我们会使用 <code>raise_softirq</code> 在 bitmask <code>__softirq_pending</code> 中进行标记，该函数是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L686">kernel/softirq.c</a> 中定义的，具体定义如下所示。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/softirq.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">  local_irq_save(flags);</span><br><span class="line">  raise_softirq_irqoff(nr);</span><br><span class="line">  local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This function must run with irqs disabled!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * If we&#x27;re in an interrupt or softirq, we&#x27;re done</span></span><br><span class="line"><span class="comment">  * (this also catches softirq-disabled code). We will</span></span><br><span class="line"><span class="comment">  * actually run the softirq once we return from</span></span><br><span class="line"><span class="comment">  * the irq or softirq.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Otherwise we wake up ksoftirqd to make sure we</span></span><br><span class="line"><span class="comment">  * schedule the softirq soon.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!in_interrupt() &amp;&amp; should_wake_ksoftirqd())</span><br><span class="line">    wakeup_softirqd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* include/linux/preempt.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_interrupt()		(irq_count())</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们下面对上面的 <code>raise_softirq</code> 函数是如何在 bitmask 中 Raise 相应的 Softirq 进行分析。

  <ol>
    <li>执行 <code>local_irq_save</code> 宏来保存 eflags 寄存器的 IF 位，并且禁止当前 CPU core 的中断;</li>
    <li>调用 <code>__raise_softirq_irqoff</code> 来完成对在当前 CPU core 的 bitmask <code>__softirq_pending</code> 中相应位的置位操作，以标记该 Softirq 是 Pending 状态;</li>
    <li>如果 <code>in_interrupt</code> 返回 1 的话，跳至第 5 步。返回 1 表明了当前对 <code>raise_softirq_irqoff</code> 的调用是在 Interrupt Context 中的，或者对 Softirq 的处理当前是被 Disabled 掉的;</li>
    <li>调用 <code>wakeup_softirqd</code> 来唤醒运行在当前 CPU core 下的 Kernel Thread <code>ksoftirqd</code>，<code>wakeup_softirqd</code> 的定义如下所示;</li>
    <li>执行 <code>local_irq_restore</code> 宏来恢复 eflags 寄存器的 IF 位</li>
  </ol>

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* we cannot loop indefinitely here to avoid userspace starvation,</span></span><br><span class="line"><span class="comment">* but we also don&#x27;t want to introduce a worst case 1/HZ latency</span></span><br><span class="line"><span class="comment">* to the pending events, so lets the scheduler to balance</span></span><br><span class="line"><span class="comment">* the softirq load for us.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wakeup_softirqd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Interrupts are disabled: no need to stop preemption */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> __this_cpu_read(ksoftirqd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tsk)</span><br><span class="line">    wake_up_process(tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Kernel Thread <code>ksoftirqd</code> 会运行 <code>run_ksoftirqd</code> 来完成对 bitmask 的检查和对相关 Softirq 的运行，其定义如下所示，位于 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L912">kernel/softirq.c</a>。它首先调用 <code>ksoftirqd_run_begin</code> 来关闭当前 CPU core 对 Interrupt 的响应，随后它会调用 <code>local_softirq_pending</code> 来对当前 CPU core 下的 bitmask 进行检查，如果发现有被标记为 Pending 的 Softirq，则调用 <code>__do_softirq</code> 来进行处理，我们在后面会分析这个函数。最后，在处理结束后会调用 <code>ksoftirqd_run_end</code> 来重新恢复当前 CPU core 对 Interrupt 的响应。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_ksoftirqd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ksoftirqd_run_begin();</span><br><span class="line">  <span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * We can safely run softirq on inline stack, as we are not deep</span></span><br><span class="line"><span class="comment">    * in the task stack here.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __do_softirq();</span><br><span class="line">    ksoftirqd_run_end();</span><br><span class="line">    cond_resched();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ksoftirqd_run_end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;关于对 bitmask 的检查的时间点，Kernel 除了在 Kernel Thread <code>ksoftirqd</code> 中来检查和执行相关的被标记为 Pending 的 Softirq，Kernel 还会在诸如以下时间点检查 bitmask <code>__softirq_pending</code> 并且执行相关 Softirq 操作:

  <ul>
    <li>从 ISR 返回的时候;</li>
    <li>在运行任何显式地对 bitmask 进行检查以及运行响应 Softirq 执行函数的代码的时候，比如在 Network Subsystem 中就有这样的代码</li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们来看 <code>__do_softirq</code>，它被用于检查 bitmask 和执行相关的 Softirq 的处理函数。值得注意的是，<font color="red">在调用 <code>__do_softirq</code> 之前，当前 CPU core 对 Interrupt 的响应通常是被 Disable 掉的</font>，比如我们上面看到过的 <code>run_ksoftirqd</code>。<code>__do_softirq</code> 是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L515">kernel/softirq.c</a> 中被定义的，其大致定义如下所示。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="keyword">void</span> __softirq_entry __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> end = jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line">  <span class="keyword">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">  softirq_handle_begin();</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">  set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"> local_irq_enable();</span><br><span class="line"></span><br><span class="line">  h = softirq_vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    h += softirq_bit - <span class="number">1</span>;</span><br><span class="line">    h-&gt;action(h);</span><br><span class="line">    pending &gt;&gt;= softirq_bit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  local_irq_disable();</span><br><span class="line"></span><br><span class="line">  pending = local_softirq_pending();</span><br><span class="line">  <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">        --max_restart)</span><br><span class="line">      <span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">    wakeup_softirqd();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  softirq_handle_end();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>__do_softirq</code> 的流程大致如下：

  <ol>
    <li>首先记录一下当前 <code>__do_softirq</code> 实例允许运行的最长时间的终止时间点到 <code>end</code>，以及记录当前 <code>__do_softirq</code> 实例允许迭代的次数到 <code>max_restart</code> 中。需要限制当前 <code>__do_softirq</code> 实例运行迭代次数的原因是：我们在运行当前 <code>__do_softirq</code> 实例的时候，新的 Softirq 可能会到达，bitmask 可能会被更新。如果我们在当前 <code>__do_softirq</code> 实例中一直 loop 直到所有的 Softirq 被处理，这将导致其他用户进程的运行被推迟。所以我们只会在当前 <code>__do_softirq</code> 实例中迭代有限次数，处理有限的 Softirq;</li>
    <li>调用 <code>local_softirq_pending</code> 保存当前 bitmask 的信息;</li>
    <li>调用 <code>softirq_handle_begin</code> 来: 
      <ol>
        <li>标识所有被标识 Pending 的 Softirq 处于 Diasble 的状态，这是因为 Softirq 的处理在一个 CPU core 上必须是串行化的。由于我们下面运行 Softirq 的相关函数的时候，对 Interrupt 的响应是被打开的，如果我们没有在运行 Softirq 的相关函数之前没有标识对 Softirq 的处理的 Disable，那么很可能会起另一个 <code>__do_softirq</code> 实例来对 Softirq 进行处理，而这是不能出现的情况;
        </li>
        <li>关闭抢占，虽然我们目前还处在 Disable 对 Interrupt 的响应的状态，但是我们在后面处理各个 Softirq 的处理函数时会打开对 Interrupt 的响应。因此我们这里需要关闭对抢占中断的响应，因为正如我们上面所说，对 Softirq 的处理是运行在 Atomic Context 下的，它不能被 Sleep;</li>
      </ol>
    </li>
    <li>调用 <code>set_softirq_pending</code> 清除当前 CPU core 的 Softirq bitmask，然后调用 <code>local_irq_enable</code> 开启对 Interrupt 的响应;</li>
    <li>进入一个 loop，对所有获取到的被标记为 Pending 的 Softirq 进行处理;</li>
    <li>loop 结束后，调用 <code>local_irq_disable</code> 来关闭对 Interrupt 响应;</li>
    <li>重新调用 <code>local_softirq_pending</code> 来获取在处理上一轮 Softirq 的期间，有没有新到达的 Softirq，如果有的话，则跳转 8，没有的话则跳转 9;</li>
    <li>如果当前 <code>__do_softirq</code> 实例还没有到达最长运行时间或者最大迭代次数，则跳转 4，否则调用 <code>wakeup_softirqd</code> 来唤醒 Kernel Thread <code>ksoftirqd</code>。</li>
    <li>调用 <code>softirq_handle_end</code> 来重新 Enable 对 Softirq 的处理。</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这里做个小总结：<code>__do_softirq</code> 在每个 CPU core 上只能运行有一个实例; <code>__do_softirq</code> 需要限制运行时间/迭代次数来保证自己不会占用太多时间。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>__do_softirq</code> 说明了 Kernel Thread <code>ksoftirqd</code> 的一个很重要作用：如果没有 <code>ksoftirqd</code>，那么内核必须面临两种选择：

  <ol>
    <li>每次运行 <code>__do_softirq</code> 只迭代一次，这样一来虽然会使得用户进程不会因为对 Softirq 的处理而拖延太久，但是却会导致 Softirq 的处理效率过低，使得在网络数据包处理等场景下引入较高的处理时延;</li>
    <li>每次运行 <code>__do_softirq</code> 的时候不断地迭代，指导 bitmask 中的所有 Softirq 都不为 Pending 状态后再退出。这种方案虽然减小了 Softirq 的处理时延，但是却导致 Kernel Thread <code>ksoftirqd</code> 会占用大量的时间，导致其他用户进程会陷入长时间的等待</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Kernel Thread 的引入，使得当 <code>__do_softirq</code> 发现自己已经到达规定的最长的处理时间却还有未处理的 Softirq 时，会通过唤醒 Kernel Thread <code>ksoftirqd</code> 的方法来对剩下的 Softirq 进行处理。<code>ksoftirqd</code> 拥有较低的优先级，它在 CPU core 较忙的时候不会被轻易调度，而在 CPU core 较空闲的时候调度，这种方案就很好地折衷了上述的两种极端解决方案。

  <h5><a name="3_Interrupt_Handler_3_2">(2) Tasklet</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;正如我们在之前提到过的，Softirq 是可重入的，同一个 Softirq 处理函数可以同时在多个 CPU cores 上运行，这意味着我们在编写 Softirq 处理函数的时候需要处理好数据的并行访问问题。并且 Softirq 只能在编译时预先设定好，并不能在运行时动态分配，这就与 Linux Module 的动态加载产生了一定的矛盾。基于上述两个原因，我们平时更多用的是基于 Softirq 的另一种实现 Deferrable Function 的机制 —— <font color="blue">Tasklet</font>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先描述一下 Tasklet 的特性：同一个 Tasklet 不可以同时在多个 CPU cores 上运行，因此编写 Tasklet 的时候就不需要考虑并行数据访问的问题; Tasklet 可以在运行时和编译的时候进行指派，使用更为灵活。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Tasklet 和两个 Softirq 相关联：<code>TASKLET_SOFTIRQ</code> 和 <code>HI_SOFTIRQ</code>。我们来看位于 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L892">kernel/softirq.c</a> 中的 <code>softirq_init</code> 函数，其完成了 Tasklet 的初始化工作，其定义如下所示:


  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">  for_each_possible_cpu(cpu) &#123;</span><br><span class="line">    per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">      &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">    per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">      &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">  open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在上面的代码中，<code>softirq_init</code> 函数使用了 <code>for_each_possible_cpu</code> 宏遍历了所有在当前系统上的 CPU cores，并且初始化了 <code>tasklet_vec</code> 和 <code>tasklet_hi_vec</code> 结构。这两个结构是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L715">kernel/softirq.c</a> 中被初始化的:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_vec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_hi_vec)</span></span>;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到它们是 per-cpu 的数据结构，在每个 CPU core 上都会有这样的两个结构，这两个结构的本质是结构题 <code>struct tasklet_head</code>，它是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L710">kernel/softirq.c</a> 中被定义的，其定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;看到这里我们应该就会猜测：每一个 CPU 上都会有两条链表，链表头是 <code>struct tasklet_head</code>，链表元素是 <code>struct tasklet_struct</code>。确实如此，下面我们来看代表一个 Tasklet 的结构体 <code>struct tasklet_struct</code> 的定义，位于 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L585">include/linux/interrupt.h</a>，如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>          <span class="comment">// 调度链表中的下一个 tasklet_struct</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> state;                  <span class="comment">// Tasklet 的状态</span></span><br><span class="line">  <span class="keyword">atomic_t</span> count;                       <span class="comment">// 锁计数器</span></span><br><span class="line">  <span class="keyword">bool</span> use_callback;              </span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span> data);   <span class="comment">// Tasklet 的执行函数</span></span><br><span class="line">    <span class="keyword">void</span> (*callback)(struct tasklet_struct *t);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> data;                   <span class="comment">// Tasklet 执行函数可能会使用的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;内核中在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L824">kernel/softirq.c</a> 中提供了 <code>tasklet_init</code> 函数来初始化一个 <code>tasklet_struct</code> 结构，其定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>), <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;state = <span class="number">0</span>;</span><br><span class="line">  atomic_set(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">  t-&gt;func = func;</span><br><span class="line">  t-&gt;use_callback = <span class="literal">false</span>;</span><br><span class="line">  t-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;同时也在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L598">include/linux/interrupt.h</a> 中提供了用于在编译前静态初始化 Tasklet 的宏 <code>DECLARE_TASKLET</code> 和 <code>DECLARE_TASKLET_DISABLED</code>:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET(name, _callback)		\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">name</span> =</span> &#123;				\</span><br><span class="line">  .count = ATOMIC_INIT(<span class="number">0</span>),			\</span><br><span class="line">  .callback = _callback,				\</span><br><span class="line">  .use_callback = <span class="literal">true</span>,				\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET_DISABLED(name, _callback)	\</span></span><br><span class="line">struct tasklet_struct name = &#123;				\</span><br><span class="line">  .count = ATOMIC_INIT(<span class="number">1</span>),			\</span><br><span class="line">  .callback = _callback,				\</span><br><span class="line">  .use_callback = <span class="literal">true</span>,				\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;正如我们在 <code>tasklet_struct</code> 的定义中所看到的，每一个 Tasklet 都会有一个状态 Flag。对于一个 Tasklet 的状态，一共有两种，是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L629">include/linux/interrupt.h</a> 中定义的:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TASKLET_STATE_SCHED,	<span class="comment">/* Tasklet is scheduled for execution */</span></span><br><span class="line">  TASKLET_STATE_RUN	    <span class="comment">/* Tasklet is running (SMP only) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>TASKLET_STATE_SCHED</code> 状态表明相应的 Tasklet 进入了 Pending 状态，等待被执行。<code>TASKLET_STATE_RUN</code> 只在多核系统中起作用，表明当前的 Tasklet 正在被某个 CPU core 执行。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Kernel 提供了以下两个 API 用于标识一个 Tasklet 进入 Pending 状态，它们是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L652">include/linux/interrupt.h</a> 中被定义的:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule</span><span class="params">(struct tasklet_struct *t)</span></span>;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于这两个 API 的唯一区别就是操作的分别是 <code>tasklet_vec</code> 和 <code>tasklet_hi_vec</code> 链表，所以我们下面就以 <code>tasklet_schedule</code> 为例展开分析，首先来看它在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L652">include/linux/interrupt.h</a> 中的相关定义 (它实质上调用了 <code>__tasklet_schedule</code>，<code>__tasklet_schedule</code> 又调用了 <code>__tasklet_schedule_common</code>，<code>__tasklet_schedule</code> 和 <code>__tasklet_schedule_common</code> 的定义都位于 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L734">kernel/softirq.c</a> 中):

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/interrupt.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">    __tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/softirq.c</span></span><br><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">  __tasklet_schedule_common(t, &amp;tasklet_vec,</span><br><span class="line">          TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __tasklet_schedule_common(struct tasklet_struct *t,</span><br><span class="line">              struct tasklet_head __percpu *headp,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_nr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> *<span class="title">head</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">  local_irq_save(flags);</span><br><span class="line">  head = this_cpu_ptr(headp);</span><br><span class="line">  t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  *head-&gt;tail = t;</span><br><span class="line">  head-&gt;tail = &amp;(t-&gt;next);</span><br><span class="line">  raise_softirq_irqoff(softirq_nr);</span><br><span class="line">  local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;整个调度 Tasklet 的流程如下：

  <ol>
    <li>首先在外层函数 <code>tasklet_schedule</code> 中，它会首先检查 Tasklet 的状态是否为 <code>TASKLET_STATE_SCHED</code>，如果该位已经被置起，则说明该 Tasklet 已经在被某个 CPU core 所处理，不需要再被 schedule。如果 <code>TASKLET_STATE_SCHED</code> 没有被标记，则先标记上，然后跳转 2;</li>
    <li>来到 <code>__tasklet_schedule_common</code>，调用 <code>local_irq_save</code> 保存 eflags 寄存器的 IF 位，并且关闭当前 CPU core 对 Interrupt 的响应;</li>
    <li>将目标 <code>tasklet_struct</code> 添加到 <code>tasklet_vec</code> 调度队列中;</li>
    <li>调用 <code>raise_softirq_irqoff</code> 来 Mark 对应的 Softirq (<code>TASKLET_SOFTIRQ</code>) 为 Pending 状态，这个函数我们在上面有所提及，它在假设当前 CPU core 对中断的响应已经被关闭的前提下拉起 bitmask 中对应的标识位，而 <code>raise_softirq</code> 则是先关闭了中断之后再调用 <code>raise_softirq_irqoff</code>，然后再恢复中断，相当于一个 wrapper;</li>
    <li>调用 <code>local_irq_restore</code> 恢复 IF 标志位</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到，事实上 Tasklet 还是依赖于 Softirq 的机制来实现了。当我们 Mark 一个 Tasklet 为 Pendind 状态时，实际上在底层也会去标记其对应的 Softirq 处于 Pending 状态。那么当我们在内核中的各个时间点去检查 Softirq 时 (在上面 Softirq 部分已经有所介绍)，我们就会检查到对应的 <code>TASKLET_SOFTIRQ</code> 或者 <code>HI_SOFTIRQ</code> 标志位被拉起，然后就回去执行相应的处理函数。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们来看 <code>__do_softirq()</code> 中是如何对 Tasklet 进行处理的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意到我们在上面介绍的 <code>softirq_init</code> 中调用了 <code>open_softirq</code> 将 <code>HI_SOFTIRQ</code> 和 <code>TASKLET_SOFTIRQ</code> 标志位与 <code>tasklet_hi_action</code> 和 <code>tasklet_action</code> 处理函数进行了关联，由于 <code>tasklet_hi_action</code> 和 <code>tasklet_action</code> 的区别就是操作的链表不同，所以我们还是以 <code>tasklet_action</code> 为例展开对 Tasklet Deferrable Function 执行过程的分析。<code>tasklet_action</code> 实际上调用了 <code>tasklet_action_common</code>，它们都是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L802">kernel/softirq.c</a> 中定义的。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __latent_entropy <span class="keyword">void</span> <span class="title">tasklet_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tasklet_action_common(a, this_cpu_ptr(&amp;tasklet_vec), TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tasklet_action_common</span><span class="params">(struct softirq_action *a,</span></span></span><br><span class="line"><span class="function"><span class="params">          struct tasklet_head *tl_head,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">  local_irq_disable();</span><br><span class="line">  <span class="built_in">list</span> = tl_head-&gt;head;</span><br><span class="line">  tl_head-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">  tl_head-&gt;tail = &amp;tl_head-&gt;head;</span><br><span class="line">  local_irq_enable();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!atomic_read(&amp;t-&gt;count)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasklet_clear_sched(t)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (t-&gt;use_callback)</span><br><span class="line">            t-&gt;callback(t);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            t-&gt;func(t-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        tasklet_unlock(t);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tasklet_unlock(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    *tl_head-&gt;tail = t;</span><br><span class="line">    tl_head-&gt;tail = &amp;t-&gt;next;</span><br><span class="line">    __raise_softirq_irqoff(softirq_nr);</span><br><span class="line">    local_irq_enable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;分析起来 <code>tasklet_action_common</code> 函数，会有一种很熟悉的感觉，它和上面我们分析 Softirq 分析过的 <code>__do_softirq</code> 的结构较为类似，实际上就是把当前所有被 Pending 的 Tasklet 全部执行一次。不同的是 <code>tasklet_action_common</code> 没有迭代的说法，遍历完就直接退出。基于 Softirq 的 Deferrable Function 的执行函数的运行迭代次数是由 <code>__do_softirq</code> 来确定的，这我们在上面也有所分析。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 <code>tasklet_action_common</code> 中，我们会首先把要处理的当前 CPU core 下的 Tasklet 链表给读进来 (i.e. 现在我们处理的链表是 <code>tasklet_vec</code>)，然后释放对应的 <code>tasklet_head</code> 结构的指针，注意这是在对 Interrupt 的响应被禁止的状态下操作的。然后重新打开对 Interrupt 的响应，在一个 loop 中遍历对应链表中的各个元素。在每次遍历开始的时候都会调用 <code>tasklet_trylock</code> 来尝试将该轮 loop 处理的 Tasklet 的状态标记为 <code>TASKLET_STATE_RUN</code>，以表明它正在被当前 CPU core 所执行，该函数定义如下所示，它是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/include/linux/interrupt.h#L634">include/linux/interrupt.h</a> 中被定义的。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tasklet_trylock</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !test_and_set_bit(TASKLET_STATE_RUN, &amp;(t)-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;同样的，当我们完成对当前 Tasklet 的处理后，我们也会调用 <code>tasklet_unlock</code> 来清除当前 Tasklet 的 <code>TASKLET_STATE_RUN</code> 标记。其定义如下所示，它是在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14.18/source/kernel/softirq.c#L876">kernel/softirq.c</a> 中被定义的。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP) || defined(CONFIG_PREEMPT_RT)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_unlock</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  smp_mb__before_atomic();</span><br><span class="line">  clear_bit(TASKLET_STATE_RUN, &amp;t-&gt;state);</span><br><span class="line">  smp_mb__after_atomic();</span><br><span class="line">  wake_up_var(&amp;t-&gt;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
  <h5><a name="3_Interrupt_Handler_3_3">(3) Work Queue</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TODO
</div>

<!--ref-->
<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>

<ol>
<li>Kernel Documentation, <a target="_blank" rel="noopener" href="https://01.org/linuxgraphics/gfx-docs/drm/core-api/genericirq.html">Linux generic IRQ handling</a></li>
<li>Linux Inside, <a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/Interrupts/linux-interrupts-9.html">Interrupts and Interrupt Handling. Part 9</a></li>
<li>Embetronicx, <a target="_blank" rel="noopener" href="https://embetronicx.com/tutorials/linux/device-drivers/softirq-in-linux-kernel/">Softirq in Linux Device Driver – Linux Device Driver Tutorial</a></p>
</div>

</li>
</ol>
</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning_backup/">SEC_LEARNING_BACKUP</a></li>
          <li>LINUX_KERNEL_INTERRUPT_AND_EXCEPTION_HANDLE</li>
        
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar_2.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
