<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Exo 2:300,300italic,400,400italic,700,700italic|Caveat:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"post","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_catalogue{padding: 10px 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="Golang 方法">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning/Tech_Program/Go_Basic_5_Method/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_catalogue{padding: 10px 10p">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_Program/Go_Basic_5_Method/pic/xxx.png">
<meta property="article:published_time" content="2022-02-10T14:39:11.401Z">
<meta property="article:modified_time" content="2021-09-07T12:09:22.000Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning/Tech_Program/Go_Basic_5_Method/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Golang 方法 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lovin' Tech with Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about-me">

    <a href="/sec_about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>
        <li class="menu-item menu-item-library">

    <a href="/sec_learning/" rel="section"><i class="fa fa-duotone fa-book fa-fw"></i>Library</a>

  </li>
        <li class="menu-item menu-item-production">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>Production</a>

  </li>
        <li class="menu-item menu-item-thoughts">

    <a href="/sec_thoughts/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Thoughts</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Golang 方法
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_Program/">TECH_PROGRAM</a></li>
          <li>GO_BASIC_5_METHOD</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_boder{padding: 10px 10px; font-size: 16px; word-spacing:0px;  border:1px solid black;}
</style>
<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>协作者：ZobinHuang，更新日期：June.7 2021</i></font></h4>
  <div align="left">
  <font size="2px">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;这篇文章内容的一些部分是转载自<a target="_blank" rel="noopener" href="https://github.com/gopl-zh/gopl-zh.github.com">Go 语言圣经（中文版）</a>，并加上了本人在使用过程中的一些自己的理解和经验，最终整理成可读性更高的网页形式。在此向原作者和译者表示感谢，他们给社区提供了很棒的 Golang 入门参考。
    <br>&nbsp;&nbsp;&nbsp;&nbsp;原作者：Alan A. A. Donovan · Brian W. Kernighan;
    <br>&nbsp;&nbsp;&nbsp;&nbsp;  译者：柴树杉，Github @chai2010，Twitter @chaishushan；Xargin, https://github.com/cch123；CrazySssst；foreversmart, njutree@gmail.com
  </font>
  </div>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">此文篇幅较长，故设置目录，有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 0. <a href="#0_preface"><font color="blue"><b>前言</b></font></a>：讨论了本章阐述的内容；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_declaration"><font color="blue"><b>方法声明</b></font></a>：讨论了在 Golang 中将方法声明到某种类型上的格式以及好处；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_pointer_method"><font color="blue"><b>基于指针对象的方法</b></font></a>：介绍了使用指针类型作为接收器的用法；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#2_pointer_method_1"><font color="blue">Nil 也是一个合法的接收器类型</font></a>：讨论了 nil 的接收器是合法的这件事情，顺带分析了 map 结构的底层实现 (不务正业)； 
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 3. <a href="#3_embedded_struct"><font color="blue"><b>通过嵌入结构体来扩展类型</b></font></a>：讨论了在结构体内嵌子结构体时的方法使用问题；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 4. <a href="#4_method_value"><font color="blue"><b>方法值和方法表达式</b></font></a>：；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 5. <a href="#5_bit_array"><font color="blue"><b>Bit 数组</b></font></a>：借助 Bit 数组，展示了方法的实际应用实例；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 6. <a href="#6_encapsulation"><font color="blue"><b>封装</b></font></a>：讨论了 Go 封装 (Package 层次的导出) 的用法以及优势
  </div>
</div>

<!--标题-->
<h2><a name="0_preface">0. 前言</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;从 90 年代早期开始，面向对象编程（OOP）就成为了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对 OOP 的支持，go 语言也不例外。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;尽管没有被大众所接受的明确的 OOP 的定义，从我们的理解来讲，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在早些的章节中，我们已经使用了标准库提供的一些方法，比如 time.Duration 这个类型的 Seconds 方法：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> day = <span class="number">24</span> * time.Hour</span><br><span class="line">fmt.Println(day.Seconds()) <span class="comment">// &quot;86400&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在本章中，OOP 编程的第一方面，我们会向你展示如何有效地定义和使用方法。我们会覆盖到 OOP 编程的两个关键点，<b>封装</b> 和 <b>组合</b>。
</div>

<h2><a name="1_declaration">1. 方法声明</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面来写我们第一个方法的例子，这个例子在 package geometry 下：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的代码里那个附加的参数 p，叫做方法的<b>接收器（receiver）</b>，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Go 语言中，我们并不会像其它语言那样用 this 或者 self 作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了 Point 的首字母 p。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// &quot;5&quot;, function call</span></span><br><span class="line">fmt.Println(p.Distance(q))  <span class="comment">// &quot;5&quot;, method call</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到，上面的两个函数调用都是 Distance，但是却没有发生冲突。第一个 Distance 的调用实际上用的是包级别的函数 geometry.Distance，而第二个则是使用刚刚声明的 Point，调用的是 Point 类下声明的 Point.Distance 方法。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这种 p.Distance 的表达式叫做选择器，因为他会选择合适的对应 p 这个对象的 Distance 方法来执行。选择器也会被用来选择一个 struct 类型的字段，比如 p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个 X 方法的话，编译器会报错，因为在调用 p.X 时会有歧义（译注：这里确实挺奇怪的）。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;因为每种类型都有其方法的命名空间，我们在用 Distance 这个名字的时候，不同的 Distance 调用指向了不同类型里的 Distance 方法。让我们来定义一个 Path 类型，这个 Path 代表一个线段的集合，并且也给这个 Path 定义一个叫 Distance 的方法。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Path is a journey connecting the points with straight lines.</span></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"><span class="comment">// Distance returns the distance traveled along the path.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  sum := <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">      sum += path[i<span class="number">-1</span>].Distance(path[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Path 是一个命名的 slice 类型，而不是 Point 那样的 struct 类型，然而我们依然可以为它定义方法。<b>在能够给任意类型定义方法这一点上，Go 和很多其它的面向对象的语言不太一样。</b>因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。<font color ="red">我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型</font>（译注：这个例子里，底层类型是指 []Point 这个 slice，Path 就是命名类型）<font color ="red">不是指针或者interface</font>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;两个 Distance 方法有不同的类型。他们两个方法之间没有任何关系，尽管 Path 的 Distance 方法会在内部调用 Point.Distance 方法来计算每个连接邻接点的线段的长度。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;让我们来调用一个新方法，计算三角形的周长：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">perim := Path&#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(perim.Distance()) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在上面两个对 Distance 名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。第一个例子中 path[i-1] 数组中的类型是 Point，因此 Point.Distance 这个方法被调用；在第二个例子中 perim 的类型是 Path，因此 Distance 调用的是 Path.Distance。 

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里 Point 和 Path 就都有 Distance 这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如 PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gopl.io/ch6/geometry&quot;</span></span><br><span class="line"></span><br><span class="line">perim := geometry.Path&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">fmt.Println(geometry.PathDistance(perim)) <span class="comment">// &quot;12&quot;, standalone function</span></span><br><span class="line">fmt.Println(perim.Distance())             <span class="comment">// &quot;12&quot;, method of geometry.Path</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;译注： 如果我们要用方法去计算 perim 的 distance，还需要去写全 geometry 的包名，和其函数名，但是因为 Path 这个类型定义了一个可以直接用的 Distance 方法，所以我们可以直接写 perim.Distance()。相当于可以少打很多字，作者应该是这个意思。因为在 Go 里包外调用函数需要带上包名，还是挺麻烦的。
</div>

<h2><a name="2_pointer_method">2. 基于指针对象的方法</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，<font color="red"><b>当这个接受者变量本身比较大时，或者我们需要修改接受者变量中的某些值时，我们就可以用其指针而不是对象来声明方法</b></font>。我们其实可以吧接收器当作函数传入的一个参数来理解，具体的例子如下：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">  p.X *= factor</span><br><span class="line">  p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个方法的名字是 (*Point).ScaleBy。这里的括号是必须的，没有括号的话这个表达式可能会被理解为 *(Point.ScaleBy)。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里我们体会一下使用指针变量作为接收器，和使用对象作为接收器的区别：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">  p.X *= factor</span><br><span class="line">  p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">ScaleByFixed</span><span class="params">(factor <span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">  p.X *= factor</span><br><span class="line">  p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">  r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">  fmt.Println(*r) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  k := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">  k.ScaleByFixed(<span class="number">2</span>)</span><br><span class="line">  fmt.Println(k) <span class="comment">// &quot;&#123;1, 2&#125;&quot;</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到由于使用了指针类型接收器的方法 ScaleBy， r 的成员 X，Y 被 ScaleBy 改变，而由于使用了以对象作为接收器的方法 ScaleByFixed，虽然在 ScaleByFixed 我们同样对接收器的成员进行了修改，但是事实上我们是对接收器的一份拷贝进行了修改，所以原始接收器中的成员值并没有发生改变。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;另外，在现实的程序里，一般会约定如果 Point 这个类有一个以指针作为接收器的方法，那么所有 Point 的方法都必须使用指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;只有类型（Point）和指向他们的指针 (*Point)，才可能是出现在接收器声明里的两种接收器。此外，为了避免歧义，<font color="red">在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</font>，比如下面这个例子：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P *<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P)</span> <span class="title">f</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;想要调用指针类型方法 (*Point).ScaleBy，只要提供一个 Point 类型的指针即可，像下面这样。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;或者这样：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">pptr := &amp;p</span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;或者这样:

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">(&amp;p).ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;不过后面两种方法有些笨拙。幸运的是，go 语言本身在这种地方会帮到我们。如果接收器 p 是一个Point类型的变量，并且其方法需要一个 Point 指针作为接收器，我们可以用下面这种简短的写法：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;编译器会隐式地帮我们用 &p 去调用 ScaleBy 这个方法。这种简写方法只适用于“变量”，包括 struct 里的字段比如 p.X，以及 array 和 slice 内的元素比如 perim[0]。<font color="red">我们不能通过一个无法取到地址的接收器来调用指针方法</font>，比如<b>临时变量的内存地址就无法获取得到</b>：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>) <span class="comment">// compile error: can&#x27;t take address of Point literal</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;但是我们可以用一个 *Point 这样的接收器来调用 Point 的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号 * 来取到该变量即可。编译器在这里也会给我们隐式地插入*这个操作符，所以下面这两种写法等价的：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pptr.Distance(q)</span><br><span class="line">(*pptr).Distance(q)</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里的几个例子可能让你有些困惑，所以我们总结一下：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型 T 或者都是类型 *T：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.Distance(q) <span class="comment">//  Point</span></span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)         <span class="comment">// *Point</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;或者接收器实参是类型 T，但接收器形参是类型 *T，这种情况下编译器会隐式地为我们取变量的地址：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>) <span class="comment">// implicit (&amp;p)</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;或者接收器实参是类型 *T，形参是类型 T。编译器会隐式地为我们解引用，取到指针指向的实际变量：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pptr.Distance(q) <span class="comment">// implicit (*pptr)</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果命名类型 T（译注：用 type xxx 定义的类型）的所有方法都是用 T 类型自己来做接收器（而不是 *T），那么拷贝这种类型的实例就是安全的，调用他的任何一个方法也就会产生一个值的拷贝。比如 time.Duration 的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对 bytes.Buffer 对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，实际上它们指向的对象是一样的。紧接着对拷贝后的变量进行修改可能会有让你有意外的结果。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;译注： 作者这里说的比较绕，其实有两点：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;不管你的 method 的 receiver 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在声明一个 method 的 receiver 该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉 C 或者 C++ 的人这里应该很快能明白。

  <h3><a name="2_pointer_method_1">2.1 Nil 也是一个合法的接收器类型</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;就像一些函数允许 nil 指针作为参数一样，方法理论上也可以用 nil 指针作为其接收器，尤其当 nil 对于对象来说是合法的零值时，比如 map 或者 slice。在下面的简单 int 链表的例子里，nil 代表的是空链表：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntList is a linked list of integers.</span></span><br><span class="line"><span class="comment">// A nil *IntList represents the empty list.</span></span><br><span class="line"><span class="keyword">type</span> IntList <span class="keyword">struct</span> &#123;</span><br><span class="line">  Value <span class="keyword">int</span></span><br><span class="line">  Tail  *IntList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sum returns the sum of the list elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *IntList)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list.Value + list.Tail.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当你定义一个允许 nil 作为接收器值的方法的类型时，在类型前面的注释中指出 nil 变量代表的意义是很有必要的，就像我们上面例子里做的这样。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是 net/url 包里 Values 类型定义的一部分。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the first value associated with the given key,</span></span><br><span class="line"><span class="comment">// or &quot;&quot; if there are none.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> vs := v[key]; <span class="built_in">len</span>(vs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the value to key.</span></span><br><span class="line"><span class="comment">// It appends to any existing values associated with key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  v[key] = <span class="built_in">append</span>(v[key], value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个定义向外部暴露了一个 map 的命名类型，并且提供了一些能够简单操作这个 map 的方法。这个 map 的 value 字段是一个 string 的 slice，所以这个 Values 是一个多维 map。客户端使用这个变量的时候可以使用 map 固有的一些操作（make，切片，m[key] 等等），也可以使用这里提供的操作方法，或者两者并用，都是可以的：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m := url.Values&#123;<span class="string">&quot;lang&quot;</span>: &#123;<span class="string">&quot;en&quot;</span>&#125;&#125; <span class="comment">// direct construction</span></span><br><span class="line">m.Add(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">m.Add(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;lang&quot;</span>)) <span class="comment">// &quot;en&quot;</span></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;q&quot;</span>))    <span class="comment">// &quot;&quot;</span></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;item&quot;</span>)) <span class="comment">// &quot;1&quot;      (first value)</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;item&quot;</span>])     <span class="comment">// &quot;[1 2]&quot;  (direct map access)</span></span><br><span class="line"></span><br><span class="line">m = <span class="literal">nil</span></span><br><span class="line">fmt.Println(m.Get(<span class="string">&quot;item&quot;</span>)) <span class="comment">// &quot;&quot;</span></span><br><span class="line">m.Add(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;3&quot;</span>)         <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对 Get 的最后一次调用中，nil 接收器的行为即是一个空 map 的行为。我们可以等价地将这个操作写成Value(nil).Get("item")，但是如果你直接写nil.Get("item")的话是无法通过编译的，因为 nil 的字面量编译器无法判断其准确类型。所以相比之下，最后的那行 m.Add 的调用就会产生一个 panic，因为他尝试更新一个空map。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><b>【IMPORTANT】</b></font>另外，对于上面的代码可能有读者会有疑惑，为什么 Add 函数的接收器是一个对象 (i.e. 上面例子中的 m)，然而我们还可以向 m 中添加元素呢？说好的使用对象作为接收器的方法操作的是该对象的一份拷贝呢？事实是，Value 类型的底层是 map[string][]string，是一个 map 复合类型，而 map 复合类型其实是一个指针<sup>[2]</sup>。因此实际上当我们在函数 Add 中得到的是一个指针值的拷贝，因此当我们使用 append 对 map 进行操作的时候，操作的还是原始 map。<font color="red">在 Golang 中，map、指针、函数、方法、chan 和 slice 都是引用类型 (reference type)，</font>这代表着当它们作为形式参数被送进函数/方法时，可以直接使用值的形式传入，并且支持在函数/方法中对它们本体进行修改，因为它们是引用类型，它们的底层是使用指针实现的。对于这些类型，在对它们使用指针时应该比较注意<sup>[3]</sup>：
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) slices: Use a pointer when you may need to modify the length or capacity, which changes the value of the slice.
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) maps: Don't use a pointer, since the map value doesn't change with modifications.
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) functions and methods: Don't use a pointer, the same effect is had through function values.
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) chan: Don't use a pointer.

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;所以，由于 url.Values 是一个 map 类型，并且由于 map 复合类型其实是一个指针的原因，url.Values.Add 事实上间接引用了这个 map 底层的 key/value 对，因此 url.Values.Add 对这个 map 里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为 nil，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想 C 语言，是差不多的）
</div>

<h2><a name="3_embedded_struct">3. 通过嵌入结构体来扩展类型</a></h2>
<div class="div_learning_post_boder">
  <h3><a name="3_embedded_struct"></a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;来看看 ColoredPoint 这个类型：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;image/color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">  Point</span><br><span class="line">  Color color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们完全可以将 ColoredPoint 定义为一个有三个字段的 struct，但是我们却将 Point 这个类型嵌入到 ColoredPoint 来提供 X 和 Y 这两个字段。像我们在第 3 章中看到的那样，内嵌可以使我们在定义 ColoredPoint 时得到一种句法上的简写形式，并使其包含 Point 类型所具有的一切字段，然后再定义一些自己的。如果我们想要的话，我们可以直接认为通过嵌入的字段就是 ColoredPoint 自身的字段，而完全不需要在调用时指出 Point，比如下面这样。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cp ColoredPoint</span><br><span class="line">cp.X = <span class="number">1</span></span><br><span class="line">fmt.Println(cp.Point.X) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">cp.Point.Y = <span class="number">2</span></span><br><span class="line">fmt.Println(cp.Y) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 Point 中的方法我们也有类似的用法，我们可以把 ColoredPoint 类型当作接收器来调用 Point 里的方法，即使 ColoredPoint 里没有声明这些方法：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>&#125;</span><br><span class="line">blue := color.RGBA&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line"><span class="keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">q.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Point 类的方法也被引入了 ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将 Point 看作一个基类，而 ColoredPoint 看作其子类或者继承类，或者将 ColoredPoint 看作 "is a" Point 类型。但这是错误的理解。请注意上面例子中对 Distance 方法的调用。Distance 有一个参数是 Point 类型，但 q 并不是一个 Point 类，所以尽管 q 有着 Point 这个内嵌类型，我们也必须要显式地选择它。尝试直接传 q 的话你会看到下面这样的错误：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.Distance(q) <span class="comment">// compile error: cannot use q (ColoredPoint) as Point</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;一个 ColoredPoint 并不是一个 Point，但他 "has a" Point，并且它有从 Point 类里引入的 Distance 和 ScaleBy 方法。如果你喜欢从实现的角度来考虑问题，<font color="red">内嵌字段会指导编译器去生成额外的<b>包装方法</b>来委托已经声明好的方法</font>，和下面的形式是等价的：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ColoredPoint)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.Point.Distance(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ColoredPoint)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">  p.Point.ScaleBy(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当 Point.Distance 被第一个包装方法调用时，它的接收器值是 p.Point，而不是 p，当然了，在 Point 类的方法里，你是访问不到 ColoredPoint 的任何字段的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（译注：访问需要通过该指针指向的对象去取）。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个 ColoredPoint 的声明内嵌了一个 *Point 的指针。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">*Point</span><br><span class="line">   Color color.RGBA</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> p := ColoredPoint&#123;&amp;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line"> q := ColoredPoint&#123;&amp;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line"> fmt.Println(p.Distance(*q.Point)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line"> q.Point = p.Point                 <span class="comment">// p and q now share the same Point</span></span><br><span class="line"> p.ScaleBy(<span class="number">2</span>)</span><br><span class="line"> fmt.Println(*p.Point, *q.Point) <span class="comment">// &quot;&#123;2 2&#125; &#123;2 2&#125;&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;一个 struct 类型也可能会有多个匿名字段。我们将 ColoredPoint 定义为下面这样：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">  Point</span><br><span class="line">  color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;然后这种类型的值便会拥有 Point 和 RGBA 类型的所有方法，以及直接定义在 ColoredPoint 中的方法。当编译器解析一个选择器到方法时，比如 p.ScaleBy，它会首先去找直接定义在这个类型里的 ScaleBy 方法，然后找被 ColoredPoint 的内嵌字段们引入的方法，然后去找 Point 和 RGBA 的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;方法只能在命名类型（像Point）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名 struct 类型来定义方法也有了手段。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是一个小 trick。这个例子展示了简单的 cache，其使用两个包级别的变量来实现，一个 mutex 互斥量和它所操作的 cache：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  mu sync.Mutex <span class="comment">// guards mapping</span></span><br><span class="line">  mapping = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  v := mapping[key]</span><br><span class="line">  mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面这个版本在功能上是一致的，但将两个包级别的变量放在了 cache 这个 struct 一组内：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  cache.Lock()</span><br><span class="line">  v := cache.mapping[key]</span><br><span class="line">  cache.Unlock()</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们给新的变量起了一个更具表达性的名字：cache。因为 sync.Mutex 字段也被嵌入到了这个 struct 里，其 Lock 和 Unlock 方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。
</div>

<h2><a name="4_method_value">4. 方法值和方法表达式</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们经常选择一个方法，并且在同一个表达式里执行，比如常见的 p.Distance() 形式，实际上将其分成两步来执行也是可能的。p.Distance 叫作 <b>“选择器”</b>，选择器会返回一个方法“值”，即选择器是一个将方法（Point.Distance）绑定到特定接收器变量的函数。<font color="red">这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器（译注：因为已经在前文中指定过了）</font>，只要传入函数的参数即可：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distanceFromP := p.Distance        <span class="comment">// method value</span></span><br><span class="line">fmt.Println(distanceFromP(q))      <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="keyword">var</span> origin Point                   <span class="comment">// &#123;0, 0&#125;</span></span><br><span class="line">fmt.Println(distanceFromP(origin)) <span class="comment">// &quot;2.23606797749979&quot;, sqrt(5)</span></span><br><span class="line"></span><br><span class="line">scaleP := p.ScaleBy <span class="comment">// method value</span></span><br><span class="line">scaleP(<span class="number">2</span>)           <span class="comment">// p becomes (2, 4)</span></span><br><span class="line">scaleP(<span class="number">3</span>)           <span class="comment">//      then (6, 12)</span></span><br><span class="line">scaleP(<span class="number">10</span>)          <span class="comment">//      then (60, 120)</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在一个包的 API 需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法“值”会非常实用。举例来说，下面例子中的 time.AfterFunc 这个函数的功能是在指定的延迟时间之后来执行一个（译注：另外的）函数，且这个函数操作的是一个 Rocket 对象 r

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rocket <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rocket)</span> <span class="title">Launch</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">r := <span class="built_in">new</span>(Rocket)</span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; r.Launch() &#125;)</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;直接用方法“值”传入 AfterFunc 的话可以更为简短：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, r.Launch)</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;译注：省掉了上面那个例子里的匿名函数。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;和方法“值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（p.Distance）语法来指定方法的接收器。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当 T 是一个类型 (而不是一个具体声明好的某种类型的变量)时，方法表达式可能会写作 T.f 或者 (*T).f，会返回一个函数“值”，这种函数会将其第一个参数用作接收器，所以可以用通常（译注：不写选择器）的方式来对其进行调用：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// method expression</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// &quot;5&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance) <span class="comment">// &quot;func(Point, Point) float64&quot;</span></span><br><span class="line"></span><br><span class="line">scale := (*Point).ScaleBy</span><br><span class="line">scale(&amp;p, <span class="number">2</span>)</span><br><span class="line">fmt.Println(p)            <span class="comment">// &quot;&#123;2 4&#125;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, scale) <span class="comment">// &quot;func(*Point, float64)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，</span></span><br><span class="line"><span class="comment">// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，</span></span><br><span class="line"><span class="comment">// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。</span></span><br><span class="line"><span class="comment">// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。</font>你可以根据选择来调用接收器各不相同的方法。下面的例子，变量 op 代表 Point 类型的 addition 或者 subtraction 方法，Path.TranslateBy 方法会为其 Path 数组中的每一个 Point 来调用对应的方法：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(q Point)</span> <span class="title">Point</span></span> &#123; <span class="keyword">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Sub</span><span class="params">(q Point)</span> <span class="title">Point</span></span> &#123; <span class="keyword">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span> <span class="title">TranslateBy</span><span class="params">(offset Point, add <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> op <span class="function"><span class="keyword">func</span><span class="params">(p, q Point)</span> <span class="title">Point</span></span></span><br><span class="line">  <span class="keyword">if</span> add &#123;</span><br><span class="line">    op = Point.Add</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    op = Point.Sub</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> path &#123;</span><br><span class="line">    <span class="comment">// Call either path[i].Add(offset) or path[i].Sub(offset).</span></span><br><span class="line">    path[i] = op(path[i], offset)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<h2><a name="5_bit_array">5. Bit 数组</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Go 语言里的集合一般会用 map[T]bool 这种形式来表示，T 代表元素类型。集合用 map 类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，<b>bit 数组</b>会比 map 表现更加理想。<font color="red">（译注：这里再补充一个例子，比如我们执行一个 http 下载任务，把文件按照 16kb 一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到 bit 数组。）</font>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;一个 bit 数组通常会用一个无符号数或者称之为“字”的 slice 来表示，<b>每一个元素的每一位</b>都表示集合里的一个值。当集合的第 i 位被设置时，我们才说这个集合包含元素 i。下面的这个程序展示了一个简单的 bit 数组类型，并且实现了三个函数来对这个 bit 数组来进行操作：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntSet is a set of small non-negative integers.</span></span><br><span class="line"><span class="comment">// Its zero value represents the empty set.</span></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">  words []<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has reports whether the set contains the non-negative value x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Has</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  word, bit := x/<span class="number">64</span>, <span class="keyword">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">  <span class="keyword">return</span> word &lt; <span class="built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="number">1</span>&lt;&lt;bit) != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the non-negative value x to the set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  word, bit := x/<span class="number">64</span>, <span class="keyword">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">  <span class="keyword">for</span> word &gt;= <span class="built_in">len</span>(s.words) &#123;</span><br><span class="line">    s.words = <span class="built_in">append</span>(s.words, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  s.words[word] |= <span class="number">1</span> &lt;&lt; bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="comment">// UnionWith sets s to the union of s and t.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">UnionWith</span><span class="params">(t *IntSet)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i, tword := <span class="keyword">range</span> t.words &#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s.words) &#123;</span><br><span class="line">      s.words[i] |= tword</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s.words = <span class="built_in">append</span>(s.words, tword)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;因为每一个字都有 64 个二进制位，所以为了定位 x 的bit位，我们用了 x/64 的商作为字的下标，并且用 x%64 得到的值作为这个字内的 bit 的所在位置。UnionWith 这个方法里用到了bit 位的 “或” 逻辑操作符号 | 来一次完成 64 个元素的或计算。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当前这个实现还缺少了很多必要的特性，有一个方法如果缺失的话我们的 bit 数组可能会比较难混：将 IntSet 作为一个字符串来打印。这里我们来实现它，让我们来给上面的例子添加一个String 方法：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">  buf.WriteByte(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">    <span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> buf.Len() &gt; <span class="built_in">len</span>(<span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">          buf.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, <span class="number">64</span>*i+j)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  buf.WriteByte(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里留意一下 String 方法，bytes.Buffer 在 String 方法里经常这么用。当你为一个复杂的类型定义了一个 String 方法时，fmt 包就会特殊对待这种类型的值，这样可以让这些类型在打印的时候看起来更加友好，而不是直接打印其原始的值。fmt 会直接调用用户定义的 String 方法。这种机制依赖于接口和类型断言，在第 6 章中我们会详细介绍。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在我们就可以在实战中直接用上面定义好的 IntSet 了：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y IntSet</span><br><span class="line">x.Add(<span class="number">1</span>)</span><br><span class="line">x.Add(<span class="number">144</span>)</span><br><span class="line">x.Add(<span class="number">9</span>)</span><br><span class="line">fmt.Println(x.String()) <span class="comment">// &quot;&#123;1 9 144&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">y.Add(<span class="number">9</span>)</span><br><span class="line">y.Add(<span class="number">42</span>)</span><br><span class="line">fmt.Println(y.String()) <span class="comment">// &quot;&#123;9 42&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">x.UnionWith(&amp;y)</span><br><span class="line">fmt.Println(x.String()) <span class="comment">// &quot;&#123;1 9 42 144&#125;&quot;</span></span><br><span class="line">fmt.Println(x.Has(<span class="number">9</span>), x.Has(<span class="number">123</span>)) <span class="comment">// &quot;true false&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里要注意：我们声明的 String 和 Has 两个方法都是以指针类型 *IntSet 来作为接收器的，但实际上对于这两个类型来说，把接收器声明为指针类型也没什么必要。不过另外两个函数就不是这样了，因为另外两个函数操作的是 s.words 对象，如果你不把接收器声明为指针对象，那么实际操作的是拷贝对象，而不是原来的那个对象。因此，因为我们的 String 方法定义在 IntSet 指针上，所以当我们的变量是IntSet类型而不是IntSet指针时，可能会有下面这样让人意外的情况：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&amp;x)         <span class="comment">// &quot;&#123;1 9 42 144&#125;&quot;</span></span><br><span class="line">fmt.Println(x.String()) <span class="comment">// &quot;&#123;1 9 42 144&#125;&quot;</span></span><br><span class="line">fmt.Println(x)          <span class="comment">// &quot;&#123;[4398046511618 0 65536]&#125;&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在第一个 Println 中，我们打印一个 *IntSet 的指针，这个类型的指针确实有自定义的 String 方法。第二个 Println，我们直接调用了 x 变量的 String() 方法；这种情况下编译器会隐式地在 x 前插入 & 操作符，这样相当于我们还是调用的 IntSet 指针的 String 方法。在第三个 Println 中，因为 IntSet 类型没有String方法，所以 Println 方法会直接以原始的方式理解并打印。所以在这种情况下 & 符号是不能忘的。在我们这种场景下，你把 String 方法绑定到 IntSet 对象上，而不是 IntSet 指针上可能会更合适一些，不过这也需要具体问题具体分析。
</div>

<h2><a name="6_encapsulation">6. 封装</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为</font><b>“封装”</b>。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Go 语言只有一种控制可见性的手段：<font color="red">大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。</font>这种限制包内成员的方式同样适用于 struct 或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个 struct。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这也就是前面的小节中 IntSet 被定义为 struct 类型的原因，尽管它只有一个字段：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    words []<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当然，我们也可以把 IntSet 定义为一个 slice 类型，但这样我们就需要把代码中所有方法里用到的 s.words 用 *s 替换掉了：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet []<span class="keyword">uint64</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;尽管这个版本的 IntSet 在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个 slice。换句话说，相对于 *s 这个表达式会出现在所有的包中，s.words 只需要在定义 IntSet 的包中出现（译注：所以还是推荐后者的意思）。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这种基于名字的手段使得在语言中最小的封装单元是 package，而不是像其它语言一样的类型。一个 struct 类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的 api 情况下能得到更大的自由。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;把 bytes.Buffer 这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为 Buffer 是一个 struct 类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer 和其增长算法我们列在这里，为了简洁性稍微做了一些精简：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf     []<span class="keyword">byte</span></span><br><span class="line">    initial [<span class="number">64</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow expands the buffer&#x27;s capacity, if necessary,</span></span><br><span class="line"><span class="comment">// to guarantee space for another n bytes. [...]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b.buf == <span class="literal">nil</span> &#123;</span><br><span class="line">        b.buf = b.initial[:<span class="number">0</span>] <span class="comment">// use preallocated space initially</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b.buf)+n &gt; <span class="built_in">cap</span>(b.buf) &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, b.Len(), <span class="number">2</span>*<span class="built_in">cap</span>(b.buf) + n)</span><br><span class="line">        <span class="built_in">copy</span>(buf, b.buf)</span><br><span class="line">        b.buf = buf</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的 Counter 类型允许调用方来增加 counter 变量的值，并且允许将这个值 reset 为0，但是不允许随便设置这个值（译注：因为压根就访问不到）：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123; n <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">N</span><span class="params">()</span> <span class="title">int</span></span>     &#123; <span class="keyword">return</span> c.n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Increment</span><span class="params">()</span></span> &#123; c.n++ &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Reset</span><span class="params">()</span></span>     &#123; c.n = <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;只用来访问或修改内部变量的函数被称为 setter 或者 getter，例子如下，比如 log 包里的 Logger 类型对应的一些函数。<font color="red">在命名一个 getter 方法时，我们通常会省略掉前面的 Get 前缀。</font>这种简洁上的偏好也可以推广到各种类型的前缀比如Fetch，Find或者Lookup。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">  flags  <span class="keyword">int</span></span><br><span class="line">  prefix <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">Flags</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">SetFlags</span><span class="params">(flag <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">Prefix</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">SetPrefix</span><span class="params">(prefix <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Go 的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证 API 兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;封装并不总是理想的。虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：time.Duration 将其表现暴露为一个 int64 数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> day = <span class="number">24</span> * time.Hour</span><br><span class="line">fmt.Println(day.Seconds()) <span class="comment">// &quot;86400&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;另一个例子，将 IntSet 和本章开头的 geometry.Path 进行对比。Path 被定义为一个 slice 类型，这允许其调用 slice 的字面方法来对其内部的 points 用 range 进行迭代遍历。在这一点上，IntSet是没有办法让你这么做的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这两种类型决定性的不同：geometry.Path 的本质是一个坐标点的序列，不多也不少，我们可以预见到之后也并不会给他增加额外的字段，所以在 geometry 包中将 Path 暴露为一个 slice。相比之下，IntSet 仅仅是在这里用了一个 []uint64 的 slice。这个类型还可以用 []uint 类型来表示，或者我们甚至可以用其它完全不同的占用更小内存空间的东西来表示这个集合，所以我们可能还会需要额外的字段来在这个类型中记录元素的个数。也正是因为这些原因，我们让 IntSet 对调用方不透明。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这章中，我们学到了如何将方法与命名类型进行组合，并且知道了如何调用这些方法。尽管方法对于 OOP 编程来说至关重要，但他们只是 OOP 编程里的半边天。为了完成 OOP，我们还需要接口。Go 里的接口会在下一章中介绍。
</div>


<!--ref-->
<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>

<ol>
<li>github.com, <a target="_blank" rel="noopener" href="https://github.com/gopl-zh/gopl-zh.github.com/tree/master/ch6">Go语言圣经(中文版) Chapter 6</a></li>
<li>Dave Cheney, <a target="_blank" rel="noopener" href="https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it">If a map isn’t a reference variable, what is it?</a></li>
<li>Stack Overflow, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31170368/go-reference-types-as-arguments#:~:text=Certain%20types%20in%20Go%20are,channels%2C%20functions%2C%20and%20methods.&text=You%20need%20it%20because%20all,capacity%20is%20not%20big%20enough.">Go: reference types as arguments</a>
</p>
</div>

</li>
</ol>
</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_Program/">TECH_PROGRAM</a></li>
          <li>GO_BASIC_5_METHOD</li>
        
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar_2.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
