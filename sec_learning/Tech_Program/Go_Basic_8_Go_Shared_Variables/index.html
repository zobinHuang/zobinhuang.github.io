<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zobinhuang.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"hide","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#FF4136","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_catalogue{padding: 10px 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="基于共享变量的并发">
<meta property="og:url" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Basic_8_Go_Shared_Variables/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_catalogue{padding: 10px 10p">
<meta property="og:locale">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Basic_8_Go_Shared_Variables/pic/xxx.png">
<meta property="article:published_time" content="2022-02-10T14:39:11.508Z">
<meta property="article:modified_time" content="2021-09-07T12:09:22.000Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Basic_8_Go_Shared_Variables/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>基于共享变量的并发 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Loves Tech & Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-关于我">

    <a href="/sec_about/" rel="section"><i class="fa fa-address-card fa-fw"></i>关于我</a>

  </li>
        <li class="menu-item menu-item-知识库">

    <a href="/sec_learning/" rel="section"><i class="fa fa-book-open fa-fw"></i>知识库</a>

  </li>
        <li class="menu-item menu-item-进度">

    <a href="/sec_schedule/" rel="section"><i class="fa fa-calendar-alt fa-fw"></i>进度</a>

  </li>
        <li class="menu-item menu-item-独立音乐人">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>独立音乐人</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="cn">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">基于共享变量的并发
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_Program/">TECH_PROGRAM</a></li>
          <li>GO_BASIC_8_GO_SHARED_VARIABLES</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_boder{padding: 10px 10px; font-size: 16px; word-spacing:0px;  border:1px solid black;}
</style>
<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>协作者：ZobinHuang，更新日期：June.14 2021</i></font></h4>
  <div align="left">
  <font size="2px">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;这篇文章内容的一些部分是转载自<a target="_blank" rel="noopener" href="https://github.com/gopl-zh/gopl-zh.github.com">Go 语言圣经（中文版）</a>，并加上了本人在使用过程中的一些自己的理解和经验，最终整理成可读性更高的网页形式。在此向原作者和译者表示感谢，他们给社区提供了很棒的 Golang 入门参考。
    <br>&nbsp;&nbsp;&nbsp;&nbsp;原作者：Alan A. A. Donovan · Brian W. Kernighan;
    <br>&nbsp;&nbsp;&nbsp;&nbsp;  译者：柴树杉，Github @chai2010，Twitter @chaishushan；Xargin, https://github.com/cch123；CrazySssst；foreversmart, njutree@gmail.com
  </font>
  </div>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">此文篇幅较长，故设置目录，有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 0. <a href="#0_preface"><font color="blue"><b>前言</b></font></a>：阐述了本章的主要内容；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_race_conditions"><font color="blue"><b>竞争条件</b></font></a>：给出了解决 Golang 中对变量进行并发访问的数据冲突问题的三种方法，详细讨论了其中两种；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_mutex"><font color="blue"><b>sync.Mutex 互斥锁</b></font></a>：展示了 Golang 中互斥锁的用法，以及在使用过程中可能会不小心产生的 bug；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 3. <a href="#3_rwmutex"><font color="blue"><b>sync.RWMutex 读写锁</b></font></a>：展示了 Golang 中多读单写锁的用法；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 4. <a href="#4_memory_sync"><font color="blue"><b>内存同步</b></font></a>：阐述了使用 mutex 进行互斥的两种理由：(1) 保证 goroutinue 对变量的访问顺序，(2) 保证共享变量在内存中的一致性；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 5. <a href="#5_once"><font color="blue"><b>sync.Once 惰性初始化</b></font></a>：讨论了 Golang 提供的一次性初始化互斥工具 sync.Once 的用法；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 6. <a href="#6_race_check"><font color="blue"><b>竞争条件检测</b></font></a>：展示了 Golang 提供了对共享内存并发访问的观测手段；
    <p> 
    &nbsp;&nbsp;&nbsp;&nbsp;Section 7. <a href="#7_concurrent_cache"><font color="blue"><b>示例: 并发的非阻塞缓存</b></font></a>：通过实现一个函数调用缓存，展示了在 Golang 中通过互斥锁或者基于 monitor goroutinue 的通信机制来实现对共享变量进行使用的方法和技巧；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 8. <a href="#8_goroutinues_and_thread"><font color="blue"><b>Goroutines 和 线程</b></font></a>：讨论了 Golang 和操作系统线程的区别
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1 <a href="#8_goroutinues_and_thread_1"><font color="blue">动态栈</font></a>：讨论了 Goroutinue 与操作系统线程不同的动态大小的栈；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2 <a href="#8_goroutinues_and_thread_2"><font color="blue">Goroutine 调度</font></a>：讨论了 Goroutinue 的调度策略；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3 <a href="#8_goroutinues_and_thread_3"><font color="blue">GOMAXPROCS</font></a>：讨论了决定 Goroutinue 运行在多少操作系统线程上的环境变量 GOMAXPROCS；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.4 <a href="#8_goroutinues_and_thread_4"><font color="blue">Goroutine 没有 ID 号</font></a>：讨论了 Goroutinue 故意没有 ID 号的原因
  </div>
</div>

<!--标题-->
<h2><a name="0_preface">0. 前言</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;前一章我们介绍了一些使用 goroutine 和 channel 这样直接而自然的方式来实现并发的方法。然而这样做我们实际上回避了在写并发代码时必须处理的一些重要而且细微的问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们会细致地了解并发机制。尤其是在多 goroutine 之间的共享变量，并发问题的分析手段，以及解决这些问题的基本模式。最后我们会解释 goroutine 和操作系统线程之间的技术上的一些区别。
</div>

<h2><a name="1_race_conditions">1. 竞争条件</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在一个线性（就是说只有一个 goroutine 的）的程序中，程序的执行顺序只由程序的逻辑来决定。例如，我们有一段语句序列，第一个在第二个之前（废话），以此类推。在有两个或更多 goroutine 的程序中，每一个 goroutine 内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个 goroutin 的事件 x 和 y 的执行顺序，x 是在 y 之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明 x 和 y 这两个事件是并发的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">考虑一下，一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是</font><b>并发安全</b><font color="red">的，并发安全的函数不需要额外的同步工作。</font>我们可以把这个概念概括为一个特定类型的一些方法和操作函数，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在一个程序中有非并发安全的类型的情况下，我们依然可以使这个程序并发安全。确实，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它。我们会避免并发访问大多数的类型，无论是将变量局限在单一的一个 goroutine 内，还是用互斥条件维持更高级别的不变性，都是为了这个目的。我们会在本章中说明这些术语。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;相反，包级别的导出函数一般情况下都是并发安全的。由于 package 级的变量没法被限制在单一的 gorouine，所以修改这些变量“必须”使用互斥条件。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;一个函数在并发调用时没法工作的原因太多了，比如死锁（deadlock）、活锁（livelock）和饿死（resource starvation）。我们没有空去讨论所有的问题，这里我们只聚焦在<b>竞争条件</b>上。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;竞争条件指的是程序在多个 goroutine 交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;传统上经常用经济损失来为竞争条件做比喻，所以我们来看一个简单的银行账户程序。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package bank implements a bank with only one account.</span></span><br><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123; balance = balance + amount &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> balance &#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;(当然我们也可以把 Deposit 存款函数写成 balance += amount，这种形式也是等价的，不过长一些的形式解释起来更方便一些。)

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于这个简单的程序而言，我们一眼就能看出，以任意顺序调用函数 Deposit 和 Balance 都会得到正确的结果。也就是说，Balance 函数会给出之前的所有存入的额度之和。然而，当我们并发地而不是顺序地调用这些函数的话，Balance 就再也没办法保证结果正确了。考虑一下下面的两个 goroutine，其代表了一个银行联合账户的两笔交易：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alice:</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  bank.Deposit(<span class="number">200</span>)                <span class="comment">// A1</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;=&quot;</span>, bank.Balance()) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bob:</span></span><br><span class="line"><span class="keyword">go</span> bank.Deposit(<span class="number">100</span>)                 <span class="comment">// B</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Alice 存了 $200，然后检查她的余额，同时 Bob 存了 $100。因为 A1 和 A2 是和 B 并发执行的，我们没法预测他们发生的先后顺序。直观地来看的话，我们会认为其执行顺序只有三种可能性：“ Alice 先”，“ Bob 先”以及“ Alice/Bob/Alice ”交错执行。下面的表格会展示经过每一步骤后 balance 变量的值。引号里的字符串表示余额单。

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Alice first        Bob first        Alice/Bob/Alice</span><br><span class="line">        0                0                      0</span><br><span class="line">A1    200        B     100             A1     200</span><br><span class="line">A2 <span class="string">&quot;= 200&quot;</span>       A1    300             B      300</span><br><span class="line">B     300        A2 <span class="string">&quot;= 300&quot;</span>            A2  <span class="string">&quot;= 300&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;所有情况下最终的余额都是 $300。唯一的变数是 Alice 的余额单是否包含了 Bob 交易，不过无论怎么着客户都不会在意。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;但是事实是上面的直觉推断是错误的。第四种可能的结果是事实存在的，这种情况下 Bob 的存款会在 Alice 存款操作中间，在余额被读到（balance + amount）之后，在余额被更新之前（balance = ...），这样会导致Bob的交易丢失。而这是因为 Alice 的存款操作 A1 实际上是两个操作的一个序列，读取然后写；可以称之为 A1r 和 A1w。下面是交叉时产生的问题：

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Data race</span><br><span class="line">0</span><br><span class="line">A1r      0     ... = balance + amount</span><br><span class="line">B      100</span><br><span class="line">A1w    200     balance = ...</span><br><span class="line">A2  <span class="string">&quot;= 200&quot;</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 A1r 之后，balance + amount 会被计算为 200，所以这是 A1w 会写入的值，并不受其它存款操作的干预。最终的余额是 $200。银行的账户上的资产比 Bob 实际的资产多了 $100。（译注：因为丢失了 Bob 的存款操作，所以其实是说 Bob 的钱丢了。）

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个程序包含了一个特定的竞争条件，叫作<b>数据竞争</b>。<font color="red">无论任何时候，只要有两个 goroutine 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。</font>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果数据竞争的对象是一个比一个机器字（译注：32 位机器上一个字 =4 个字节）更大的类型时，事情就变得更麻烦了，比如 interface，string 或者 slice 类型都是如此。下面的代码会并发地更新两个不同长度的 slice：


  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000000</span>) &#125;()</span><br><span class="line">x[<span class="number">999999</span>] = <span class="number">1</span> <span class="comment">// <span class="doctag">NOTE:</span> undefined behavior; memory corruption possible!</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;最后一个语句中的 x 的值是未定义的；其可能是 nil，或者也可能是一个长度为 10 的 slice，也可能是一个长度为 1,000,000 的 slice。但是回忆一下 slice 的三个组成部分：指针（pointer）、长度（length）和容量（capacity）。如果指针是从第一个make调用来，而长度从第二个make来，x 就变成了一个混合体，一个自称长度为 1,000,000 但实际上内部只有 10 个元素的slice。这样导致的结果是存储 999,999 元素的位置会碰撞一个遥远的内存位置，这种情况下难以对值进行预测，而且 debug 也会变成噩梦。这种语义雷区被称为未定义行为，对 C 程序员来说应该很熟悉；幸运的是在 Go 语言里造成的麻烦要比 C 里小得多。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;尽管并发程序的概念让我们知道并发并不是简单的语句交叉执行。我们将会在第 4 小节中看到，数据竞争可能会有奇怪的结果。许多程序员，甚至一些非常聪明的人也还是会偶尔提出一些理由来允许数据竞争，比如：“互斥条件代价太高”，“这个逻辑只是用来做 logging”，“我不介意丢失一些消息”等等。因为在他们的编译器或者平台上很少遇到问题，可能给了他们错误的信心。一个好的经验法则是根本就没有什么所谓的良性数据竞争。所以我们一定要避免数据竞争，那么在我们的程序中要如何做到呢？

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们来重复一下数据竞争的定义，因为实在太重要了：<b>数据竞争会在两个以上的 goroutine 并发访问相同的变量且至少其中一个为写操作时发生。</b>根据上述定义，有三种方式可以避免数据竞争：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第一种方法是不要去写变量。考虑一下下面的 map，会被“懒”填充，也就是说在每个 key 被第一次请求到的时候才会去填值。如果 Icon 是被顺序调用的话，这个程序会工作很正常，但如果 Icon 被并发调用，那么对于这个 map 来说就会存在数据竞争。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">  icon, ok := icons[name]</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    icon = loadIcon(name)</span><br><span class="line">    icons[name] = icon</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;反之，如果我们在创建 goroutine 之前的初始化阶段，就初始化了 map 中的所有条目并且再也不去修改它们，那么任意数量的 goroutine 并发访问 Icon 都是安全的，因为每一个 goroutine 都只是去读取而已。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">  <span class="string">&quot;spades.png&quot;</span>:   loadIcon(<span class="string">&quot;spades.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="string">&quot;hearts.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="string">&quot;diamonds.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="string">&quot;clubs.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123; <span class="keyword">return</span> icons[name] &#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的例子里 icons 变量在包初始化阶段就已经被赋值了，包的初始化是在程序 main 函数开始执行之前就完成了的。只要初始化完成了，icons 就再也不会被修改。数据结构如果从不被修改或是不变量则是并发安全的，无需进行同步。不过显然，如果 update 操作是必要的，我们就没法用这种方法，比如说银行账户。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第二种避免数据竞争的方法是，避免从多个 goroutine 访问变量。这也是前一章中大多数程序所采用的方法。例如前面的并发 web 爬虫(第 7 章) 的 main goroutine 是唯一一个能够访问 seen map 的 goroutine，而聊天服务器(第 7 章) 中的 broadcaster goroutine 是唯一一个能够访问 clients map 的 goroutine。这些变量都被限定在了一个单独的 goroutine中。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于其它的 goroutine 不能够直接访问变量，它们只能使用一个 channel 来发送请求给指定的 goroutine 来查询更新变量。这也就是 Go 的口头禅：<font color="red">“不要使用共享数据来通信；使用通信来共享数据”。</font>一个提供对一个指定的变量通过 channel 来请求的 goroutine 叫做这个变量的 monitor（监控）goroutine。例如 broadcaster goroutine 会监控 clients map 的全部访问。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是一个重写了的银行的例子，这个例子中 balance 变量被限制在了 monitor goroutine 中，名为 teller：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package bank provides a concurrency-safe bank with one account.</span></span><br><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposits = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// send amount to deposit</span></span><br><span class="line"><span class="keyword">var</span> balances = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// receive balance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123; deposits &lt;- amount &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span>       &#123; <span class="keyword">return</span> &lt;-balances &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teller</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> balance <span class="keyword">int</span> <span class="comment">// balance is confined to teller goroutine</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> amount := &lt;-deposits:</span><br><span class="line">      balance += amount</span><br><span class="line">    <span class="keyword">case</span> balances &lt;- balance:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> teller() <span class="comment">// start the monitor goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;即使当一个变量无法在其整个生命周期内被绑定到一个独立的 goroutine，绑定依然是并发问题的一个解决方案。例如在一条流水线上的 goroutine 之间共享变量是很普遍的行为，在这两者间会通过 channel 来传输地址信息。如果流水线的每一个阶段都能够避免在将变量传送到下一阶段后再去访问它，那么对这个变量的所有访问就是线性的。其效果是变量会被绑定到流水线的一个阶段，传送完之后被绑定到下一个，以此类推。这种规则有时被称为串行绑定。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面的例子中，Cakes 会被严格地顺序访问，先是 baker gorouine，然后是 icer gorouine：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cake <span class="keyword">struct</span>&#123; state <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">baker</span><span class="params">(cooked <span class="keyword">chan</span>&lt;- *Cake)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    cake := <span class="built_in">new</span>(Cake)</span><br><span class="line">    cake.state = <span class="string">&quot;cooked&quot;</span></span><br><span class="line">    cooked &lt;- cake <span class="comment">// baker never touches this cake again</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">icer</span><span class="params">(iced <span class="keyword">chan</span>&lt;- *Cake, cooked &lt;-<span class="keyword">chan</span> *Cake)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> cake := <span class="keyword">range</span> cooked &#123;</span><br><span class="line">    cake.state = <span class="string">&quot;iced&quot;</span></span><br><span class="line">    iced &lt;- cake <span class="comment">// icer never touches this cake again</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第三种避免数据竞争的方法是允许很多 goroutine 去访问变量，但是在同一个时刻最多只有一个 goroutine 在访问。这种方式被称为<b>“互斥”</b>，在下一节来讨论这个主题。
</div>

<h2><a name="2_mutex">2. sync.Mutex互斥锁</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在第 7 章的第 6 节中，我们使用了一个 buffered channel 作为一个计数信号量，来保证最多只有 20 个 goroutine 会同时执行 HTTP 请求。同理，我们可以用一个容量只有 1 的 channel 来保证最多只有一个 goroutine 在同一时刻访问一个共享变量。一个只能为 1 和 0 的信号量叫做<b>二元信号量（binary semaphore）</b>。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  sema    = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>) <span class="comment">// a binary semaphore guarding balance</span></span><br><span class="line">  balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire token</span></span><br><span class="line">  balance = balance + amount</span><br><span class="line">  &lt;-sema <span class="comment">// release token</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire token</span></span><br><span class="line">  b := balance</span><br><span class="line">  &lt;-sema <span class="comment">// release token</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这种互斥很实用，而且被 sync 包里的 Mutex 类型直接支持。它的 Lock 方法能够获取到 token(这里叫锁)，并且 Unlock 方法会释放这个 token：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  mu      sync.Mutex <span class="comment">// guards balance</span></span><br><span class="line">  balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  balance = balance + amount</span><br><span class="line">  mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  b := balance</span><br><span class="line">  mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;每次一个 goroutine 访问 bank 变量时（这里只有 balance 余额变量），它都会调用 mutex 的 Lock 方法来获取一个互斥锁。如果其它的 goroutine 已经获得了这个锁的话，这个操作会被阻塞直到其它 goroutine 调用了 Unlock 使该锁变回可用状态。mutex 会保护共享变量。惯例来说，被 mutex 所保护的变量是在 mutex 变量声明之后立刻声明的。如果你的做法和惯例不符，确保在文档里对你的做法进行说明。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Lock 和 Unlock 之间的代码段中的内容 goroutine 可以随便读取或者修改，这个代码段叫做<b>临界区</b>。锁的持有者在其他 goroutine 获取该锁之前需要调用 Unlock。goroutine 在结束后释放锁是必要的，无论以哪条路径通过函数都需要释放，即使是在错误路径中，也要记得释放。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的 bank 程序例证了一种通用的并发模式。<font color="red">一系列的导出函数封装了一个或多个变量，那么访问这些变量唯一的方式就是通过这些函数来做（或者方法，对于一个对象的变量来说）。每一个函数在一开始就获取互斥锁并在最后释放锁，从而保证共享变量不会被并发访问。</font>这种函数、互斥锁和变量的编排叫作<b>监控 monitor</b>（这种老式单词的monitor是受“monitor goroutine”的术语启发而来的。两种用法都是一个代理人保证变量被顺序访问）。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于在存款和查询余额函数中的临界区代码这么短——只有一行，没有分支调用——在代码最后去调用 Unlock 就显得更为直截了当。在更复杂的临界区的应用中，尤其是必须要尽早处理错误并返回的情况下，就很难去（靠人）判断对 Lock 和 Unlock 的调用是在所有路径中都能够严格配对的了。Go 语言里的 defer 简直就是这种情况下的救星：我们用 defer 来调用 Unlock，临界区会隐式地延伸到函数作用域的最后，这样我们就从“总要记得在函数返回之后或者发生错误返回时要记得调用一次 Unlock”这种状态中获得了解放。Go 会自动帮我们完成这些事情。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的例子里 Unlock 会在 return 语句读取完 balance 的值之后执行，所以 Balance 函数是并发安全的。这带来的另一点好处是，我们再也不需要一个本地变量 b 了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;此外，一个 deferred Unlock 即使在临界区发生 panic 时依然会执行，这对于用 recover (第 4 章)来恢复的程序来说是很重要的。defer 调用只会比显式地调用 Unlock 成本高那么一点点，不过却在很大程度上保证了代码的整洁性。大多数情况下对于并发程序来说，代码的整洁性比过度的优化更重要。如果可能的话尽量使用 defer 来将临界区扩展到函数的结束。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;考虑一下下面的 Withdraw 函数。成功的时候，它会正确地减掉余额并返回 true。但如果银行记录资金对交易来说不足，那么取款就会恢复余额，并返回 false。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not atomic!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  Deposit(-amount)</span><br><span class="line">  <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">    Deposit(amount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;函数终于给出了正确的结果，但是还有一点讨厌的副作用。当过多的取款操作同时执行时，balance 可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。所以如果 Bob 尝试买一辆 sports car 时，Alice 可能就没办法为她的早咖啡付款了。<font color="red">这里的问题是取款不是一个原子操作：它包含了三个步骤，每一步都需要去获取并释放互斥锁，但任何一次锁都不会锁上整个取款流程。</font>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  Deposit(-amount)</span><br><span class="line">  <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">    Deposit(amount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面这个例子中，Deposit 会调用 mu.Lock() 第二次去获取互斥锁，但因为 mutex 已经锁上了，而无法被重入（译注：go 里没有重入锁，关于重入锁的概念，请参考 java）——也就是说没法对一个已经锁上的 mutex 来再次上锁——这会导致程序死锁，没法继续执行下去，Withdraw 会永远阻塞下去。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;关于 Go 的 mutex 不能重入这一点我们有很充分的理由。mutex 的目的是确保共享变量在程序执行时的关键点上能够保证不变性。不变性的一层含义是“没有 goroutine 访问共享变量”，但实际上这里对于 mutex 保护的变量来说，不变性还包含更深层含义：当一个 goroutine 获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（译注：即没有其他代码块正在读写共享变量），在其获取并保持锁期间，可能会去更新共享变量，这样不变性只是短暂地被破坏，然而当其释放锁之后，锁必须保证共享变量重获不变性并且多个 goroutine 按顺序访问共享变量。尽管一个可以重入的 mutex 也可以保证没有其它的 goroutine 在访问共享变量，但它不具备不变性更深层含义。（译注：更详细的解释，Russ Cox 认为可重入锁是 bug 的温床，是一个失败的设计）

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;一个通用的解决方案是将一个函数分离为多个函数，比如我们把 Deposit 分离成两个：一个不导出的函数 deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数 Deposit，这个函数会调用 deposit，但在调用前会先去获取锁。同理我们可以将 Withdraw 也表示成这种形式：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  deposit(-amount)</span><br><span class="line">  <span class="keyword">if</span> balance &lt; <span class="number">0</span> &#123;</span><br><span class="line">    deposit(amount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  deposit(amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function requires that the lock be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123; balance += amount &#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当然，这里的存款 deposit 函数很小，实际上取款 Withdraw 函数不需要理会对它的调用，尽管如此，这里的表达还是表明了规则。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;封装，用限制一个程序中的意外交互的方式，可以使我们获得数据结构的不变性。因为某种原因，封装还帮我们获得了并发的不变性。当你使用 mutex 时，确保 mutex 和其保护的变量没有被导出（在 go 里也就是小写，且不要被大写字母开头的函数访问啦），无论这些变量是包级的变量还是一个 struct 的字段。
</div>

<h2><a name="3_rwmutex">3. sync.RWMutex 读写锁</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 100 刀的存款消失时不做记录多少还是会让我们有一些恐慌，Bob 写了一个程序，每秒运行几百次来检查他的银行余额。他会在家，在工作中，甚至会在他的手机上来运行这个程序。银行注意到这些陡增的流量使得存款和取款有了延时，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的 goroutine 运行。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于 Balance 函数只需要读取变量的状态，所以我们同时让多个 Balance 调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款操作就行。在这种场景下我们需要一种特殊类型的锁，<font color="red">其允许多个只读操作并行执行，但写操作会完全互斥。</font>这种锁叫作<b>“多读单写”锁（multiple readers, single writer lock）</b>，Go语言提供的这样的锁是 sync.RWMutex：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mu.RLock() <span class="comment">// readers lock</span></span><br><span class="line">  <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">  <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Balance 函数现在调用了 RLock 和 RUnlock 方法来获取和释放一个读取或者共享锁。Deposit 函数没有变化，会调用 mu.Lock 和 mu.Unlock 方法来获取和释放一个写或互斥锁。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这次修改后，Bob 的余额查询请求就可以彼此并行地执行并且会很快地完成了。锁在更多的时间范围可用，并且存款请求也能够及时地被响应了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">RLock 只能在临界区共享变量没有任何写入操作时可用。</font>一般来说，我们不应该假设逻辑上的只读函数/方法也不会去更新某一些变量。比如一个方法功能是访问一个变量，但它也有可能会同时去给一个内部的计数器+1（译注：可能是记录这个方法的访问次数啥的），或者去更新缓存——使即时的调用能够更快。如果有疑惑的话，请使用互斥锁。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;RWMutex 只有当获得锁的大部分 goroutine 都是读操作，而锁在竞争条件下，也就是说，goroutine 们必须等待才能获取到锁的时候，RWMutex 才是最能带来好处的。其它场景下未见得能带来性能提升，因为 RWMutex 需要更复杂的内部记录，所以会让它比一般的无竞争锁的 mutex 慢一些。
</div>

<h2><a name="4_memory_sync">4. 内存同步</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;你可能比较纠结为什么 Balance 方法需要用到互斥条件，无论是基于 channel 还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它 goroutine 在其执行“期间”执行其它逻辑的风险。这里使用 mutex 有两方面考虑。第一使用 mutex 可以使得 Balance 不会在其它操作比如 Withdraw “中间”执行。第二（更重要的）是“同步”不仅仅是一堆 goroutine 执行顺序的问题，同样也会涉及到内存的问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存（local cache）。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起 flush 到主存。这种情况下这些数据可能会以与当初 goroutine 写入顺序不同的顺序被提交到主存。像 channel 通信或者互斥量操作这样的原语会使处理器将其聚集的写入 flush 并 commit，这样 goroutine 在某个时间点上的执行结果才能被其它处理器上运行的 goroutine 得到。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;考虑一下下面代码片段的可能输出：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x = <span class="number">1</span> <span class="comment">// A1</span></span><br><span class="line">  fmt.Print(<span class="string">&quot;y:&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  y = <span class="number">1</span>                   <span class="comment">// B1</span></span><br><span class="line">  fmt.Print(<span class="string">&quot;x:&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;因为两个 goroutine 是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y:0 x:1</span><br><span class="line">x:0 y:1</span><br><span class="line">x:1 y:1</span><br><span class="line">y:1 x:1</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第四行可以被解释为执行顺序 A1,B1,A2,B2 或者 B1,A1,A2,B2 的执行结果。然而实际运行时还是有些情况让我们有点惊讶：

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:0 y:0</span><br><span class="line">y:0 x:0</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;根据所使用的编译器，CPU，或者其它很多影响因子，这两种情况也是有可能发生的。那么这两种情况要怎么解释呢？

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在一个独立的 goroutine 中，每一个语句的执行顺序是可以被保证的，也就是说 goroutine 内顺序是连贯的。但是在不使用 channel 且不使用 mutex 这样的显式同步操作时，我们就没法保证事件在不同的 goroutine 中看到的执行顺序是一致的了。尽管 goroutine A 中一定需要观察到 x=1 执行成功之后才会去读取 y，但它没法确保自己观察得到 goroutine B 中对 y 的写入，所以 A 还可能会打印出 y 的一个旧版的值。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;尽管去理解并发的一种尝试是去将其运行理解为不同 goroutine 语句的交错执行，但看看上面的例子，这已经不是现代的编译器和 cpu 的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。<font color="red">如果两个 goroutine 在不同的 CPU 上执行，每一个核心有自己的缓存，这样一个 goroutine 的写入对于其它 goroutine 的 Print，在主存同步之前就是不可见的了。</font>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在 goroutine 内部；如果是多个 goroutine 都需要访问的变量，使用互斥条件来访问。
</div>

<h2><a name="5_once">5. sync.Once 惰性初始化</a></h2>
<div class="div_learning_post_boder">
  <h3><a name="1_xxx_1"></a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。</font>如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。让我们来看在本章早一些时候的 icons 变量：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个版本的 Icon 用到了懒初始化（lazy initialization）。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">&quot;spades.png&quot;</span>:   loadIcon(<span class="string">&quot;spades.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="string">&quot;hearts.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="string">&quot;diamonds.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;clubs.png&quot;</span>:	loadIcon(<span class="string">&quot;clubs.png&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">    loadIcons() <span class="comment">// one-time initialization</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果一个变量只被一个单独的 goroutine 所访问的话，我们可以使用上面的这种模板，但这种模板在 Icon 被并发调用时并不安全。就像前面银行的那个 Deposit (存款)函数一样，Icon 函数也是由多个步骤组成的：首先测试 icons 是否为空，然后 load 这些 icons，之后将 icons 更新为一个非空的值。直觉会告诉我们最差的情况是 loadIcons 函数被多次访问会带来数据竞争。当第一个 goroutine 在忙着 loading 这些 icons 的时候，另一个 goroutine 进入了 Icon 函数，发现变量是 nil，然后也会调用 loadIcons 函数。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;不过这种直觉是错误的。（我们希望你从现在开始能够构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的！），回忆一下上面第 4 小节。因为缺少显式的同步，编译器和 CPU 是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个 goroutine 自己的执行顺序一致。其中一种可能 loadIcons 的语句重排是下面这样。它会在填写 icons 变量的值之前先用一个空 map 来初始化 icons 变量。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">  icons[<span class="string">&quot;spades.png&quot;</span>] = loadIcon(<span class="string">&quot;spades.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;hearts.png&quot;</span>] = loadIcon(<span class="string">&quot;hearts.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;diamonds.png&quot;</span>] = loadIcon(<span class="string">&quot;diamonds.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;clubs.png&quot;</span>] = loadIcon(<span class="string">&quot;clubs.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;因此，<font color="red">一个 goroutine 在检查 icons 是非空时，也并不能就假设这个变量的初始化流程已经走完了</font>（译注：可能只是塞了个空 map，里面的值还没填完，也就是说填值的语句都没执行完呢）。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;最简单且正确的保证所有 goroutine 能够观察到 loadIcons 效果的方式，是用一个 mutex 来同步检查。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex <span class="comment">// guards icons</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">    loadIcons()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;然而使用互斥访问 icons 的代价就是没有办法对该变量进行并发访问，即使变量已经被初始化完毕且再也不会进行变动。这里我们可以引入一个允许多读的锁：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex <span class="comment">// guards icons</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">  mu.RLock()</span><br><span class="line">  <span class="keyword">if</span> icons != <span class="literal">nil</span> &#123;</span><br><span class="line">    icon := icons[name]</span><br><span class="line">    mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">  &#125;</span><br><span class="line">  mu.RUnlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// acquire an exclusive lock</span></span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123; <span class="comment">// <span class="doctag">NOTE:</span> must recheck for nil</span></span><br><span class="line">    loadIcons()</span><br><span class="line">  &#125;</span><br><span class="line">  icon := icons[name]</span><br><span class="line">  mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的代码有两个临界区。goroutine 首先会获取一个读锁，查询 map，然后释放锁。如果条目被找到了（一般情况下），那么会直接返回。如果没有找到，那 goroutine 会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查 icons 变量是否为 nil，以防止在执行这一段代码的时候，icons 变量已经被其它 gorouine 初始化过了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的模板使我们的程序能够更好的并发，但是有一点太复杂且容易出错。幸运的是，sync 包为我们提供了一个专门的方案来解决这种一次性初始化的问题：sync.Once。概念上来讲，一次性的初始化需要一个互斥量 mutex 和一个 boolean 变量来记录初始化是不是已经完成了，互斥量用来保护 boolean 变量和客户端数据结构。Do 这个唯一的方法需要接收初始化函数作为其参数。让我们用 sync.Once 来简化前面的 Icon 函数吧：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">  loadIconsOnce.Do(loadIcons)</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;每一次对 Do(loadIcons) 的调用都会锁定 mutex，并会检查 boolean 变量（译注：Go1.9 中会先判断 boolean 变量是否为 1(true)，只有不为 1 才锁定 mutex，不再需要每次都锁定 mutex）。在第一次调用时，boolean 变量的值是 false，Do 会调用 loadIcons 并会将 boolean 变量设置为 true。随后的调用什么都不会做，但是 mutex 同步会保证 loadIcons 对内存（这里其实就是指 icons 变量啦）产生的效果能够对所有 goroutine 可见。用这种方式来使用 sync.Once 的话，我们能够避免在变量被构建完成之前和其它 goroutine 共享该变量。
</div>

<h2><a name="6_race_check">6. 竞争条件检测</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go 的 runtime 和工具链为我们装备了一个复杂但好用的动态分析工具，<b>竞争检查器（the race detector）</b>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;只要在 go build，go run 或者 go test 命令后面加上 -race 的 flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的 test，并且会记录下每一个读或者写共享变量的 goroutine 的身份信息。另外，修改版的程序会记录下所有的同步事件，比如 go 语句，channel 操作，以及对 (*sync.Mutex).Lock，(*sync.WaitGroup).Wait 等等的调用。（完整的同步事件集合是在 The Go Memory Model 文档中有说明，该文档是和语言文档放在一起的。译注：https://golang.org/ref/mem ）

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;竞争检查器会检查这些事件，会寻找在哪一个 goroutine 中出现了这样的 case，例如其读或者写了一个共享变量，这个共享变量是被另一个 goroutine 在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的 goroutine 中活跃的函数的调用栈。这些信息在定位问题时通常很有用。第 7 小节中会有一个竞争检查器的实战样例。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件，并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的程序（工作）来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的 debugging。（译注：多少服务端 C 和 C++ 程序员为此竞折腰。）
</div>

<h2><a name="7_concurrent_cache">7. 示例: 并发的非阻塞缓存</a></h2>
<div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本节中我们会做一个无阻塞的缓存，这种工具可以帮助我们来解决现实世界中并发程序出现但没有现成的库可以解决的问题。这个问题叫作缓存（memoizing）函数（译注：Memoization 的定义：  memoization 一 词是 Donald Michie 根据拉丁语 memorandum 杜撰的一个词。相应的动词、过去分词、ing 形式有 memoiz、memoized、memoizing），也就是说，我们需要缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。我们的解决方案会是并发安全且会避免对整个缓存加锁而导致所有操作都去争一个锁的设计。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们将使用下面的 httpGetBody 函数作为我们需要缓存的函数的一个样例。这个函数会去进行 HTTP GET 请求并且获取 http 响应 body。对这个函数的调用本身开销是比较大的，所以我们尽量避免在不必要的时候反复调用。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpGetBody</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">  resp, err := http.Get(url)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">  <span class="keyword">return</span> ioutil.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;最后一行稍微隐藏了一些细节。ReadAll 会返回两个结果，一个 []byte 数组和一个错误，不过这两个对象可以被赋值给 httpGetBody 的返回声明里的 interface{} 和 error 类型，所以我们也就可以这样返回结果并且不需要额外的工作了。我们在 httpGetBody 中选用这种返回类型是为了使其可以与缓存匹配。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是我们要设计的 cache 的第一个“草稿”：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package memo provides a concurrency-unsafe</span></span><br><span class="line"><span class="comment">// memoization of a function of type Func.</span></span><br><span class="line"><span class="keyword">package</span> memo</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Memo caches the results of calling a Func.</span></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">  f     Func</span><br><span class="line">  cache <span class="keyword">map</span>[<span class="keyword">string</span>]result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Func is the type of the function to memoize.</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span> *<span class="title">Memo</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]result)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">  res, ok := memo.cache[key]</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    res.value, res.err = memo.f(key)</span><br><span class="line">    memo.cache[key] = res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Memo 实例会记录需要缓存的函数 f（类型为 Func），以及缓存内容（里面是一个 string 到 result 映射的 map）。每一个 result 都是简单的函数返回的值对儿 —— 一个值和一个错误值。继续下去我们会展示一些 Memo 的变种，不过所有的例子都会遵循上面的这些方面。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是一个使用 Memo 的例子。对于流入的 URL 的每一个元素我们都会调用 Get，并打印调用延时以及其返回的数据大小的 log：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m := memo.New(httpGetBody)</span><br><span class="line"><span class="keyword">for</span> url := <span class="keyword">range</span> incomingURLs() &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line">  value, err := m.Get(url)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s, %s, %d bytes\n&quot;</span>,</span><br><span class="line">  url, time.Since(start), <span class="built_in">len</span>(value.([]<span class="keyword">byte</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们可以使用测试包（第 10 章的主题）来系统地鉴定缓存的效果。从下面的测试输出，我们可以看到 URL 流包含了一些重复的情况，尽管我们第一次对每一个 URL 的 (*Memo).Get 的调用都会花上几百毫秒，但第二次就只需要花 1 毫秒就可以返回完整的数据了。

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v gopl.io/ch9/memo1</span><br><span class="line">=== RUN   Test</span><br><span class="line">https://golang.org, 175.026418ms, 7537 bytes</span><br><span class="line">https://godoc.org, 172.686825ms, 6878 bytes</span><br><span class="line">https://play.golang.org, 115.762377ms, 5767 bytes</span><br><span class="line">http://gopl.io, 749.887242ms, 2856 bytes</span><br><span class="line">https://golang.org, 721ns, 7537 bytes</span><br><span class="line">https://godoc.org, 152ns, 6878 bytes</span><br><span class="line">https://play.golang.org, 205ns, 5767 bytes</span><br><span class="line">http://gopl.io, 326ns, 2856 bytes</span><br><span class="line">--- PASS: Test (1.21s)</span><br><span class="line">PASS</span><br><span class="line">ok  gopl.io/ch9/memo1   1.257s</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个测试是顺序地去做所有的调用的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于这种彼此独立的 HTTP 请求可以很好地并发，我们可以把这个测试改成并发形式。可以使用 sync.WaitGroup 来等待所有的请求都完成之后再返回。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m := memo.New(httpGetBody)</span><br><span class="line"><span class="keyword">var</span> n sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> url := <span class="keyword">range</span> incomingURLs() &#123;</span><br><span class="line">  n.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    value, err := m.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s, %s, %d bytes\n&quot;</span>,</span><br><span class="line">    url, time.Since(start), <span class="built_in">len</span>(value.([]<span class="keyword">byte</span>)))</span><br><span class="line">    n.Done()</span><br><span class="line">  &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line">n.Wait()</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这次测试跑起来更快了，然而不幸的是貌似这个测试不是每次都能够正常工作。我们注意到有一些意料之外的 cache miss（缓存未命中），或者命中了缓存但却返回了错误的值，或者甚至会直接崩溃。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;但更糟糕的是，有时候这个程序还是能正确的运行（译：也就是最让人崩溃的偶发 bug），所以我们甚至可能都不会意识到这个程序有 bug。但是我们可以使用 -race 这个 flag 来运行程序，竞争检测器（第 6 小节）会打印像下面这样的报告：

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run=TestConcurrent -race -v gopl.io/ch9/memo1</span><br><span class="line">=== RUN   TestConcurrent</span><br><span class="line">...</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write by goroutine 36:</span><br><span class="line">  runtime.mapassign1()</span><br><span class="line">      ~/go/src/runtime/hashmap.go:411 +0x0</span><br><span class="line">  gopl.io/ch9/memo1.(*Memo).Get()</span><br><span class="line">      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205</span><br><span class="line">  ...</span><br><span class="line">Previous write by goroutine 35:</span><br><span class="line">  runtime.mapassign1()</span><br><span class="line">      ~/go/src/runtime/hashmap.go:411 +0x0</span><br><span class="line">  gopl.io/ch9/memo1.(*Memo).Get()</span><br><span class="line">      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205</span><br><span class="line">...</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">FAIL    gopl.io/ch9/memo1   2.393s</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;memo.go 的 32 行出现了两次，说明有两个 goroutine 在没有同步干预的情况下更新了 cache map。这表明 Get 不是并发安全的，存在数据竞争。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28</span>  <span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="number">29</span>      res, ok := memo.cache(key)</span><br><span class="line"><span class="number">30</span>      <span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="number">31</span>          res.value, res.err = memo.f(key)</span><br><span class="line"><span class="number">32</span>          memo.cache[key] = res</span><br><span class="line"><span class="number">33</span>      &#125;</span><br><span class="line"><span class="number">34</span>      <span class="keyword">return</span> res.value, res.err</span><br><span class="line"><span class="number">35</span>  &#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;最简单的使 cache 并发安全的方式是使用基于监控的同步。只要给 Memo 加上一个 mutex，在 Get 的一开始获取互斥锁，return 的时候释放锁，就可以让 cache 的操作发生在临界区内了：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">  f     Func</span><br><span class="line">  mu    sync.Mutex <span class="comment">// guards cache</span></span><br><span class="line">  cache <span class="keyword">map</span>[<span class="keyword">string</span>]result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get is concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  memo.mu.Lock()</span><br><span class="line">  res, ok := memo.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    res.value, res.err = memo.f(key)</span><br><span class="line">    memo.cache[key] = res</span><br><span class="line">  &#125;</span><br><span class="line">  memo.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;测试依然并发进行，但这回竞争检查器“沉默”了。不幸的是对于 Memo 的这一点改变使我们完全丧失了并发的性能优点。每次对 f 的调用期间都会持有锁，Get 将本来可以并行运行的 I/O 操作串行化了。我们本章的目的是完成一个无锁缓存，而不是现在这样的将所有请求串行化的函数的缓存。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下一个 Get 的实现，调用 Get 的 goroutine 会两次获取锁：查找阶段获取一次，如果查找没有返回任何内容，那么进入更新阶段会再次获取。在这两次获取锁的中间阶段，其它 goroutine 可以随意使用 cache。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  memo.mu.Lock()</span><br><span class="line">  res, ok := memo.cache[key]</span><br><span class="line">  memo.mu.Unlock()</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    res.value, res.err = memo.f(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Between the two critical sections, several goroutines</span></span><br><span class="line">    <span class="comment">// may race to compute f(key) and update the map.</span></span><br><span class="line">    memo.mu.Lock()</span><br><span class="line">    memo.cache[key] = res</span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这些修改使性能再次得到了提升，但有一些 URL 被获取了两次。这种情况在两个以上的 goroutine 同一时刻调用 Get 来请求同样的URL时会发生。多个 goroutine 一起查询 cache，发现没有值，然后一起调用 f 这个慢不拉叽的函数。在得到结果后，也都会去更新 map。其中一个获得的结果会覆盖掉另一个的结果。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;理想情况下是应该避免掉多余的工作的。而这种“避免”工作一般被称为 duplicate suppression（重复抑制/避免）。下面版本的 Memo 每一个 map 元素都是指向一个条目的指针。每一个条目包含对函数 f 调用结果的内容缓存。与之前不同的是这次 entry 还包含了一个叫 ready 的 channel。在条目的结果被设置之后，这个 channel 就会被关闭，以向其它 goroutine 广播（第 7 章）去读取该条目内的结果是安全的了。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">  res   result</span><br><span class="line">  ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when res is ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span> *<span class="title">Memo</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*entry)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">  f     Func</span><br><span class="line">  mu    sync.Mutex <span class="comment">// guards cache</span></span><br><span class="line">  cache <span class="keyword">map</span>[<span class="keyword">string</span>]*entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  memo.mu.Lock()</span><br><span class="line">  e := memo.cache[key]</span><br><span class="line">  <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// This is the first request for this key.</span></span><br><span class="line">    <span class="comment">// This goroutine becomes responsible for computing</span></span><br><span class="line">    <span class="comment">// the value and broadcasting the ready condition.</span></span><br><span class="line">    e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">    memo.cache[key] = e</span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    e.res.value, e.res.err = memo.f(key)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(e.ready) <span class="comment">// broadcast ready condition</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// This is a repeat request for this key.</span></span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    &lt;-e.ready <span class="comment">// wait for ready condition</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e.res.value, e.res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在 Get 函数包括下面这些步骤了：获取互斥锁来保护共享变量 cache map，查询 map 中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成（也就是有其它的 goroutine 在调用 f 这个慢函数）时，goroutine 必须等待值 ready 之后才能读到条目的结果。而想知道是否 ready 的话，可以直接从 ready channel 中读取，由于这个读取操作在 channel 关闭之前一直是阻塞。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果没有条目的话，需要向 map 中插入一个没有准备好的条目，当前正在调用的 goroutine 就需要负责调用慢函数、更新条目以及向其它所有 goroutine 广播条目已经 ready 可读的消息了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;条目中的 e.res.value 和 e.res.err 变量是在多个 goroutine 之间共享的。创建条目的 goroutine 同时也会设置条目的值，其它 goroutine 在收到 "ready" 的广播消息之后立刻会去读取条目的值。尽管会被多个 goroutine 同时访问，但却并不需要互斥锁。ready channel 的关闭一定会发生在其它 goroutine 接收到广播事件之前，因此第一个 goroutine 对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这样并发、不重复、无阻塞的 cache 就完成了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面这样 Memo 的实现使用了一个互斥量来保护多个 goroutine 调用 Get 时的共享 map 变量。不妨把这种设计和前面提到的把 map 变量限制在一个单独的 monitor goroutine 的方案做一些对比，后者在调用 Get 时需要发消息。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Func、result 和 entry 的声明和之前保持一致：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Func is the type of the function to memoize.</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A result is the result of calling a Func.</span></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">  res   result</span><br><span class="line">  ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when res is ready</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;然而 Memo 类型现在包含了一个叫做 requests 的 channel，Get 的调用方用这个 channel 来和 monitor goroutine 来通信。requests channel 中的元素类型是 request。Get 的调用方会把这个结构中的两组 key 都填充好，实际上用这两个变量来对函数进行缓存的。另一个叫 response 的 channel 会被拿来发送响应结果。这个 channel 只会传回一个单独的值。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A request is a message requesting that the Func be applied to key.</span></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">  key      <span class="keyword">string</span></span><br><span class="line">  response <span class="keyword">chan</span>&lt;- result <span class="comment">// the client wants a single result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span>&#123; requests <span class="keyword">chan</span> request &#125;</span><br><span class="line"><span class="comment">// New returns a memoization of f.  Clients must subsequently call Close.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span> *<span class="title">Memo</span></span> &#123;</span><br><span class="line">  memo := &amp;Memo&#123;requests: <span class="built_in">make</span>(<span class="keyword">chan</span> request)&#125;</span><br><span class="line">  <span class="keyword">go</span> memo.server(f)</span><br><span class="line">  <span class="keyword">return</span> memo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">  response := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">  memo.requests &lt;- request&#123;key, response&#125;</span><br><span class="line">  res := &lt;-response</span><br><span class="line">  <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Close</span><span class="params">()</span></span> &#123; <span class="built_in">close</span>(memo.requests) &#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的 Get 方法，会创建一个 response channel，把它放进 request 结构中，然后发送给 monitor goroutine，然后马上又会接收它。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;cache 变量被限制在了 monitor goroutine 中，下面会看到。monitor 会在循环中一直读取请求，直到 request channel 被 Close 方法关闭。每一个请求都会去查询 cache，如果没有找到条目的话，那么就会创建/插入一个新的条目。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">server</span><span class="params">(f Func)</span></span> &#123;</span><br><span class="line">  cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*entry)</span><br><span class="line">  <span class="keyword">for</span> req := <span class="keyword">range</span> memo.requests &#123;</span><br><span class="line">    e := cache[req.key]</span><br><span class="line">    <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// This is the first request for this key.</span></span><br><span class="line">      e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">      cache[req.key] = e</span><br><span class="line">      <span class="keyword">go</span> e.call(f, req.key) <span class="comment">// call f(key)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> e.deliver(req.response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">call</span><span class="params">(f Func, key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Evaluate the function.</span></span><br><span class="line">  e.res.value, e.res.err = f(key)</span><br><span class="line">  <span class="comment">// Broadcast the ready condition.</span></span><br><span class="line">  <span class="built_in">close</span>(e.ready)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">deliver</span><span class="params">(response <span class="keyword">chan</span>&lt;- result)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Wait for the ready condition.</span></span><br><span class="line">  &lt;-e.ready</span><br><span class="line">  <span class="comment">// Send the result to the client.</span></span><br><span class="line">  response &lt;- e.res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;和基于互斥量的版本类似，第一个对某个 key 的请求需要负责去调用函数 f 并传入这个 key，将结果存在条目里，并关闭 ready channel 来广播条目的 ready 消息。使用 (*entry).call 来完成上述工作。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;紧接着对同一个 key 的请求会发现 map 中已经有了存在的条目，然后会等待结果变为 ready，并将结果从 response 发送给客户端的 goroutinue。上述工作是用 (*entry).deliver 来完成的。对 call 和 deliver 方法的调用必须让它们在自己的 goroutine 中进行以确保 monitor goroutines 不会因此而被阻塞住而没法处理新的请求。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个例子说明我们无论用上锁，还是通信来建立并发程序都是可行的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上面的两种方案并不好说特定情境下哪种更好，不过了解他们还是有价值的。有时候从一种方式切换到另一种可以使你的代码更为简洁。（译注：不是说好的 golang 推崇通信并发么。）
</div>

<h2><a name="8_goroutinues_and_thread">8. Goroutines 和线程</a></h2>
<div class="div_learning_post_boder">

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在上一章中我们说 goroutine 和操作系统的线程区别可以先忽略。尽管两者的区别实际上只是一个量的区别，但量变会引起质变的道理同样适用于 goroutine 和线程。现在正是我们来区分开两者的最佳时机。

  <h3><a name="8_goroutinues_and_thread_1">8.1 动态栈</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;每一个 OS 线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。这个固定大小的栈同时很大又很小。因为 2MB 的栈对于一个小小的 goroutine 来说是很大的内存浪费，比如对于我们用到的，一个只是用来 WaitGroup 之后关闭 channel 的 goroutine 来说。而对于 go 程序来说，同时创建成百上千个 goroutine 是非常普遍的，如果每一个 goroutine 都需要这么大的栈的话，那这么多的 goroutine 就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;相反，一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。

  <h3><a name="8_goroutinues_and_thread_2">8.2 Goroutine 调度</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;OS 线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作 scheduler 的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的 cpu 周期。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Go 的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如 m:n 调度，因为其会在 n 个操作系统线程上多工（调度）m 个goroutine。Go 调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的 Go 程序中的 goroutine（译注：按程序独立）。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;和操作系统的线程调度不同的是，Go 调度器并不是用一个硬件定时器，而是被 Go 语言“建筑”本身进行调度的。例如当一个 goroutine 调用了 time.Sleep，或者被 channel 调用或者 mutex 操作阻塞时，调度器会使其进入休眠并开始执行另一个 goroutine，直到时机到了再去唤醒第一个 goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个 goroutine 比调度一个线程代价要低得多。

  <h3><a name="8_goroutinues_and_thread_3">8.3 GOMAXPROCS</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Go 的调度器使用了一个叫做 <b>GOMAXPROCS</b> 的变量来决定会有多少个操作系统的线程同时执行 Go的代码。其默认的值是运行机器上的 CPU 的核心数，所以在一个有 8 个核心的机器上时，调度器一次会在 8 个 OS 线程上去调度 GO 代码。（GOMAXPROCS 是前面说的 m:n 调度中的 n）。在休眠中的或者在通信中被阻塞的 goroutine 是不需要一个对应的线程来做调度的。在 I/O 中或系统调用中或调用非 Go 语言函数时，是需要一个对应的操作系统线程的，但是 GOMAXPROCS 并不需要将这几种情况计算在内。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;你可以用 GOMAXPROCS 的环境变量来显式地控制这个参数，或者也可以在运行时用 runtime.GOMAXPROCS 函数来修改它。我们在下面的小程序中会看到 GOMAXPROCS 的效果，这个程序会无限打印 0 和 1。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">go</span> fmt.Print(<span class="number">0</span>)</span><br><span class="line">  fmt.Print(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOMAXPROCS=<span class="number">1</span> <span class="keyword">go</span> run hacker-cliché.<span class="keyword">go</span></span><br><span class="line"><span class="number">111111111111111111110000000000000000000011111.</span>..</span><br><span class="line"></span><br><span class="line">$ GOMAXPROCS=<span class="number">2</span> <span class="keyword">go</span> run hacker-cliché.<span class="keyword">go</span></span><br><span class="line"><span class="number">010101010101010101011001100101011010010100110.</span>..</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在第一次执行时，最多同时只能有一个 goroutine 被执行。初始情况下只有 main goroutine 被执行，所以会打印很多 1。过了一段时间后，GO 调度器会将其置为休眠，并唤醒另一个 goroutine，这时候就开始打印很多 0 了，在打印的时候，goroutine 是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个 goroutine 可以一起被执行，以同样的频率交替打印 0 和 1。我们必须强调的是 goroutine 的调度是受很多因子影响的，而 runtime 也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。

  <h3><a name="8_goroutinues_and_thread_4">8.4 Goroutine 没有 ID 号</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份（id），并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个 integer 或者指针值。这种情况下我们做一个抽象化的 thread-local storage（线程本地存储，多线程编程中不希望其它线程访问的内容）就很容易，只需要以线程的 id 作为 key 的一个 map 就可以解决问题，每一个线程以其 id 就能从中获取到值，且和其它线程互不冲突。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;goroutine 没有可以被程序员获取到的身份（id）的概念。这一点是设计上故意而为之，由于 thread-local storage 总是会被滥用。比如说，一个 web server 是用一种支持 tls 的语言实现的，而非常普遍的是很多函数会去寻找 HTTP 请求的信息，这代表它们就是去其存储层（这个存储层有可能是 tls）查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变 —— 比如一些 worker 线程之类的 —— 那么函数的行为就会变得神秘莫测。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Go鼓励更为简单的模式，这种模式下参数（译注：外部显式参数和内部显式参数。tls 中的内容算是"外部"隐式参数）对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;你现在应该已经明白了写一个 Go 程序所需要的所有语言特性信息。在后面两章节中，我们会回顾一些之前的实例和工具，支持我们写出更大规模的程序：如何将一个工程组织成一系列的包，如何获取，构建，测试，性能测试，剖析，写文档，并且将这些包分享出去。
</div>

<!--ref-->
<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>

<ol>
<li>github.com, <a target="_blank" rel="noopener" href="https://github.com/gopl-zh/gopl-zh.github.com/tree/master/ch9">Go语言圣经(中文版) Chapter 9</a></p>
</div>

</li>
</ol>
</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_Program/">TECH_PROGRAM</a></li>
          <li>GO_BASIC_8_GO_SHARED_VARIABLES</li>
        
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.weibo.com/u/2861056530" title="Weibo → https:&#x2F;&#x2F;www.weibo.com&#x2F;u&#x2F;2861056530" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HwangZobin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HwangZobin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021044371号 </a>
  </div>

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-guitar"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8LMT8RtOsi4JsbYHtNm2J7U-gzGzoHsz',
      appKey     : 'Q0cSe4rR8Iwr0Gs60rwWBsYa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
