<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zobinhuang.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"hide","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#FF4136","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="Golang 网络标准库">
<meta property="og:url" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:locale">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/xxx.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/net.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/stream.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/packet.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/listen.png">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/nethttp.svg">
<meta property="og:image" content="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/pic/net_http_invoke.svg">
<meta property="article:published_time" content="2022-02-10T14:39:11.482Z">
<meta property="article:modified_time" content="2021-09-07T12:09:22.000Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="http://www.zobinhuang.com:10082/sec_learning/Tech_Program/Go_Standard_Library_2_Net/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>Golang 网络标准库 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Loves Tech & Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-关于我">

    <a href="/sec_about/" rel="section"><i class="fa fa-address-card fa-fw"></i>关于我</a>

  </li>
        <li class="menu-item menu-item-知识库">

    <a href="/sec_learning/" rel="section"><i class="fa fa-book-open fa-fw"></i>知识库</a>

  </li>
        <li class="menu-item menu-item-进度">

    <a href="/sec_schedule/" rel="section"><i class="fa fa-calendar-alt fa-fw"></i>进度</a>

  </li>
        <li class="menu-item menu-item-独立音乐人">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>独立音乐人</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="cn">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Golang 网络标准库
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_Program/">TECH_PROGRAM</a></li>
          <li>GO_STANDARD_LIBRARY_2_NET</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_concurrent_img{padding: 10px 10px; display: flex; align-items:center; justify-content:center;}
    @media(max-width: 768px) {
      .div_concurrent_img{flex-direction: column;}
    }
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_boder{padding: 10px 10px; font-size: 16px; word-spacing:0px;  border:1px solid black;}
</style>

<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
<!--支持矩阵显示-->
<script type="text/javascript">
  run_maths = function() {
    if (document.querySelector('[class*="cmath"]') !== null) {
      if (typeof (mjax_path)=='undefined') { mjax_path='https://cdn.jsdelivr.net/npm/mathjax@2'; }
      if (typeof (mjax_config)=='undefined') { mjax_config='AM_CHTML'; }
      smjax = document.createElement ('script');
      smjax.setAttribute('src',`${mjax_path}/MathJax.js?config=${mjax_config}`);
      smjax.setAttribute('async',true);
      document.getElementsByTagName('head')[0].appendChild(smjax);
    }
  };
  if (document.readyState === 'loading') {  
    window.addEventListener('DOMContentLoaded', run_maths); 
  } else { 
    run_maths(); 
  }
</script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：Aug.6 2021</i></font></h4>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center" bgcolor="#FFFFFF">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--矩阵公式-->
<!--
<div class="cmath" align="center">
  `((1, 0),(1, 0))`
</div>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_intro"><font color="blue"><b>Golang 网络标准库</b></font></a>：介绍了 Golang 网络标准库 的概况，列出了各个 package 大概的功能。
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_net"><font color="blue"><b>package net</b></font></a>：介绍了 package net 的基本功能和使用方法；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#2_net_1"><font color="blue">回顾 Socket</font></a>：回顾了 Socket 的种类、作用域的内容；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#2_net_2"><font color="blue">package net 基本结构</font></a>：分析了 package net 的基本结构；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#2_net_3"><font color="blue">基于流的协议</font></a>：分析了基于流的协议的编程框架；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#2_net_4"><font color="blue">基于包的协议</font></a>：分析了基于包的协议的编程框架；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#2_net_5"><font color="blue">Dial 函数</font></a>：分析了用于在客户端创建连接使用的 Dial 函数；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#2_net_6"><font color="blue">Listen 函数</font></a>：分析了用于在服务端监听连接使用的 Listen 函数；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 3. <a href="#3_net_http"><font color="blue"><b>package net/http</b></font></a>：详细且清楚地分析了 package net/http.
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#3_net_http_1"><font color="blue">关键数据结构</font></a>：列举了 package net/http 中的关键数据结构；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#3_net_http_2"><font color="blue">HTTP 请求和响应</font></a>：分析了 HTTP 处理的基本数据结构：http.Request 和 http.ResponseWriter；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#3_net_http_3"><font color="blue">路由注册实现细节</font></a>：详细分析了 package net/http 是如何将 Handler 注册到 HTTP Server 中的，以及 HTTP Server 是如何实现重定向的功能的；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="#3_net_http_4"><font color="blue">HTTP 请求处理实现细节</font></a>：详细分析了 package net/http 是如何创建 HTTP Server 并且处理输入的 HTTP 请求的；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="#3_net_http_5"><font color="blue">实践：搭建 HTTP 服务器</font></a>：回到用户接口，作为总结，展示了创建 HTTP Server 的方法；
  </div>
</div>

<!--标题-->
<h2><a name="1_intro">1. Golang 网络标准库</a></h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Golang 在标准库中提供了对程序网络功能的很好的支持。与网络相关的包如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <th>包名</th>
      <th>功能</th>
    </tr>
    <tr>
      <td>net</td>
      <td>net 包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和 Unix 域 socket</td>
    </tr>
    <tr>
      <td>net/http</td>
      <td>net/http 包提供了 HTTP 客户端和服务端的实现</td>
    </tr>
    <tr>
      <td>net/mail</td>
      <td>net/mail 包实现了邮件的解析</td>
    </tr>
    <tr>
      <td>net/rpc</td>
      <td>rpc 包提供了通过网络或其他 I/O 连接对一个对象的导出方法的访问。服务端注册一个对象，使它作为一个服务被暴露，服务的名字是该对象的类型名。注册之后，对象的导出方法就可以被远程访问。</td>
    </tr>
    <tr>
      <td>net/smtp</td>
      <td>net/smtp 包实现了简单邮件传输协议（SMTP）</td>
    </tr>
    <tr>
      <td>net/textproto</td>
      <td>net/textproto 实现了对基于文本的请求/回复协议的一般性支持，包括 HTTP、NNTP 和 SMTP</td>
    </tr>
    <tr>
      <td>net/url</td>
      <td>net/url 包可以用于解析 URL 并实现了查询的逸码</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们会对重要的一些标准库网络 package 进行分析。
</div>

<h2><a name="2_net">2. package net</a></h2>
<div class="div_learning_post">
  <h3><a name="2_net_1">2.1 回顾 Socket</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;package net 提供了让程序访问底层网络原语的能力，能够让我们在 Golang 中实现 socket 的编程。在开始讲解如何在 Golang 中进行套接字编程之前，我们必须梳理一下套接字都有哪些类型。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;打破次元壁，我们来看一下 Linux 提供给我们的基于 C 的创建 socket 的接口是什么样的：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在<b>功能维度</b>上，通常也称为按 <font color="blue">域 (Domain)</font> 划分，对应于 socket 创建接口的第一个参数 domain，我们可以把套接字分为两种：<font color="blue">TCP/IP domain socket</font> 和 <font color="blue">UNIX domain socket</font>，前者用于主机间的网络通信，后者用于进程间通信。二者由于作用对象的不同，因此在数据传输的实现细节上也有所不同：前者的数据传输需要经过内核协议栈，而后者的数据传输仅需要在内核 buffer 中进行拷贝即可，但是它们呈现给用户态程序的接口是一样的，因此在编程框架上基本无区别。这里，当我们指定 domain=AF_INET / AF_INET6 / AF_PACKET 时，我们就是在 TCP/IP domain 下；当我们指定 domain=AF_UNIX 时，我们就是在 UNIX domain 下。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;顺便提一句，有时候我们还会看见以 "PF_" 为前缀的域，读者只需要简单的把 "PF_XXXX" 等价为 "AF_XXXX" 就可以了，这种区分是有历史原因的，但是实际上如今已经不需要区分，具体原因见于 <a target="_blank" rel="noopener" href="https://beej.us/guide/bgnet/html/#system-calls-or-bust">Beej's Guide to Network Programming</a>，下面摘取相关内容：

  <div class="div_learning_post_boder">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;In some documentation, you'll see mention of a mystical "PF_INET". This is a weird etherial beast that is rarely seen in nature, but I might as well clarify it a bit here. Once a long time ago, it was thought that maybe a address family (what the "AF" in "AF_INET" stands for) might support several protocols that were referenced by their protocol family (what the "PF" in "PF_INET" stands for) <font color="red">[很久以前，人们认为也许一个地址族可能支持其协议族引用的几种协议]</font>. That didn't happen. Oh well. So the correct thing to do is to use AF_INET in your struct sockaddr_in and PF_INET in your call to socket(). But practically speaking, you can use AF_INET everywhere. And, since that's what W. Richard Stevens does in his book, that's what I'll do here.
  </div><br>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在<b>数据传输维度</b>上，我们又可以把套接字分为三种：<font color="blue">面向流的 socket</font>，<font color="blue">面向数据报 (datagram) 的 socket</font> 和 <font color="blue">原始 (raw) socket</font>，对应于 socket 创建接口的第二个参数 type。<b>面向流的 socket</b> 提供了顶层的有序的、可靠的，面向连接的通信；<b>面向数据报 (datagram) 的 socket</b> 提供了顶层的无连接的，固定大小传输的、不可靠的通信。这两种类型的套接字在 TCP/IP domain socket 和 UNIX domain socket 上都被支持。而最后一种类型 —— 原始 (raw) socket 则仅在 TCP/IP domain socket 上被讨论才有意义，它允许我们获取传输层以下的网络数据。这里，当我们指定 type=SOCK_STREAM 时，我们就是在创建<b>面向流的 socket</b>；当我们指定 type=SOCK_DGRAM 时，我们就是在创建<b>面向数据报的 socket</b>；当我们指定 type=SOCK_RAW 时，我们就是在创建<b>原始 (raw) socket</b>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，当我们在创建<b>原始 (raw) socket</b>时，domain 字段似乎已经失去了意义。其实不然，当我们指定 domain=AF_INET 和 type=SOCK_RAW 时，我们创建的<b>原始 (raw) socket</b>可用于收发 IP 数据包 (网络层)；当我们指定 domain=AF_PACKET 和 type=SOCK_RAW 时，我们创建的<b>原始 (raw) socket</b>可用于收发<b><font color="red">包含</font></b>链路层协议头的以太网数据帧 (数据链路层)；当我们指定 domain=AF_PACKET 和 type=SOCK_DGRAM 时，我们创建的<b>原始 (raw) socket</b>可用于收发<b><font color="red">不包含</font></b>链路层协议头的以太网数据帧 (数据链路层)。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们使用下表进行总结：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <caption>UNIX & TCP/IP socket</caption>
    <tr>
      <th>Domain</th>
      <th>Type</th>
      <th>功能</th>
    </tr>
    <tr>
      <td>TCP/IP: AF_INET/AF_INET6</td>
      <td>SOCK_STREAM</td>
      <td>TCP socket</td>
    </tr>
    <tr>
      <td>TCP/IP: AF_INET/AF_INET6</td>
      <td>SOCK_DGRAM</td>
      <td>UDP socket</td>
    </tr>
    <tr>
      <td>TCP/IP: AF_INET/AF_INET6</td>
      <td>SOCK_RAW</td>
      <td>IP socket</td>
    </tr>
    <tr>
      <td>TCP/IP: AF_PACKET</td>
      <td>SOCK_RAW</td>
      <td>Eth socket (with eth header)</td>
    </tr>
    <tr>
      <td>TCP/IP: AF_PACKET</td>
      <td>SOCK_DGRAM</td>
      <td>Eth socket (without eth header)</td>
    </tr>
    <tr>
      <td>UNIX: AF_UNIX</td>
      <td>SOCK_STREAM</td>
      <td>UNIX stream socket</td>
    </tr>
    <tr>
      <td>UNIX: AF_UNIX</td>
      <td>SOCK_DGRAM</td>
      <td>UNIX datagram socket</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 socket 创建接口的第三个参数 protocol，这个适用于指定具体协议的。常见的用法如下：

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1: 发送接收 ip 数据包</span></span><br><span class="line">socket(PF_INET, SOCK_RAW, IPPROTO_TCP|IPPROTO_UDP|IPPROTO_ICMP); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2: 发送接收以太网数据帧</span></span><br><span class="line">socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 3: 发送接收以太网数据帧（不包括以太网头部)</span></span><br><span class="line">socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL));</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们来看一下一个数据包从被内核接收上来，到抵达用户态套接字缓冲区，期间发生了什么事情。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先,网卡对该数据帧进行硬过滤 (根据网卡的模式不同会有不同的动作，如果设置了 promisc 混杂模式的话,则不做任何过滤直接交给下一层输入例程，否则非本机 mac 或者广播 mac 会被直接丢弃)。如果成功的话，会进入 ip 输入例程，但是在进入 ip 输入例程之前，系统会检查系统中是否有通过 socket(AF_PACKET, SOCK_RAW/SOCK_DGRAM, ..) 创建的套接字，如果有的话并且协议相符 (即参数 protocol 相匹配)，系统就给每个这样的 socket 接收缓冲区发送一个数据帧拷贝，然后进入下一步。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;随后数据包就进入了 ip 输入例程 (ip 层会对该数据包进行软过滤，就是检查校验或者丢弃非本机 ip 或者广播 ip 的数据包等，具体要参考源代码)，如果成功的话会进入 TCP/UDP 输入例程.但是在交给 TCP/UDP 输入例程之前,系统会检查系统中是否有通过 socket(AF_INET, SOCK_RAW, ..) 创建的套接字，如果有的话并且协议相符，系统就给每个这样的 socket 接收缓冲区发送一个数据帧拷贝.然后就进入 我们熟悉的 TCP/UDP 输入例程。

  <h3><a name="2_net_2">2.2 package net 基本结构</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;回顾完 socket 的内容后，我希望读者朋友没有被绕晕。如果你已经晕了也别担心，Golang 标准库在 package net 中为我们屏蔽了这些繁琐的细节，提供了十分友好的编程接口，实现了对底层 socket 细节的屏蔽。

  <div align="center">
    <img src="./pic/net.png" width=700px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;上图所示是 package net 中的关系，灰色方框代表了结构体，黄色方框代表了接口，蓝色线代表了结构体对接口的实现。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在上图最下面的结构体中，我们可以发现所有我们在 <a href="#2_net_1">回顾 socket</a> 中描述到的 socket 类型，包括以下结构体：

  <ul>
    <li>对应 TCP socket 的 <font color="blue">TCPConn</font> 和 <font color="blue">TCPListener</font></li>
    <li>对应 UDP socket 的 <font color="blue">UDPConn</font></li>
    <li>对应 UNIX stream socket 的 <font color="blue">UnixConn</font> 以及 <font color="blue">UnixListener</font></li>
    <li>对应 UNIX datagram socket 的 <font color="blue">UnixConn</font></font></li>
    <li>对应 IP Raw socket 的 <font color="blue">IPConn</font></li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当我们在进行网络编程的时候，实际上操作的就是上面的结构体。比如，我们在服务端会使用 net.Listen() 来新建一个 Listener，我们在客户端会使用 net.Dial() 来获取一个 Conn，实际上这些函数就是在操作上面的这些结构体，再往底层走就是在操作 socket。net 包已经给我们提供了很好的封装，因此我们一般不会直接与结构体进行交互。下面我们就来理清楚这些封装函数的结构以及它们所提供的功能。在看这些函数之前，我们首先再回忆一下 socket 编程的一些流程框架。

  <h3><a name="2_net_3">2.3 基于流的协议</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;基于流的协议，net 包中支持了常见的 TCP，Unix（Stream 方式）两种。基于流的协议需要先于对端建立链接，然后再发送消息。下面是基于流的编程的流程：

  <div align="center">
    <img src="./pic/stream.png" width=300px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，服务端需要绑定并监听端口，然后等待客户端与其建立链接，通过 Accept 接收到客户端的连接后，开始读写消息。最后，当服务端收到 EOF 标识后，关闭链接即可。 HTTP, SMTP 等应用层协议都是使用的 TCP 传输层协议。

  <h3><a name="2_net_4">2.4 基于包的协议</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;基于包的协议，net 包中支持了常见的 UDP，Unix（DGRAM 包方式，PacketConn 方式），IP (网络层协议，支持了icmp, igmp) 几种。基于包的协议在 bind 端口后，无需建立连接，是一种即发即收的模式。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;基于包的协议，有例如基于 UDP 的 DNS解析， 文件传输（TFTP协议）等协议。 下面是基于包请求的 Server 端和 Client 端：

  <div align="center">
    <img src="./pic/packet.png" width=300px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到，在 Socket 编程里， 基于包的协议是不需要 Listen 和 Accept 的。在 net 包中，使用 ListenPacket，实际上仅是构造了一个UDP Socket，做了端口绑定而已。端口绑定后，Server 端开始阻塞读取包数据，之后二者开始通信。由于基于包协议，因此，我们也可以采用 PacketConn 接口（看第一个实现接口的图）构造UDP包。

  <h3><a name="2_net_5">2.5 Dial 函数</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Golang 中，Dial 用于在客户端创建 socket 和一些相关的初始化操作，可以参考上面 <a name="2_net_3">2.3 基于流的协议</a>。Golang 大致提供了 5 种 dial，包括：

  <ul>
    <li><font color="blue">Dial</font>(network, address string) (Conn, error)</li>
    <li><font color="blue">DialTCP</font>(network string, laddr, raddr *TCPAddr) (*TCPConn, error)</li>
    <li><font color="blue">DialUDP</font>(network string, laddr, raddr *UDPAddr) (*UDPConn, error)</li>
    <li><font color="blue">DialIP</font>(network string, laddr, raddr *IPAddr) (*IPConn, error)</li>
    <li><font color="blue">DialUnix</font>(network string, laddr, raddr *UnixAddr) (*UnixConn, error)</li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;其中 Dial 是对其他几个的封装，输入参数 network 用于指定要创建的套接字所在的网络的类型，可以是如下类型：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td>tcp</td>
      <td>tcp4</td>
      <td>tcp6</td>
      <td>udp</td>
      <td>udp4</td>
      <td>udp6</td>
      <td>ip</td>
      <td>ip4(IPv4-only)</td>
      <td>ip6(IPv6-only)</td>
      <td>unix</td>
      <td>unixgram</td>
      <td>unixpacket</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们使用 Dial 和 TCPDial 为例来看它们的使用方法。首先是 Dial：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建连接</span></span><br><span class="line">conn,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;192.168.1.254:4001&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">conn.Write([]<span class="keyword">byte</span>&#123;<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0A</span>&#125;)</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//读取返回数据</span></span><br><span class="line">result,err := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result,buffer)</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，我们使用 net.Dial("tcp","192.168.1.254:4001") 返回的是一个 DialTCP 结构体，也就是说 net.Dial 会根据我们输入的 network 类型来返回相应的结构。其次，我们注意到收发数据使用的是 Write 和 Read 函数，也就是说 TCPConn 等结构体实际上实现了 io.Reader 和 io.Writer 接口，我们可以使用它们实现的 Read 和 Write 函数来获取数据，也可以使用 bufio.Reader 和 bufio.Writer 来创建带有缓存的 io 结构来读取数据。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们来看 DialTCP:

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//进行地址化转换</span></span><br><span class="line">tcpAddr,err:=net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;192.168.1.254:4001&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个连接</span></span><br><span class="line">conn,err:=net.DialTCP(<span class="string">&quot;tcp&quot;</span>,<span class="literal">nil</span>,tcpAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">str := []<span class="keyword">byte</span>&#123;<span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">85</span>, <span class="number">35</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">7</span>, <span class="number">226</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">15</span>, <span class="number">45</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向连接端发送一个数据</span></span><br><span class="line">_,err=conn.Write(str)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取连接端返回来的数据，</span></span><br><span class="line">result,err:=ioutil.ReadAll(conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(result))</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以发现，在使用 DialTCP 的时候，需要使用 net.ResolveTCPAddr 来获得用于描述 TCP 地址的 TCPAddr 结构。其实在 Dial 中，连接会根据你填入的连接类型，自动把地址转换为对应类型地址。 

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;另外，在 Dial 的例子中，我们是把 buffer 填充完后就直接执行后面的代码了，但是 buffer 的你需要事先定义大小。在 TCPDial 的例子中， ioutil.ReadAll() 要是拿不到结束符，会一直等到连接超时才执行后面代码。这样就会导致阻塞很长时间。

  <h3><a name="2_net_6">2.6 Listen 函数</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;看完了 Dial 函数，我们现在来看一下 Listen 函数。Listen 函数用于在服务端创建监听方法，在 golang 中监听方法大致有：

  <ul>
    <li>net.Listen()</li>
    <li>net.ListenPacket()</li>
    <li>net.ListenTcp()</li>
    <li>net.ListenUdp()</li>
    <li>net.ListenUnix()</li>
    <li>net.ListenIp()</li>
    <li>net.ListenUnixgram()</li>
    <li>net.ListenMulticastUDP()</li>
    <li>http.ListenAndServe()</li>
    <li>http.ListenAndServeTLS()</li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;它们的关系如下图所示：

  <div align="center">
    <img src="./pic/listen.png" width=600px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;http 有关的函数在 package net/http 中被提供。由上图可以看出，http 的监听是对 net.Listen() 的封装，而 net.Listen() 是对 TCP 和 Unix 的封装。而 http 的监听在调用 net.Listen() 传入的都是 tcp。即 http 的监听最终都是实现的 net.ListenTcp()。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当我们调用 net.DialTCP() 时，实际上 net 包内部会去调用 doDialTCP()；当我们调用 net.ListenTCP() 时，实际上 net 包内部会去调用 listenTCP()。下面我们对比一下这两个内部函数：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span> <span class="title">listenTCP</span><span class="params">(ctx context.Context, laddr *TCPAddr)</span> <span class="params">(*TCPListener, error)</span></span> &#123;</span><br><span class="line">  fd, err := internetSocket(ctx, sl.network, laddr, <span class="literal">nil</span>, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">&quot;listen&quot;</span>, sl.ListenConfig.Control)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;TCPListener&#123;fd&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span> <span class="title">doDialTCP</span><span class="params">(ctx context.Context, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line">  fd, err := internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">&quot;dial&quot;</span>, sd.Dialer.Control)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fd.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    fd, err = internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">&quot;dial&quot;</span>, sd.Dialer.Control)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTCPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;实际上它们都调用了 internetSocket()，传入的倒数第二个参数指示了创建的 socket 是客户端的还是服务器的。在服务端创建完 socket 之后，会直接使用 socket 的文件句柄创建一个 TCPListener 结构；而在客户端创建玩 socket 之后，会调用 newTCPConn(td) 使用文件句柄来实例化一个 TCPConn 结构。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;同样地，当我们调用 net.DialUDP() 时，实际上 net 包内部会去调用 doDialUDP()；当我们调用 net.ListenUDP() 时，实际上 net 包内部会去调用 listenUDP()。下面我们对比一下这两个内部函数：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span> <span class="title">listenUDP</span><span class="params">(ctx context.Context, laddr *UDPAddr)</span> <span class="params">(*UDPConn, error)</span></span> &#123;</span><br><span class="line">  fd, err := internetSocket(ctx, sl.network, laddr, <span class="literal">nil</span>, syscall.SOCK_DGRAM, <span class="number">0</span>, <span class="string">&quot;listen&quot;</span>, sl.ListenConfig.Control)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newUDPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span> <span class="title">dialUDP</span><span class="params">(ctx context.Context, laddr, raddr *UDPAddr)</span> <span class="params">(*UDPConn, error)</span></span> &#123;</span><br><span class="line">  fd, err := internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_DGRAM, <span class="number">0</span>, <span class="string">&quot;dial&quot;</span>, sd.Dialer.Control)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newUDPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们会发现，相比于 TCP，UDP 在服务器和客户端两边的 socket 创建和结构体初始化逻辑是完全一样的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面的这段代码展示了基本的 TCP Server 的初始化流程：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独处理客户端的请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clientHandle</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close();</span><br><span class="line"></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello &quot;</span> + time.Now().String()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个TCP服务端</span></span><br><span class="line">    tcpaddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>);</span><br><span class="line">    chkError(err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听端口</span></span><br><span class="line">    tcplisten, err2 := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tcpaddr);</span><br><span class="line">    chkError(err2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环的处理客户端请求</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//等待客户的连接</span></span><br><span class="line">        conn, err3 := tcplisten.Accept();</span><br><span class="line">        <span class="comment">//如果有错误直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过goroutine来处理用户的请求</span></span><br><span class="line">        <span class="keyword">go</span> clientHandle(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面的这段代码展示了基本的 HTTP Server 的初始化流程：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通 HTTP Server</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, HelloServer)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS HTTP Server</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">http.ListenAndServeTLS(<span class="string">&quot;:8081&quot;</span>, <span class="string">&quot;server.crt&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;server.key&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在 <a href="#3_net_http">package net/http</a> 中将看到和 HTTP 服务器有关的实现细节。
</div>

<h2><a name="3_net_http">3. package net/http</a></h2>
<div class="div_learning_post">
  <h3><a name="3_net_http_1">3.1 关键数据结构</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Golang 中，通过 net/http 标准库， 我们可以快速实现一个 HTTP 服务器，然后让这个服务器接受请求并返回响应。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;packge net/http 中关键的类型如下所示：

  <div align="center">
    <img src="./pic/nethttp.svg" width=100%>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在后面的几个小节中，我们将看到这些类型的大部分细节。这张图片作为地图使用，读者被绕晕的时候可以回来寻找所处的位置。

  <h3><a name="3_net_http_2">3.2 HTTP 请求和响应</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先我们来理清楚与 HTTP 请求和响应处理相关的结构/类型：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">  Method <span class="keyword">string</span> <span class="comment">// HTTP 方法 (GET, POST, PUT, etc.)</span></span><br><span class="line"></span><br><span class="line">  URL *url.URL <span class="comment">// HTTP 请求中的 URL</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 版本</span></span><br><span class="line">  Proto      <span class="keyword">string</span> <span class="comment">// &quot;HTTP/1.0&quot;</span></span><br><span class="line">  ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">  ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于描述 HTTP Request Header，是一个 map[string][]string 的结构</span></span><br><span class="line">  <span class="comment">// Header = map[string][]string&#123;</span></span><br><span class="line">  <span class="comment">//		&quot;Accept-Encoding&quot;: &#123;&quot;gzip, deflate&quot;&#125;,</span></span><br><span class="line">  <span class="comment">//		&quot;Accept-Language&quot;: &#123;&quot;en-us&quot;&#125;,</span></span><br><span class="line">  <span class="comment">//		&quot;Foo&quot;: &#123;&quot;Bar&quot;, &quot;two&quot;&#125;,</span></span><br><span class="line">  <span class="comment">//	&#125;</span></span><br><span class="line">  Header Header</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于描述 HTTP Request body</span></span><br><span class="line">  Body io.ReadCloser</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于获取 HTTP Request body 的一份拷贝</span></span><br><span class="line">  GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于获取 HTTP Request body 的长度</span></span><br><span class="line">  ContentLength <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">  TransferEncoding []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于指示在回复完该 HTTP Request 后是否关闭 TCP 连接</span></span><br><span class="line">  Close <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP Reqeust Header 中的 Host 字段</span></span><br><span class="line">  Host <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录发送 HTTP Request 的主机地址，通常用于记录日志</span></span><br><span class="line">  RemoteAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// RFC 规定的 HTTP Header 中的一个字段</span></span><br><span class="line">  RequestURI <span class="keyword">string</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Response 用于重定向时使用</span></span><br><span class="line">  Response *Response</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  ctx context.Context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第一个是 <font color="blue">http.Request</font>，它是一个结构体，如上所示。可以看到它用于描述服务器收到的 HTTP Request，具体字段的含义已经在上面的注释中给出，这里不再赘述。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Header() Header</span><br><span class="line"></span><br><span class="line">  Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line"> </span><br><span class="line">  WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;然后是 <font color="blue">ResponseWriter</font>，它是一个接口，用于 HTTP 服务端构建 HTTP Response 使用。<font color="blue">Header</font> 用于返回当前正在处理的 Reponse 的头部。Reponse 头部和上面看到的 Request 头部的格式是一样的，都是一个 map[string][]string 的结构；<font color="blue">WriteHeader</font> 用于向 HTTP Response Header 中添加 HTTP 状态码；<font color="blue">Write</font> 用于向 HTTP Response 中添加正文内容。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;以上这两种类型分别对应 HTTP 服务器的输入和输出的形态，是整个 HTTP 处理流程的基础。基于它们，我们下面可以开始来看 Golang 标准库是如何处理 HTTP 请求的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们首先展示整个调用堆栈，如下图所示，我们在后续的所有描述都围绕这张图展开：

  <div align="center">
    <img src="./pic/net_http_invoke.svg" width=100%>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;再次说明，这张图片作为地图使用，读者被绕晕的时候可以回来寻找所处的位置。

  <h3><a name="3_net_http_3">3.3 路由注册实现细节</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在本文中将讲解调用堆栈图中背景为黄色的部分。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里我们来看我们是如何实现 HTTP 路由注册的。所谓路由注册就是 <font color="red">将 URL 和相应的处理程序绑定起来</font>。下面我们首先来看 Golang 中对于这里的 "处理程序" 的定义。

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">  ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;来看 <font color="blue">Handler</font>，它是一个接口，我们最终在实现某个 API 上的业务逻辑的时候，所编写的函数就需要去满足这个接口，即实现 <font color="blue">ServeHTTP(ResponseWriter, *Request)</font> 函数，其中，正如我们在上面描述过的，参数 ResponseWriter 是一个接口，表示服务端的输出，Request 表示来自客户端的请求。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 package net/http 中，有一个名为 <font color="blue">ServeMux</font> 的结构体，它实现了 Handler 接口，也就是说 <font color="blue">ServeMux</font> 实现了 <font color="blue">ServeHTTP(ResponseWriter, *Request)</font> 函数。<font color="blue">ServeMux</font> 是一个特殊的 "处理程序"，它的功能是可以根据 URL 来判断应该把请求转发到哪个 Handler，这里的 Handler 也是 http.Handler，而 <font color="blue">ServeMux</font> 本身也是 http.Handler。也就是说 Golang 使用 http.Handler 来管理 http.Handler，这是一个非常优雅的设计。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面是 <font color="blue">ServeMux.ServeHTTP(ResponseWriter, *Request)</font> 的源代码：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> r.RequestURI == <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">      w.Header().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    w.WriteHeader(StatusBadRequest)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  h, _ := mux.Handler(r)</span><br><span class="line">  h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到，在 <font color="blue">ServeMux.ServeHTTP</font> 中实际上是调用了 <font color="blue">ServeMux.Handler</font> 来进行重定向，<font color="blue">ServeMux.Handler</font> 的函数签名如下：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;它实现的内部逻辑是去 ServeMux 结构体的成员 <font color="blue">m</font> 中寻找有没有对应 pattern 的 Handler，有的话就返回相应的 Handler，没有的话返回一个回送 404 error 的 Handler。这里提到的 ServeMux 结构体的成员 <font color="blue">m</font> 是一个 <font color="blue">map[string]muxEntry</font>，用于存储 Handler 和 pattern 的映射关系。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;以上就是 ServeMux 结构提供的重定向功能的内部细节。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;那么，Handler 是如何被注册到 ServeMux 结构体中去的呢？在 package net/http 中实际上初始化了一个 ServeMux 的实例 <font color="blue">defaultServeMux</font>，并以 <font color="blue">DefaultServeMux</font> 的名称将其导出。我们在创建 HTTP Server 的时候，会调用 package net/http 提供的方法 <font color="blue">http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</font> 来注册 Handler，实际上 http.HandleFunc 内部调用的是 <font color="blue">DefaultServeMux.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</font>。由于 <font color="blue">http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</font> 接收的是一个匿名函数，它会在内部将其转化为 "实现了 Handle 接口的函数对象"，然后再调用 <font color="blue">DefaultServeMux.Handle(pattern string, handler Handler)</font> 方法来将 Handler 注册到我们上文讲过的 ServeMux 结构体的成员 m 中。具体代码如下所示：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">  DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;okay，现在我们有了一个 ServerMux 的实例 DefaultServeMux，它下面的 ServeMux.ServeHTTP(ResponseWriter, *Request) 函数可以用来帮助我们重定向 HTTP 请求。那么 HTTP 请求是怎么被引导到这个 Handler 去的呢？下面我们来看看 HTTP Server 是如何被创建并且处理 HTTP 请求的。

  <h3><a name="3_net_http_4">3.4 HTTP 请求处理实现细节</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在本文中将讲解调用堆栈图中背景为灰色的部分。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;为了创建一个 HTTP Server，我们需要调用 <font color="blue">http.ListenAndServe(addr string, handler Handler)</font> 函数，函数定义如下：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">  <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这个函数会创建一个 <font color="blue">http.Server</font> 结构体，它可以用于描述我们创建的 HTTP Server 的基本信息，其定义如下：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 用于指示 HTTP Server 所使用的 TCP 地址，默认为 &quot;:http&quot; (port 80)</span></span><br><span class="line">  Addr <span class="keyword">string</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相应 HTTP 请求的 handler，默认为 http.DefaultServeMux</span></span><br><span class="line">  Handler Handler </span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意到，当我们在创建 http.Server 的时候，如果没有指定 http.Server.Handler 成员的值的话，那么默认将为 http.DefaultServeMux，这一点我们在后面将会看到具体的实现方式。因此，我们基本不会去手动设置 http.Server.Handler 的值，因为我们想创建一个具有多路复用功能的 HTTP Server。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;回到 <font color="blue">http.ListenAndServe(addr string, handler Handler)</font> 函数，我们注意到它调用了刚创建好的 <font color="blue">http.Server</font> 结构体 的 <font color="blue">server.ListenAndServe()</font> 函数，我们来看它的定义：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">    <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">  &#125;</span><br><span class="line">  addr := srv.Addr</span><br><span class="line">  <span class="keyword">if</span> addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    addr = <span class="string">&quot;:http&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到，在 <font color="blue">server.ListenAndServe()</font> 中，我们创建了一个 TCP 服务端的 socket 并且启动了监听。socket 创建和初始化完成之后，我们把 socket 对应的文件句柄 ln 传给了 <font color="blue">func (srv *Server) Serve(l net.Listener)</font> 函数，我们来看它的定义：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ... </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    rw, err := l.Accept()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    c := srv.newConn(rw)</span><br><span class="line">    c.setState(c.rwc, StateNew, runHooks) <span class="comment">// before Serve can return</span></span><br><span class="line">    <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;实际上这里面就是在实现 HTTP Server 的外层逻辑：接收请求，使用 <font color="blue">http.Server.newConn</font> 函数将 net.Conn 封装为 <font color="blue">http.conn</font>，然后创建处理请求的 goroutine。这里的 <font color="blue">http.conn</font> 是一个 package net/http 的内部结构体，实现了对 net.Conn 的包装，在承载 net.Conn 的基础上，增加了一些属性用于描述 HTTP 连接。我们可以看到上面代码的最后，goroutine 起的是  <font color="blue">http.conn</font> 下的方法 <font color="blue">http.conn.serve(ctx context.Context)</font>，它的定义大致如下：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    w, err := c.readRequest(ctx)</span><br><span class="line">    serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">    w.cancelCtx()</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看见它将我们的 <font color="blue">http.Server</font> 结构体封装为了 <font color="blue">http.serverHandler</font>，然后调用了 <font color="blue">http.serverHandler</font> 下的方法 <font color="blue">http.ServeHTTP(rw ResponseWriter, req *Request)</font> 进行对 HTTP 请求的处理。代码如下：


  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">  handler := sh.srv.Handler</span><br><span class="line">  <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">    handler = DefaultServeMux</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> req.RequestURI == <span class="string">&quot;*&quot;</span> &amp;&amp; req.Method == <span class="string">&quot;OPTIONS&quot;</span> &#123;</span><br><span class="line">    handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们看到它回去判断我们的 <font color="blue">http.Server</font> 结构体有没有绑定 Handler，如果没有的话，就指定 DefaultServeMux 为我们服务。如果有的话，就使用指定的 Handler。这与我们上面所描述的是一致的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这样一来，HTTP Server 处理 HTTP 请求的这条路我们也理清楚了。


  <h3><a name="3_net_http_5">3.5 实践：搭建 HTTP 服务器</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;讲了这么多底层的东西，当我们回过头来尝试去使用 Golang 标准库留给我们的用户接口的时候，一切就很简单了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们现在创建一个指定有 Handler 的 HTTP 服务器：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorldHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *WorldHandler)</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;World!n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  world := WorldHandler&#123;&#125;</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;: 8080&quot;</span>, &amp;world)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们现在对它发起 HTTP 请求。可以发现，不论我们的 URL 长什么样子，HTTP 都是 invoke 我们指定的那个 Handler：

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curlsdeMacBook-Pro:src curls$ curl localhost:8080</span><br><span class="line">World!</span><br><span class="line">curlsdeMacBook-Pro:src curls$ curl localhost:8080/hello</span><br><span class="line">World!</span><br><span class="line">curlsdeMacBook-Pro:src curls$ curl localhost:8080/welcom</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们使用多路复用器的形式：

  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">  fmt.Fprintf(writer, <span class="string">&quot;Hello, %s!n&quot;</span>, request.URL.Path[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorldHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *WorldHandler)</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">  fmt.Fprintf(w, <span class="string">&quot;World!n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">  world := &amp;WorldHandler&#123;&#125;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">  http.Handle(<span class="string">&quot;/world&quot;</span>, world)</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;: 8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意，我们这里使用了两种方法来注册路由：http.HandleFunc 和 http.Handle。回顾我们上文所讲的，http.HandleFunc 传入的是一个匿名函数，http.HandleFunc 内部会将其转化为 "实现了 Handle 接口的函数对象" 后，再调用 http.Handle。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们可以看到多路服用的效果如下所示：

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curlsdeMacBook-Pro:src curls$ curl localhost:8080/world</span><br><span class="line">World!</span><br><span class="line"></span><br><span class="line">curlsdeMacBook-Pro:src curls$ curl localhost:8080/welcome</span><br><span class="line">Hello, welcome!</span><br><span class="line"></span><br><span class="line">curlsdeMacBook-Pro:src curls$ curl localhost:8080/curls</span><br><span class="line">Hello, curls!</span><br></pre></td></tr></table></figure>
</div>

<!--ref-->

<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>

<ol>
<li>segmentfault, <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022577103">Golang net 包学习和实战</a></li>
<li>CSDN, <a target="_blank" rel="noopener" href="https://blog.csdn.net/sandware/article/details/40923491?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base"> AF_INET 域与 AF_UNIX 域 socket 通信原理对比</a></li>
<li>IBM, <a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-socket-create-socket">socket() — Create a socket</a></li>
<li>博客园, <a target="_blank" rel="noopener" href="https://www.cnblogs.com/cdwodm/archive/2012/09/22/2698163.html">Linux下PF_PACKET的使用</a></li>
<li>CSDN, <a target="_blank" rel="noopener" href="https://blog.csdn.net/aixinaxc/article/details/88774257">net包 dial - golang</a></li>
<li>CSDN, <a target="_blank" rel="noopener" href="https://blog.csdn.net/aixinaxc/article/details/88812259">net包 listen - golang</a></li>
<li>曝晒三十分, <a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/allokay/topics/1640848">深入学习golang中的net/http包</a></p>
</div>

</li>
</ol>
</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_Program/">TECH_PROGRAM</a></li>
          <li>GO_STANDARD_LIBRARY_2_NET</li>
        
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.weibo.com/u/2861056530" title="Weibo → https:&#x2F;&#x2F;www.weibo.com&#x2F;u&#x2F;2861056530" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HwangZobin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HwangZobin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021044371号 </a>
  </div>

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-guitar"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8LMT8RtOsi4JsbYHtNm2J7U-gzGzoHsz',
      appKey     : 'Q0cSe4rR8Iwr0Gs60rwWBsYa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
