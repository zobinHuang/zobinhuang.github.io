<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Exo 2:300,300italic,400,400italic,700,700italic|Caveat:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"post","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们以 Intel E1000 网卡为例，展示数据包从物理网卡 (p.s. E1000 是一个虚拟机网卡，它实现了对 Intel 82545EM 网卡的仿真 vmware_e1000) 到内核中的大致流程，我们在后面的章节中会对具体的细节进行分析。大致流程如 fc_e1000_overview 所示。       flowchart TB">
<meta property="og:type" content="website">
<meta property="og:title" content="Zobin">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/Linux_Kernel_Network_Packet_Driver_Recv/backup.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们以 Intel E1000 网卡为例，展示数据包从物理网卡 (p.s. E1000 是一个虚拟机网卡，它实现了对 Intel 82545EM 网卡的仿真 vmware_e1000) 到内核中的大致流程，我们在后面的章节中会对具体的细节进行分析。大致流程如 fc_e1000_overview 所示。       flowchart TB">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-18T13:41:05.335Z">
<meta property="article:modified_time" content="2022-09-18T13:41:05.335Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/Linux_Kernel_Network_Packet_Driver_Recv/backup">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title> | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lovin' Tech with Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about-me-(关于我)">

    <a href="/sec_about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me (关于我)</a>

  </li>
        <li class="menu-item menu-item-library-(知识库)">

    <a href="/sec_learning/" rel="section"><i class="fa fa-duotone fa-book fa-fw"></i>Library (知识库)</a>

  </li>
        <li class="menu-item menu-item-music-(独立音乐人)">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>Music (独立音乐人)</a>

  </li>
        <li class="menu-item menu-item-thoughts-(想法)">

    <a href="/sec_thoughts/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Thoughts (想法)</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/">TECH_OS_AND_LINUX_KERNEL</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/Linux_Kernel_Network_Packet_Driver_Recv/">LINUX_KERNEL_NETWORK_PACKET_DRIVER_RECV</a></li>
            <li>BACKUP</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们以 Intel E1000 网卡为例，展示数据包从物理网卡 (p.s. E1000 是一个虚拟机网卡，它实现了对 Intel 82545EM 网卡的仿真 <cite>vmware_e1000</cite>) 到内核中的大致流程，我们在后面的章节中会对具体的细节进行分析。大致流程如 <flowchartref>fc_e1000_overview</flowchartref> 所示。

  <flowchart class="mermaid" title="E1000 网卡数据包处理流程" label="fc_e1000_overview">
  flowchart TB
    %% 节点定义
    nic[网卡]
      style nic fill:#8fc,stroke:#333,stroke-width:4px
    memory[Device DMA Memory]
      style memory fill:#8fc,stroke:#333,stroke-width:4px
    irq_src[CPU 接收到对应中断向量]
    e1000_intr[[<code>e1000_intr</code><br>中断回调函数]]
    e1000_clean[[<code>e1000_clean</code><br>NAPI <code>poll</code> 函数]]
    e1000_clean_rx_irq[[<code>e1000_clean_rx_irq</code><br>从 DMA 区域中 Harvest 接收到的数据帧到内核缓冲区, 并且封装为 <code>sk_buff</code>]]
    has_reached_budget{完成 polling budget?}
    skb_1([<code>sk_buff</code>])
      style skb_1 fill:#fec,stroke:#333,stroke-width:4px
    e1000_receive_skb[[<code>e1000_receive_skb</code><br>对 <code>sk_buff</code> 进行处理]]
    napi_gro_receive[[<code>napi_gro_receive</code><br> 将数据包传递给 GRO 处理模块]]
    dev_gro_receive[[<code>dev_gro_receive</code><br>GRO 核心处理函数]]
    napi_skb_finish{<code>napi_skb_finish</code><br>判断 GRO 是否完成}
    gro_normal_one[[<code>gro_normal_one</code><br>GRO 核心处理函数]]
    %%
    %% 拓扑
    nic x-. MSI, MSI-X 或 INTx 中断 .-x irq_src
    nic -. DMA .-> memory
    irq_src ---> e1000_intr
    memory -.-> skb_1
    e1000_intr -. 调度 Softirq Kernel Thread .-> e1000_clean
    e1000_clean --> e1000_clean_rx_irq
    e1000_clean_rx_irq --> has_reached_budget
    skb_1 -.-> e1000_receive_skb
    has_reached_budget -- 未达到 --> e1000_receive_skb
    e1000_receive_skb --> napi_gro_receive
    napi_gro_receive --> dev_gro_receive
    dev_gro_receive --> napi_skb_finish
    napi_skb_finish -- GRO 未完成 --> e1000_clean_rx_irq
    napi_skb_finish -- GRO 完成 --> gro_normal_one
  </flowchart>

  <h3 class="title">硬中断回调</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，在 E1000 的驱动程序 <code>drivers/net/ethernet/intel/e1000/e1000_main.c</code> <cite>linuxsrc_e1000_main_c</cite> 中，它首先调用如下函数向内核申请了一个 Linux IRQ:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_request_irq</span><span class="params">(struct e1000_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> adapter-&gt;netdev;</span><br><span class="line">  <span class="keyword">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line">  <span class="keyword">int</span> irq_flags = IRQF_SHARED;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">        netdev);</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    e_err(probe, <span class="string">&quot;Unable to allocate interrupt Error: %d\n&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到 E1000 处理 Linux IRQ 的中断回调函数是同文件下的 <code>e1000_intr</code>，具体代码如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * e1000_intr - Interrupt Handler</span></span><br><span class="line"><span class="comment"> * @irq: interrupt number</span></span><br><span class="line"><span class="comment"> * @data: pointer to a network interface device structure</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">e1000_intr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> =</span> netdev_priv(netdev);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span> =</span> &amp;adapter-&gt;hw;</span><br><span class="line">  u32 icr = er32(ICR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely((!icr)))</span><br><span class="line">    <span class="keyword">return</span> IRQ_NONE;  <span class="comment">/* Not our interrupt */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we might have caused the interrupt, but the above</span></span><br><span class="line"><span class="comment">   * read cleared it, and just in case the driver is</span></span><br><span class="line"><span class="comment">   * down there is nothing to do so return handled</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (unlikely(test_bit(__E1000_DOWN, &amp;adapter-&gt;flags)))</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(icr &amp; (E1000_ICR_RXSEQ | E1000_ICR_LSC))) &#123;</span><br><span class="line">    hw-&gt;get_link_status = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* guard against interrupt when we&#x27;re going down */</span></span><br><span class="line">    <span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">      schedule_delayed_work(&amp;adapter-&gt;watchdog_task, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* disable interrupts, without the synchronize_irq bit */</span></span><br><span class="line">  ew32(IMC, ~<span class="number">0</span>);</span><br><span class="line">  E1000_WRITE_FLUSH();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (likely(napi_schedule_prep(&amp;adapter-&gt;napi))) &#123;</span><br><span class="line">    adapter-&gt;total_tx_bytes = <span class="number">0</span>;</span><br><span class="line">    adapter-&gt;total_tx_packets = <span class="number">0</span>;</span><br><span class="line">    adapter-&gt;total_rx_bytes = <span class="number">0</span>;</span><br><span class="line">    adapter-&gt;total_rx_packets = <span class="number">0</span>;</span><br><span class="line">    __napi_schedule(&amp;adapter-&gt;napi);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* this really should not happen! if it does it is basically a</span></span><br><span class="line"><span class="comment">     * bug, but not a hard error, so enable ints and continue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">      e1000_irq_enable(adapter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <h3 class="title">软中断 NAPI Polling</h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;E1000 网卡使用 NAPI 软中断对数据包做后续的处理，E1000 NAPI 的 <code>poll</code> 函数是同文件下的 <code>e1000_clean</code>，定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * e1000_clean - NAPI Rx polling callback</span></span><br><span class="line"><span class="comment"> * @napi: napi struct containing references to driver info</span></span><br><span class="line"><span class="comment"> * @budget: budget given to driver for receive packets</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_clean</span><span class="params">(struct napi_struct *napi, <span class="keyword">int</span> budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> =</span> container_of(napi, struct e1000_adapter,</span><br><span class="line">                napi);</span><br><span class="line">  <span class="keyword">int</span> tx_clean_complete = <span class="number">0</span>, work_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tx_clean_complete = e1000_clean_tx_irq(adapter, &amp;adapter-&gt;tx_ring[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  adapter-&gt;clean_rx(adapter, &amp;adapter-&gt;rx_ring[<span class="number">0</span>], &amp;work_done, budget);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tx_clean_complete || work_done == budget)</span><br><span class="line">    <span class="keyword">return</span> budget;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exit the polling mode, but don&#x27;t re-enable interrupts if stack might</span></span><br><span class="line"><span class="comment">  * poll us due to busy-polling</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (likely(napi_complete_done(napi, work_done))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(adapter-&gt;itr_setting &amp; <span class="number">3</span>))</span><br><span class="line">      e1000_set_itr(adapter);</span><br><span class="line">    <span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">      e1000_irq_enable(adapter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>e1000_clean</code> 进一步调用了 <code>e1000_clean_rx_irq</code> 对网卡接收到的数据进行处理，主要完成两件事情: ① 将数据包从网卡 DMA 数据区域将数据包拷贝到内核空间中，并且 ② 使用 <code>sk_buff</code> 对数据包进行封装。<code>e1000_clean_rx_irq</code> 在同文件中被定义，相关定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * e1000_clean_rx_irq - Send received data up the network stack; legacy</span></span><br><span class="line"><span class="comment"> * @adapter: board private structure</span></span><br><span class="line"><span class="comment"> * @rx_ring: ring to clean</span></span><br><span class="line"><span class="comment"> * @work_done: amount of napi work completed this call</span></span><br><span class="line"><span class="comment"> * @work_to_do: max amount of work allowed for this call to do</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">e1000_clean_rx_irq</span><span class="params">(struct e1000_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct e1000_rx_ring *rx_ring,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> *work_done, <span class="keyword">int</span> work_to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> adapter-&gt;netdev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span> =</span> adapter-&gt;pdev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> *<span class="title">rx_desc</span>, *<span class="title">next_rxd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_buffer</span> *<span class="title">buffer_info</span>, *<span class="title">next_buffer</span>;</span></span><br><span class="line">  u32 length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> cleaned_count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> cleaned = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> total_rx_bytes = <span class="number">0</span>, total_rx_packets = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  i = rx_ring-&gt;next_to_clean;</span><br><span class="line">  rx_desc = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">  buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    u8 *data;</span><br><span class="line">    u8 status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*work_done &gt;= work_to_do)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    (*work_done)++;</span><br><span class="line">    dma_rmb(); <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span></span><br><span class="line"></span><br><span class="line">    status = rx_desc-&gt;status;</span><br><span class="line">    length = le16_to_cpu(rx_desc-&gt;length);</span><br><span class="line"></span><br><span class="line">    data = buffer_info-&gt;rxbuf.data;</span><br><span class="line">    prefetch(data);</span><br><span class="line">    skb = e1000_copybreak(adapter, buffer_info, length, data);</span><br><span class="line">    <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> frag_len = e1000_frag_len(adapter);</span><br><span class="line"></span><br><span class="line">      skb = build_skb(data - E1000_HEADROOM, frag_len);</span><br><span class="line">      <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">        adapter-&gt;alloc_rx_buff_failed++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      skb_reserve(skb, E1000_HEADROOM);</span><br><span class="line">      dma_unmap_single(&amp;pdev-&gt;dev, buffer_info-&gt;dma,</span><br><span class="line">          adapter-&gt;rx_buffer_len,</span><br><span class="line">          DMA_FROM_DEVICE);</span><br><span class="line">      buffer_info-&gt;dma = <span class="number">0</span>;</span><br><span class="line">      buffer_info-&gt;rxbuf.data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++i == rx_ring-&gt;count)</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    next_rxd = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">    prefetch(next_rxd);</span><br><span class="line"></span><br><span class="line">    next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">    cleaned = <span class="literal">true</span>;</span><br><span class="line">    cleaned_count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* !EOP means multiple descriptors were used to store a single</span></span><br><span class="line"><span class="comment">     * packet, if thats the case we need to toss it.  In fact, we</span></span><br><span class="line"><span class="comment">     * to toss every packet with the EOP bit clear and the next</span></span><br><span class="line"><span class="comment">     * frame that _does_ have the EOP bit set, as it is by</span></span><br><span class="line"><span class="comment">     * definition only a frame fragment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!(status &amp; E1000_RXD_STAT_EOP)))</span><br><span class="line">      adapter-&gt;discarding = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adapter-&gt;discarding) &#123;</span><br><span class="line">      <span class="comment">/* All receives must fit into a single buffer */</span></span><br><span class="line">      netdev_dbg(netdev, <span class="string">&quot;Receive packet consumed multiple buffers\n&quot;</span>);</span><br><span class="line">      dev_kfree_skb(skb);</span><br><span class="line">      <span class="keyword">if</span> (status &amp; E1000_RXD_STAT_EOP)</span><br><span class="line">        adapter-&gt;discarding = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">goto</span> next_desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(rx_desc-&gt;errors &amp; E1000_RXD_ERR_FRAME_ERR_MASK)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e1000_tbi_should_accept(adapter, status,</span><br><span class="line">                rx_desc-&gt;errors,</span><br><span class="line">                length, data)) &#123;</span><br><span class="line">        length--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (netdev-&gt;features &amp; NETIF_F_RXALL) &#123;</span><br><span class="line">        <span class="keyword">goto</span> process_skb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_kfree_skb(skb);</span><br><span class="line">        <span class="keyword">goto</span> next_desc;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">process_skb:</span><br><span class="line">    total_rx_bytes += (length - <span class="number">4</span>); <span class="comment">/* don&#x27;t count FCS */</span></span><br><span class="line">    total_rx_packets++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!(netdev-&gt;features &amp; NETIF_F_RXFCS)))</span><br><span class="line">      <span class="comment">/* adjust length to remove Ethernet CRC, this must be</span></span><br><span class="line"><span class="comment">       * done after the TBI_ACCEPT workaround above</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      length -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer_info-&gt;rxbuf.data == <span class="literal">NULL</span>)</span><br><span class="line">      skb_put(skb, length);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* copybreak skb */</span></span><br><span class="line">      skb_trim(skb, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receive Checksum Offload */</span></span><br><span class="line">    e1000_rx_checksum(adapter,</span><br><span class="line">          (u32)(status) |</span><br><span class="line">          ((u32)(rx_desc-&gt;errors) &lt;&lt; <span class="number">24</span>),</span><br><span class="line">          le16_to_cpu(rx_desc-&gt;csum), skb);</span><br><span class="line"></span><br><span class="line">    e1000_receive_skb(adapter, status, rx_desc-&gt;special, skb);</span><br><span class="line"></span><br><span class="line">next_desc:</span><br><span class="line">    rx_desc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(cleaned_count &gt;= E1000_RX_BUFFER_WRITE)) &#123;</span><br><span class="line">      adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line">      cleaned_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use prefetched values */</span></span><br><span class="line">    rx_desc = next_rxd;</span><br><span class="line">    buffer_info = next_buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  rx_ring-&gt;next_to_clean = i;</span><br><span class="line"></span><br><span class="line">  cleaned_count = E1000_DESC_UNUSED(rx_ring);</span><br><span class="line">  <span class="keyword">if</span> (cleaned_count)</span><br><span class="line">    adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line"></span><br><span class="line">  adapter-&gt;total_rx_packets += total_rx_packets;</span><br><span class="line">  adapter-&gt;total_rx_bytes += total_rx_bytes;</span><br><span class="line">  netdev-&gt;stats.rx_bytes += total_rx_bytes;</span><br><span class="line">  netdev-&gt;stats.rx_packets += total_rx_packets;</span><br><span class="line">  <span class="keyword">return</span> cleaned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Line 112 处，函数调用了 <code>e1000_receive_skb</code> 函数，对从 DMA 区域取出来并且完成封装的各个 <code>sk_buff</code> 进行处理。<code>e1000_receive_skb</code> 在同文件中被定义，相关定义如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * e1000_receive_skb - helper function to handle rx indications</span></span><br><span class="line"><span class="comment"> * @adapter: board private structure</span></span><br><span class="line"><span class="comment"> * @status: descriptor status field as written by hardware</span></span><br><span class="line"><span class="comment"> * @vlan: descriptor vlan field as written by hardware (no le/be conversion)</span></span><br><span class="line"><span class="comment"> * @skb: pointer to sk_buff to be indicated to stack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e1000_receive_skb</span><span class="params">(struct e1000_adapter *adapter, u8 status,</span></span></span><br><span class="line"><span class="function"><span class="params">            __le16 vlan, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  skb-&gt;protocol = eth_type_trans(skb, adapter-&gt;netdev);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status &amp; E1000_RXD_STAT_VP) &#123;</span><br><span class="line">    u16 vid = le16_to_cpu(vlan) &amp; E1000_RXD_SPC_VLAN_MASK;</span><br><span class="line"></span><br><span class="line">    __vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);</span><br><span class="line">  &#125;</span><br><span class="line">  napi_gro_receive(&amp;adapter-&gt;napi, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到在函数中，实际上是调用了用于进行 GRO 处理的函数 <code>napi_gro_receive</code> (p.s. 和 TSO 对应，GRO 用于收包，TSO 用于发包) 将 <code>sk_buff</code> 传递给 GRO 处理模块。<code>napi_gro_receive</code> 在 <code>net/core/dev.c</code><cite>linuxsrc_dev_c</cite> 中被定义，如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gro_result_t</span> <span class="title">napi_gro_receive</span><span class="params">(struct napi_struct *napi, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">gro_result_t</span> ret;</span><br><span class="line"></span><br><span class="line">  skb_mark_napi_id(skb, napi);</span><br><span class="line">  trace_napi_gro_receive_entry(skb);</span><br><span class="line"></span><br><span class="line">  skb_gro_reset_offset(skb, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ret = napi_skb_finish(napi, skb, dev_gro_receive(napi, skb));</span><br><span class="line">  trace_napi_gro_receive_exit(ret);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(napi_gro_receive);</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以发现其实际上调用了 <code>dev_gro_receive</code> 来实现 GRO 的核心处理功能，然后调用 <code>napi_skb_finish</code> 来根据 GRO 的处理结果进行进一步处理。<code>dev_gro_receive</code> 同样是在 <code>net/core/dev.c</code><cite>linuxsrc_dev_c</cite> 中被定义的，如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> gro_result <span class="title">dev_gro_receive</span><span class="params">(struct napi_struct *napi, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u32 hash = skb_get_hash_raw(skb) &amp; (GRO_HASH_BUCKETS - <span class="number">1</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span> =</span> &amp;offload_base;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">packet_offload</span> *<span class="title">ptype</span>;</span></span><br><span class="line">  __be16 type = skb-&gt;protocol;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">gro_head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">pp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">gro_result</span> <span class="title">ret</span>;</span></span><br><span class="line">  <span class="keyword">int</span> same_flow;</span><br><span class="line">  <span class="keyword">int</span> grow;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (netif_elide_gro(skb-&gt;dev))</span><br><span class="line">    <span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line">  gro_head = gro_list_prepare(napi, skb);</span><br><span class="line"></span><br><span class="line">  rcu_read_lock();</span><br><span class="line">  list_for_each_entry_rcu(ptype, head, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptype-&gt;type != type || !ptype-&gt;callbacks.gro_receive)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    skb_set_network_header(skb, skb_gro_offset(skb));</span><br><span class="line">    skb_reset_mac_len(skb);</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;flush = skb_is_gso(skb) || skb_has_frag_list(skb);</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;encap_mark = <span class="number">0</span>;</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;recursion_counter = <span class="number">0</span>;</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;is_fou = <span class="number">0</span>;</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;is_atomic = <span class="number">1</span>;</span><br><span class="line">    NAPI_GRO_CB(skb)-&gt;gro_remcsum_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup for GRO checksum validation */</span></span><br><span class="line">    <span class="keyword">switch</span> (skb-&gt;ip_summed) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHECKSUM_COMPLETE:</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum = skb-&gt;csum;</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum_valid = <span class="number">1</span>;</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum_cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CHECKSUM_UNNECESSARY:</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum_cnt = skb-&gt;csum_level + <span class="number">1</span>;</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum_valid = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum_cnt = <span class="number">0</span>;</span><br><span class="line">      NAPI_GRO_CB(skb)-&gt;csum_valid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pp = INDIRECT_CALL_INET(ptype-&gt;callbacks.gro_receive,</span><br><span class="line">          ipv6_gro_receive, inet_gro_receive,</span><br><span class="line">          gro_head, skb);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (&amp;ptype-&gt;<span class="built_in">list</span> == head)</span><br><span class="line">    <span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PTR_ERR(pp) == -EINPROGRESS) &#123;</span><br><span class="line">    ret = GRO_CONSUMED;</span><br><span class="line">    <span class="keyword">goto</span> ok;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  same_flow = NAPI_GRO_CB(skb)-&gt;same_flow;</span><br><span class="line">  ret = NAPI_GRO_CB(skb)-&gt;<span class="built_in">free</span> ? GRO_MERGED_FREE : GRO_MERGED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp) &#123;</span><br><span class="line">    skb_list_del_init(pp);</span><br><span class="line">    napi_gro_complete(napi, pp);</span><br><span class="line">    napi-&gt;gro_hash[hash].count--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (same_flow)</span><br><span class="line">    <span class="keyword">goto</span> ok;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NAPI_GRO_CB(skb)-&gt;flush)</span><br><span class="line">    <span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(napi-&gt;gro_hash[hash].count &gt;= MAX_GRO_SKBS)) &#123;</span><br><span class="line">    gro_flush_oldest(napi, gro_head);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    napi-&gt;gro_hash[hash].count++;</span><br><span class="line">  &#125;</span><br><span class="line">  NAPI_GRO_CB(skb)-&gt;count = <span class="number">1</span>;</span><br><span class="line">  NAPI_GRO_CB(skb)-&gt;age = jiffies;</span><br><span class="line">  NAPI_GRO_CB(skb)-&gt;last = skb;</span><br><span class="line">  skb_shinfo(skb)-&gt;gso_size = skb_gro_len(skb);</span><br><span class="line">  list_add(&amp;skb-&gt;<span class="built_in">list</span>, gro_head);</span><br><span class="line">  ret = GRO_HELD;</span><br><span class="line"></span><br><span class="line">pull:</span><br><span class="line">  grow = skb_gro_offset(skb) - skb_headlen(skb);</span><br><span class="line">  <span class="keyword">if</span> (grow &gt; <span class="number">0</span>)</span><br><span class="line">    gro_pull_from_frag0(skb, grow);</span><br><span class="line">ok:</span><br><span class="line">  <span class="keyword">if</span> (napi-&gt;gro_hash[hash].count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!test_bit(hash, &amp;napi-&gt;gro_bitmask))</span><br><span class="line">      __set_bit(hash, &amp;napi-&gt;gro_bitmask);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (test_bit(hash, &amp;napi-&gt;gro_bitmask)) &#123;</span><br><span class="line">    __clear_bit(hash, &amp;napi-&gt;gro_bitmask);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">normal:</span><br><span class="line">  ret = GRO_NORMAL;</span><br><span class="line">  <span class="keyword">goto</span> pull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>dev_gro_receive</code> 的处理结果是由 <code>napi_skb_finish</code> 进行接手的，<code>napi_skb_finish</code> 同样是在 <code>net/core/dev.c</code><cite>linuxsrc_dev_c</cite> 中被定义的，如下所示:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">gro_result_t</span> <span class="title">napi_skb_finish</span><span class="params">(struct napi_struct *napi,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">gro_result_t</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">  <span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line">    gro_normal_one(napi, skb, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> GRO_MERGED_FREE:</span><br><span class="line">    <span class="keyword">if</span> (NAPI_GRO_CB(skb)-&gt;<span class="built_in">free</span> == NAPI_GRO_FREE_STOLEN_HEAD)</span><br><span class="line">      napi_skb_free_stolen_head(skb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __kfree_skb_defer(skb);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> GRO_HELD:</span><br><span class="line">  <span class="keyword">case</span> GRO_MERGED:</span><br><span class="line">  <span class="keyword">case</span> GRO_CONSUMED:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>napi_skb_finish</code> 判断到 GRO 完成，也即 <code>dev_gro_receive</code> 的返回值为 <code>GRO_NORMAL</code> 时，则调用 <code>gro_normal_one</code>，准备将 <code>sk_buff</code> 上送协议栈进行处理。<code>gro_normal_one</code> 的定义如下所示，它位于 <code>net/core/dev.c</code><cite>linuxsrc_dev_c</cite> 文件中:

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of GRO_NORMAL skbs to batch up for list-RX */</span></span><br><span class="line"><span class="keyword">int</span> gro_normal_batch __read_mostly = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Queue one GRO_NORMAL SKB up for list processing. If batch size exceeded,</span></span><br><span class="line"><span class="comment"> * pass the whole batch up to the stack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gro_normal_one</span><span class="params">(struct napi_struct *napi, struct sk_buff *skb, <span class="keyword">int</span> segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  list_add_tail(&amp;skb-&gt;<span class="built_in">list</span>, &amp;napi-&gt;rx_list);</span><br><span class="line">  napi-&gt;rx_count += segs;</span><br><span class="line">  <span class="keyword">if</span> (napi-&gt;rx_count &gt;= gro_normal_batch)</span><br><span class="line">    gro_normal_list(napi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/">TECH_OS_AND_LINUX_KERNEL</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/Linux_Kernel_Network_Packet_Driver_Recv/">LINUX_KERNEL_NETWORK_PACKET_DRIVER_RECV</a></li>
            <li>BACKUP</li>
          
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar_2.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
