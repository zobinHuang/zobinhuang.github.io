<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"hide","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#FF4136","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="分页机制和动态页面分配">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:locale">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/xxx.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/segment.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/problem.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/page.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/page_cut.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/map.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/pdt.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/initial_memory.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/processed_memory.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/low_1_m.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/local_global.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/pdt_explaination.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/pdt_explaination_2.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/multi_segment_1.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/multi_segment_2.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/multi_segment_3.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/tcb.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/user_task.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/pic/page_model.png">
<meta property="article:published_time" content="2022-02-10T14:39:11.269Z">
<meta property="article:modified_time" content="2021-11-28T14:36:17.715Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_12_Page/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>分页机制和动态页面分配 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Loves Tech & Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-关于我">

    <a href="/sec_about/" rel="section"><i class="fa fa-address-card fa-fw"></i>关于我</a>

  </li>
        <li class="menu-item menu-item-知识库">

    <a href="/sec_learning/" rel="section"><i class="fa fa-book-open fa-fw"></i>知识库</a>

  </li>
        <li class="menu-item menu-item-进度">

    <a href="/sec_schedule/" rel="section"><i class="fa fa-calendar-alt fa-fw"></i>进度</a>

  </li>
        <li class="menu-item menu-item-独立音乐人">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>独立音乐人</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="cn">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">分页机制和动态页面分配
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/">TECH_OS_AND_LINUX_KERNEL</a></li>
          <li>X86_ISA_12_PAGE</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_concurrent_img{padding: 10px 10px; display: flex; align-items:center; justify-content:center;}
    @media(max-width: 768px) {
      .div_concurrent_img{flex-direction: column;}
    }
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_border{
      margin-bottom: 20px;
      padding: 10px 10px; 
      font-size: 16px; 
      word-spacing:0px;  
      border:1px solid black;
    }
    .div_learning_post_background{
      background-color:#E3E2E2;
      padding: 10px 40px; 
      font-size: 16px;
      word-spacing:0px;  
      border-radius: 15px;
      margin-bottom: 15px;
    }
    .div_learning_post_background p{
      margin: 0px;
    }
</style>

<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
<!--支持矩阵显示-->
<script type="text/javascript">
  run_maths = function() {
    if (document.querySelector('[class*="cmath"]') !== null) {
      if (typeof (mjax_path)=='undefined') { mjax_path='https://cdn.jsdelivr.net/npm/mathjax@2'; }
      if (typeof (mjax_config)=='undefined') { mjax_config='AM_CHTML'; }
      smjax = document.createElement ('script');
      smjax.setAttribute('src',`${mjax_path}/MathJax.js?config=${mjax_config}`);
      smjax.setAttribute('async',true);
      document.getElementsByTagName('head')[0].appendChild(smjax);
    }
  };
  if (document.readyState === 'loading') {  
    window.addEventListener('DOMContentLoaded', run_maths); 
  } else { 
    run_maths(); 
  }
</script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：Aug.24 2021</i></font></h4>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center" bgcolor="#FFFFFF">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--矩阵公式-->
<!--
<div class="cmath" align="center">
  `((1, 0),(1, 0))`
</div>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_segment_page"><font color="blue"><b>段页式内存管理机制</b></font></a>：讲述了在分段背景下仍然需要分页机制的原因；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#1_segment_page_1"><font color="blue">分段的意义</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2 <a href="#1_segment_page_2"><font color="blue">分段的方法</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3 <a href="#1_segment_page_3"><font color="blue">分页的 Motivation</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4 <a href="#1_segment_page_4"><font color="blue">分页的方法</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4.1 <a href="#1_segment_page_4_1"><font color="blue">引入线性地址空间</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4.2 <a href="#1_segment_page_4_2"><font color="blue">将内存分页</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4.3 <a href="#1_segment_page_4_3"><font color="blue">引入页表</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4.4 <a href="#1_segment_page_4_4"><font color="blue">引入页目录</font></a>
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_example"><font color="blue"><b>段页式内存管理实例</b></font></a>：详细地分析了一个使能了分页机制的内核程序；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#2_example_1"><font color="blue">开启分页机制</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#2_example_2"><font color="blue">全局空间和局部空间</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#2_example_3"><font color="blue">创建内核任务</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href="#2_example_3_1"><font color="blue">分页机制下的虚拟空间分配</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href="#2_example_3_2"><font color="blue">创建 TSS</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#2_example_4"><font color="blue">创建一个用户任务</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 <a href="#2_example_4_1"><font color="blue">多段模型 与 平坦模型</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 <a href="#2_example_4_2"><font color="blue">加载用户程序</font></a>
  </div>
</div>

<!--标题-->
<h2><a name="1_segment_page">1. 段页式内存管理机制</a></h2>
<div class="div_learning_post">
  <h3><a name="1_segment_page_1">1.1 分段的意义</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;基于我们从保护模式以来的几篇文章的理解，我们现在知道了分段的一个很重要的意义：<b>特权级保护</b>。我们通过把一个任务内的不同的段分为不同的特权级，并且基于 "先登记，后使用" 的思路，把这些段登记在任务局部空间的 LDT 和全局空间的 GDT 中。一个段要被访问之前，必须通过处理器固件的合法性检查。可以说，<font color="red">分段机制是从程序本身的性质出发，处理器为了实施保护而采用的内存管理机制</font>，这也就是为什么处理器升级到 32 位之后仍然保留着分段机制的原因。

  <h3><a name="1_segment_page_2">1.2 分段的方法</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;好了，在升华了分段机制的 Motivation 后，让我们再来回顾一下分段基址的基本方法，以便我们后面引出分页机制。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上图所示，我们曾经说过，对于一个任务，它能够在 LDT 中注册的段描述符的个数受限于段描述符选择子的索引宽度 —— 13-bits，即能够注册 `2^13=8192` 个段选择子，而一个段描述符对应的段的最大长度受限于段描述符中段界限的宽度 —— 20-bits，当 G 位为 1 时，段界限单位为 4KB，因此一个段的最大长度为 `2^20 \times 4KB = 4GB`。因此，理论上来说，一个任务拥有的段的空间总和理论上最大为：`4GB \times 8192 = 32768GB`。对于被所有任务共享的全局地址空间，也是一样的计算方法，因此一个任务能够访问到的全局地址空间中的段空间总和理论上也为 `4GB \times 8192 = 32768GB`。这样算起来，在一个任务内部，理论上能够访问的空间大小最大为：`32768GB + 32768GB = 65536GB`。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意，我们把上面分析的地址空间称为一个任务的 <font color="blue">逻辑地址空间</font>。它具体是什么意思呢？它指的起始就是 <font color="red">段内偏移地址空间</font>。请读者朋友思考一下，我们上面算的总和，是在对一个任务中各个段的段内偏移地址做加法，因此，在一个任务中，我们是一共有了 65536GB 的段内偏移地址空间。

  <div align="center">
    <img src="./pic/segment.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;但是，我们在 32-bits 处理器下，我们实际能访问的物理内存只有 4GB。虽然各个任务的 <b>私有逻辑地址空间</b> 以及大家共享的 <b>全局逻辑地址空间</b> 的理论最大值特别大，但是最终大家都得憋屈着把各家的段都塞进 4GB 的物理内存中。我们知道，当一个段被安装到内存之后，我们一般回相应地在 GDT/LDT 中注册相应的描述符，在描述符中会存储着段在内存中的基地址，这个基地址就是段实际上在内存中的位置，我们把实际在内存中的空间称为 <font color="blue">物理地址空间</font>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于我们在分页机制中将引入 <font color="blue">线性地址空间</font>，而在分页机制没有起作用的时候 <b>线性地址空间</b> 就等同于 <b>物理地址空间</b>，因此在分页机制没有被引入之前我们常常把这两个词混着用，我们在上图中也干了这样的事情。

  <h3><a name="1_segment_page_3">1.3 分页的 Motivation</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;有读者朋友会问：要是各个任务的 <b>逻辑地址空间</b> 需求都特别大，无法全部塞进仅 4GB 的 <b>物理地址空间</b> 中该怎么办呢？就算各家的 <b>逻辑地址空间</b> 需求都不大，如果任务的运行数量很多， <b>物理地址空间</b> 肯定也不够用。为了解决这个问题，回忆我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_8_Protect_Mode/index.html#1_gdt_3">段描述符</a> 中介绍过的段描述符的 P 位和 A 位。P 位用于标识一个段是否在内存中，A 位用于指示一个段最近是否被访问过。当一个段被访问的时候，处理器固件将自动地把相应描述符的 A 位置为 1。把 A 位清 0 的工作是由操作系统来负责的，操作系统会定期地监视各个段描述符 A 位的状态。如果某个段描述符的 A 位变为了 1，则首先会将它清零，然后再操作系统中增加用于记录该段使用次数的变量。当有一刻，操作系统发现它已经无法在内存中找到一片能够容纳即将被安装到内存中的段的空间时，它会将使用次数最少的段从内存迁移到磁盘中去，然后将相应段描述符的 P 位置为 0，以标识该段不在内存中。下一次如果有任务访问这个被替换到硬盘中的段的时候，就会引发异常中断，操作系统相应的中断服务过程将会使用相同的手段，将被替换到磁盘中的重新迁移到内存中。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;读者点了点头，会觉得上述基于分段的替换机制已经解决了 <b>物理地址空间</b> 不足的问题。上述机制确实解决了问题，但是它存在性能问题：<font color="red">由于段在内存中的安装只能是连续的，这就导致了严重的内存碎片问题</font>。

  <div align="center">
    <img src="./pic/problem.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上图上半部分所示，当想我们想安装一个新的段的时候，虽然我们找不到一个合适的空白内存区域能够容纳这个新来的段，但是内存中零零散散的碎片空间总和加起来是可以容纳的。这样一来，最无奈的方法莫过于把内存空间中的段全部拉到磁盘中，然后重组为上图下半部分的内存形态，这样一来就能够容纳新来的段了。可是我们知道，磁盘的读写是有巨大延迟开销的。因此，虽然有办法能够处理内存碎片问题，但是性能是底下的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;基于这个问题，我们拥有了本文的重点 —— <font color="blue">分页机制</font>。可以说，<font color="red">分页机制是从处理器底层访问内存的角度出发，为了提高内存的使用效率而采用的内存管理机制</font>。因此我们现在知道，分段和分页并不是在解决同一个维度上的问题，但是它们都对我们的程序最终以什么方式访问内存产生了影响，所以我们将它们放在一起讨论。

  <h3><a name="1_segment_page_4">1.4 分页的方法</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;基于上述的性能问题，我们会发现，其性能问题的根源在于以下两点：

  <ul>
    <li>我们只能连续地在物理内存中安装段</li>
    <li>各个段的长度是不固定的</li>
  </ul>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第一个原因导致了在一段时间过后，内存中将产生大量的段碎片；第二个原因导致了我们没有很好的办法来减小内存碎片的数量。因此，在分段机制的底下，我们又多加了一层分页机制，来解决该性能问题。我们下面对分页的方法进行解释。

  <h5><a name="1_segment_page_4_1">(1) 引入线性地址空间</a></h5>

  <div align="center">
    <img src="./pic/page.png" width=700px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;同样地，在一个任务内部，我们还是有 可以访问的 32768GB 的 <b>局部逻辑地址空间</b> 和 32768GB 的 <b>全局逻辑地址空间</b>。同样地，通过把各个段登记到 GDT 和 LDT 中，我们就能够把这些段在另一个空间中 "平铺" 开来，这样我们就能够在各个段描述符拿到各个段的基地址。在引入分页机制之前，我们用于 "平铺" 各个段的地址空间直接就是 <b>物理地址空间</b>；而在引入分页机制之后，现在我们用于 "平铺" 各个段的空间是一个称为 <font color="blue">线性地址空间</font> 的地址空间，有时也称为 <font color="blue">虚拟地址空间</font>。<font color="blue">线性地址空间</font> 各个任务都有一份，相当于各个任务都有了独属于自己的可以用于 "平铺" 各个段的地址空间，如上图所示。我们规定各个任务的 <b>线性地址空间</b> 的大小和实际整体 <b>物理地址空间</b> 的大小保持一致 —— 也是 4GB，原因我们在后面将会进行解释。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于各个任务的 <b>线性地址空间</b>，我们把它分为两部分：<b>全局空间</b> 和 <b>局部空间</b>。对于 <b>全局空间</b>，里面 "平铺" 的将是各个任务之间共享的，登记在 GDT 中的描述符对应的段，例如内核提供的例程等。每个任务的 <b>全局空间</b> 中的内容都是完全一致的；对于 <b>局部空间</b>，里面 "平铺" 的将是任务自己私有的，登记在自己 LDT 中的描述符对应的段，各个任务的 <b>局部空间</b> 中的内容都是由自己决定的。我们在 <a href="#2_example_2">全局空间和局部空间</a> 中还将继续探讨 <b>全局空间</b> 和 <b>局部空间</b> 的问题，读者届时将能理解如此设计的 Motivation。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意！我们现在讨论的 <b>线性地址空间</b> 是一个虚拟的空间。对于一个任务的安装来说，我们其实只是在计算各个段在这个虚拟的 <b>线性地址空间</b> 中的位置，这并不是一个真实的物理安装过程。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;完成在 <b>线性地址空间</b> 的段安装之后，也就代表了我们在 GDT/LDT 中注册好了相应的段描述符，这些段描述符的基地址字段填写的就是基于 <b>线性地址空间</b> 的基地址。下面，我们的工作就是完成从 <b>线性地址空间</b> 到 <b>物理地址空间</b> 的映射，也就是在这一步，我们引入了分页机制，从而解决了内存碎片问题。

  <h5><a name="1_segment_page_4_2">(2) 将内存分页</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在，为了解释分页机制下是如何把 <b>线性地址空间</b> 映射到 <b>物理地址空间</b> 上去的，我们现在首先反过头来分析分页机制下是如何分割 <b>物理地址空间</b> 的，然后我们再来关心如何进行映射。

  <div align="center">
    <img src="./pic/page_cut.png" width=200px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 4GB 的 <b>物理地址空间</b>，我们现在将它以 4KB 为单元进行切分，每一个单元我们称之为一个 <font color="blue">页 (Page)</font>。这样，我们一共能切出 `(4GB)/(4KB)=`0x100000 `=` 1048576 个页。细心的读者会注意到，每个页的起始地址的低 12-bits 都为 0，我们定位 4GB 的 <b>物理地址空间</b> 中的一个页，使用 20-bits 的宽度就可以了。这一点请读者先留个印象。

  <h5><a name="1_segment_page_4_3">(3) 引入页表</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在我们最后的工作就是解释如何把 <b>线性地址空间</b> 映射到被分页了的 <b>物理地址空间</b> 上，以及它是如何解决内存碎片问题的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当操作系统加载一个程序并且创建为任务时，会首先如上文所述的，在相应的 <b>线性地址空间</b> 中寻找空闲的段空间并进行 "平铺"，然后就会把这些段映射到空闲的页上去。由于 <b>物理地址空间</b> 是所有任务共享的，因此这些页也是各个任务所共享的，所以此处 "空闲的页" 指的是还没有被本任务或者其它任务使用的页空间，据此可以推测：页的分配情况是由全局性管理的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;读者会有些疑惑：一个页最多就 4KB，然而段的长度可以远远长于这个值，怎么能把段塞到页里面去呢？我们下面马上会进行解释。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;为了在分配之后能够根据线性地址找到页的物理地址，对于每个任务的线性地址空间，都会有一张 <font color="blue">页表 (Page Table)</font>，这是一张一维的表格。因为 <b>线性地址空间</b> 一共也是 4GB，所以也是可以分出 1048576 个页，所以页表一共有 1048576 个表项。页表中的各项存储的是一个实际的页单元物理起始地址。正如我们上文所述，在物理内存中，每个页的起始地址的低 12-bits 都为 0，定位一个页需要的宽度是 20-bits，因此在一个页表中定位一个页表项需要的宽度也是 20-bits。基于此，这张页表的使用方法是：因此当我们拿到一个 <b>线性地址空间</b> 的地址时，我们可以取其高 20-bits，作为页表表项的索引。通过索引找到页表项之后，我们就能拿到一个实际的 32-bits 页单元的 <b>起始物理地址</b>，将这个 <b>32-bits 起始物理地址</b> 与我们 <b>线性地址空间</b> 剩余的 12-bits 偏移地址相加，就能最终拿到我们想要 <b>物理空间地址</b>。

  <div align="center">
    <img src="./pic/map.png" width=700px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上图所示，我们通过取线性地址的高 20-bits，把我们在 <b>线性地址空间</b> 中的一个段分成了页表索引为 "00202"、"00201" 和 "00200" 三部分。当我们在程序中访问这个段时，例如我们的目标线性地址是 "00201003"，那么处理器的页固件首先会拿到高 20-bits —— "00201"，然后在页表中索引出该 4KB 线性地址块在物理内存页中的实际起始地址 "00002000"，接着将这个实际的 <b>物理起始地址</b> 与剩下的 12-bits 偏移地址 "003" 相加，得到 "00002003"，这就是最终用于访问物理内存的 <b>物理地址</b>。处理器将 "00002003" 送上地址总线，就能够访问到存储着目标数据的内存单元。

  <h5><a name="1_segment_page_4_4">(4) 引入页目录</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;一个任务中，在我们有了页表之后，我们就能实现 <b>线性地址空间</b> 向 <b>物理地址空间</b> 的映射了。但是有一个问题就是：对于每一个任务，我们都需要创建 `2^20 \times 4` Bytes `=` 4MB 空间的一张页表来存储映射关系，这将会导致在运行的任务多起来的时候，内存空间大量被页表耗尽的情况发生。因此，针对这种情况，我们在一个任务内，再次进行切分，引入了 <font color="blue">页目录 (Page Directory Table, PDT)</font> 的概念。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;TODO：为什么不能设计动态扩大的页表。

  <div align="center">
    <img src="./pic/pdt.png" width=100%>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;引入页目录之后的映射机制是这样的：在一个任务中，首先我们把能容纳 1048576 条表项的页表拆分为 1024 张能容纳 1024 条表项的页表，然后我们再给出一个能容纳 1024 张页表起始物理地址的 <font color="blue">页目录 (Page Directory Table, PDT)</font>。有接着，如上图所示，当我们在 <b>线性地址空间</b> 给出一个 32-bits 的 <b>虚拟地址</b> 后，我们取其高 10-bits，作为页目录中的索引，我们从页目录中拿到页表的 <b>物理地址</b> 后，利用这个 <b>物理地址</b> 找到对应的页表，然后使用 <b>虚拟地址</b> 的中间 10-bits 作为页表中的索引，找到物理页的 <b>起始物理地址</b>。我们使用这个物理页的 <b>起始物理地址</b> 找到对应的物理页后，利用 <b>虚拟地址</b> 的最后 12-bits 作为页内的偏移值，就能最终得到我们要访问的内存单元的 <b>物理地址</b> 了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;读者会提问：处理器如何知道一个任务的 PDT 所处的位置的呢？回忆我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_10_Task_And_Privilege/index.html#1_task_4">TSS (Task State Segment)</a> 中展示过的一个任务的 TSS 的结构，里面有一个 32-bits 的 "CR3(PDTR)" 域，这个域就是用于存储一个任务对应的 PDT 的 <b>起始物理地址</b> 的，它对应了处理器的 CR3 寄存器。每当处理器加载一个任务的时候，它就会把 CR3 寄存器指向对应任务的 页目录 的位置，CR3 寄存器的格式如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td width="4%">长度</td>
      <td width="60%"><div align="center">20b</div></td>
      <td width="21%">7b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="9%">3b</td>
    </tr>
    <tr>
      <td width="4%">含义</td>
      <td width="60%"><div align="center"><b>页目录</b> 起始物理地址的高 20-bits</div></td>
      <td width="21%">NOT USED</td>
      <td width="3%">PCD</td>
      <td width="3%">PWT</td>
      <td width="9%">NOT USED</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于页目录表大小为 `1024\times4` Bytes `=` 4KB，因此它最后被安装到内存中的时候必然位于一个物理页中，因此其物理基地址的低 12-bits 将为全零。处理器的设计者认为既然如此，在 CR3 寄存器中只需登记它的高 20-bits 地址即可。至于低 12-bits，我们暂时略过不研究。  

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在理解了 页目录 和 页表 的关系以及新的 <b>线性地址空间</b> -> <b>物理地址空间</b> 映射方式后，让我们来看 页目录项 和 页表项 的具体格式。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于页目录来说，它的表项对应的是某个页表的 <b>起始物理地址</b>，但是由于我们现在一个页表是 `1024\times32` bits `=` 4KB，刚好塞在一个物理页中，实际上一个页表确实也是完整地塞在一个物理页中的，所以我们要定位一个页表，使用高 20-bits 就可以了。页目录的表项确实如此，但是页目录的表项长度是 32-bits，这是因为它使用了剩余的 12-bits 来表示对应页表的属性情况。页目录表项格式如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td width="4%">长度</td>
      <td width="60%"><div align="center">20b</div></td>
      <td width="9%">3b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
    </tr>
    <tr>
      <td width="4%">含义</td>
      <td width="60%"><div align="center"><b>页表</b> 起始物理地址的高 20-bits</div></td>
      <td width="9%">AVL</td>
      <td width="3%">G</td>
      <td width="3%">0</td>
      <td width="3%">D</td>
      <td width="3%">A</td>
      <td width="3%">PCD</td>
      <td width="3%">PWT</td>
      <td width="3%">US</td>
      <td width="3%">RW</td>
      <td width="3%">P</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于 页表项，也是同样的道理，它本身就是用来定位 4KB 物理页的，所以它也只使用了 20-bits 来定位，剩下的 12-bits 用来标识一个物理页的属性，其格式如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td width="4%">长度</td>
      <td width="60%"><div align="center">20b</div></td>
      <td width="9%">3b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
    </tr>
    <tr>
      <td width="4%">含义</td>
      <td width="60%"><div align="center"><b>物理页</b> 起始物理地址的高 20-bits</div></td>
      <td width="9%">AVL</td>
      <td width="3%">G</td>
      <td width="3%">0</td>
      <td width="3%">D</td>
      <td width="3%">A</td>
      <td width="3%">PCD</td>
      <td width="3%">PWT</td>
      <td width="3%">US</td>
      <td width="3%">RW</td>
      <td width="3%">P</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看出，页目录项 和 页表项 的格式十分类似，它们各个字段的含义如下所示：

  <ul>
    <li>P 位是存在位：为 1 时，表示页表或者页位于内存中；为 0 时，表示页表或者页不在内存中，需要予以创建/从磁盘调入内存后才能使用；</li>
    <li>RW 位是读写位：为 0 时表示这样的页只能读取；为 1 时，表示可读可写；</li>
    <li>US (User/Supervisor) 位是用户/管理位：为 0 表示允许所有特权级的程序访问；为 1 时表示不允许特权级为 3 的程序访问；</li>
    <li>PWT (Page-level Write-Through) 是页级通写位：与高速缓存机制有关；</li>
    <li>PCD (Page-level Cache Disable) 是页级高速缓存禁止位：用来间接决定该表项所指示的那个页是否使用高速缓存策略；</li>
    <li>A (Accessed) 是访问位：该位由处理器固件来设置，在一个页被访问的时候会被置为 1，清零的工作由操作系统来完成，可以用于统计一个页面的使用频次。当内存空间紧张时用以将使用次数较少的页面从磁盘换出到磁盘，并且把 P 位清零，然后把释放的页面分配给即将要运行的程序，以实现虚拟内存管理功能；</li>
    <li>D (Dirty) 是脏位：用来指示该表项对应的页是否写过数据；</li>
    <li>PAT (Page Attribute Table) 是页属性表支持位：与更复杂的分页系统和高速缓存有关；</li>
    <li>G (Global) 是全局位：用来指示一个页是否为全局性质的。如果一个页面是全局的，那么它将会一直在高速缓存中保存。因为页高速缓存容量有限，只能存放使用频繁的那些表项。另外，当因为任务切换等原因改变 CR3 寄存器的内容是，整个页高速缓存的内容都会被刷新；</li>
    <li>AVL 位被处理器忽略，软件可以使用</li>
  </ul>
</div>


<h2><a name="2_example">2. 段页式内存管理实例</a></h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;老规矩，我们先给出链接：<a href="./kernel.html">内核源代码</a> 和 <a href="./user.html">用户程序源代码</a>

  <h3><a name="2_example_1">2.1 开启分页机制</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;理解了上文所阐述的分页机制原理之后，在本节我们将关注如何在内核初始化代码中开启分页机制。我们会遵循上一篇文章的思路，在将内核程序创建为一个任务的过程中，开启分页机制。

  <div class="div_concurrent_img">
    <img src="./pic/initial_memory.png" width=200px>
    <img src="./pic/processed_memory.png" width=200px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上第一张图所示，这是我们在最开始进入内核程序的时候，低 1MB 的 <b>物理内存空间</b> 的分布情况。有读者会疑惑：我们的内核程序已经在开启分页机制之后被 MBR 直接装入物理内存中了。在开启分页机制之后，访问这部分物理内存需要经过 "段部件->页部件" 的处理，这就很麻烦了。因为按常理来说，我们会在加载一个任务的时候，是先利用页目录和页表处理好该任务的 <b>线性地址空间</b> 向 <b>物理地址空间</b> 的映射，然后再把各个段的内容放到对应的物理页上去；现在我们相当于反其道而行之，MBR 已经直接先把各个段的内容放到物理内存中了。解决这个问题的一个思路就是，在内核任务中使得在经过页部件之后输出的 <b>物理地址</b> 与输入的 <b>线性地址</b> 保持一致。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在有了策略之后，我们来看我们页表的放置规模和位置。由于我们的内核程序 (i.e. 包括内核代码段和内核数据段) 的整体占用 <b>物理内存空间</b> 不超过 <b>物理内存</b> 的低 1MB，而一张页表可以存储 1024 个页表项，也即指向 4MB 的 <b>物理内存</b>，所以我们使用一个页表就能 cover 内核的需求。如上第二张图所示，我们计划把内核任务的 页目录 放在起始地址在 0x00020000 的物理页中，把内核任务的唯一一张页表放在起始地址在 0x00021000 的物理页中。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;来看代码是怎么处理的。内核代码的入口在 Line 880 的位置。来到 Line 923~929 的位置，我们使用了一个 loop 将 0x00020000~0x00020FFF 的区域全部清空为 0，作为我们 PDT 的放置空间。将这段空间清 0 的原因是为了让各个 页目录项 的 P 位都置为 0。初始化完成后，在 Line 932，为了方便我们后面直接使用线性地址访问页目录，我们在页目录偏移为 4092 (i.e. 0xFFC，页目录最后一项) 的位置填入了 0x00020003，其实就是页目录本身的 <b>物理地址</b> <font color="red">(i.e. 这里比较特殊，填入的是页目录自身的物理地址，而不是页表的物理地址，这实际上是把页目录表当作页表在使用，值得注意！)</font>，并且 P=1，RW=1，US=0。注意到这将浪费 <b>虚拟内存</b> 的最高 4MB (i.e. 0xFFC00000~0xFFFFFFFF)，但是由于一般的程序都不会涉足到这么高的 <b>虚拟内存领域</b>，因此也就无关紧要。然后在 Line 935 中，我们创建了当前页目录中唯一的一条表项：与线性地址 0x00000000 对应的目录项，它指向了第一张页表所在的位置。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;完成 页目录 的初始化后，我们现在就可以向我们所需要的唯一的一张页表中写入物理页信息了。为了 cover 住 <b>物理地址空间</b> 的低 1MB 的内存空间，在这张页表中我们需要创建低位的 256 条页表项，如下图所示。在代码的 Line 941~948，我们向页表中填写了指向内存低 1MB 的表项：第 1 个页表项对应的是线性地址 0x00000000~0x00000FFFF，填写的内容是第一个页的 <b>起始物理地址</b> 0x00000000；第 2 个页表项对应的是线性地址 0x00010000~0x00001FFFF，填写的内容是第一个页的 <b>起始物理地址</b> 0x00010000；以此类推。值得注意的是，在 Line 944 的地方，我们在寻址的时候使用了倍率因子 "[es:ebx+esi<b><font color="red">*4</font></b>]"，这是 32 位处理器支持的功能，并且表达式的计算不再编译的时候进行，而是在指令执行的时候进行。

  <div align="center">
    <img src="./pic/low_1_m.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Line 950~954 的地方，我们把页表中的剩余表项目全部设置为无效。以避免出错。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Line 957~958 中，我们设置了 CR3 寄存器，使它指向我们当前已经初始化好的页目录。下面我们将正式开启页功能。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_8_Protect_Mode/index.html#2_load_protection_5">正式进入保护模式</a> 中曾经介绍过，我们把处理器切换成保护模式是通过设置 CR0 寄存器的 PE 位实现的。现在，为了开启处理器的分页功能，我们是通过设置 CR0 寄存器中的 <font color="blue">PG (Page)</font> 位实现的。在 Line 960~962，我们就是在干这样一件事情。从此，我们段部件输出的地址，都将只是一个 <b>线性地址</b>，还需要通过页部件的转换才能输出 <b>物理地址</b>。

  <h3><a name="2_example_2">2.2 全局空间和局部空间</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在，我们在初始化好内核并且开启分页机制后，我们下面的工作是加载一个用户程序并且创建一个任务。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在请读者思考一下用户任务内调用内核例程的问题。在分页机制开启之前，段部件输出的地址就是物理地址。只要用户程序的 <b>头部段</b> 中保存有相关调用门的选择子，我们就能够在满足特权级需求的前提下在用户任务中访问内核例程。现在，当我们在分页机制下，每一个任务都有一个属于自己的 <b>线性地址空间</b>，还有一个用于映射自己 <b>线性地址空间</b> 到 <b>物理地址空间</b> 的 页目录 和若干 页表。为了使能用户任务依然能正常访问内核例程，我们在 <a href="#1_segment_page_4_1">引入线性地址空间</a> 中提到过，对于每一个任务的 <b>线性地址空间</b>，我们将其分为了两部分。用户任务私有的程序应该被安装在 <b>线性地址空间</b> 的 <b>局部空间</b>，<b>全局空间</b> 用于安装各个任务之间共享的程序。在一个任务中，当给出一个 <b>局部空间</b> 的 <b>线性地址</b> 的时候，相关的页目录和页表项应该把它引导向保存有用户私有程序的页面上；当给出一个 <b>全局空间</b> 的 <b>线性地址</b> 的时候，相关的页目录和页表项应该把它引导向保存有全局共享程序的页面上。整体如下图所示。这样一来，在启用分页机制的背景下，我们同样能够使能在用户任务内从 局部地址空间 向 全局地址空间 转移的操作。

  <div align="center">
    <img src="./pic/local_global.png" width=600px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在本文的代码例子中，我们把 4GB 的 <b>线性地址空间</b> 分割为了各为 2GB 的 <b>局部地址空间</b> 和 <b>全局地址空间</b>。<b>全局地址空间</b> 占据着 <b>线性地址空间</b> 的高 2GB，即 <b>线性地址范围</b> 为 0x80000000~0xFFFFFFFF；<b>局部地址空间</b> 占据着 <b>线性地址空间</b> 的低 2GB，即 <b>线性地址范围</b> 为 0x00000000~0x7FFFFFFF。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这样一来，对于我们正在创建的内核任务本身，内核程序目前所处的 <b>线性地址</b> 是处于内存的低端位置，我们需要调整到 <b>线性地址空间</b> 的高端位置中，而对于真实的 <b>物理地址</b>，我们并不需要去修改。我们的计划是把内核程序调整到 <b>线性地址空间</b> 的 0x80000000 的起始位置，我们直接修改页目录的内容就可以了，不用修改页表的原因是因为我们修改的地址范围没有超出 <b>线性地址</b> 的高 10-bits。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在页机制已经被使能的背景下，为了修改页目录，我们需要给出的是页目录的线性地址。这里稍微有一点绕：为了访问页目录表，我们必须通过页目录表自身来进行访问。回顾我们在 <a href="#2_example_1">开启分页机制</a> 中，我们向页目录中偏移为 4092 的位置填入了页目录自身的物理地址，这样一来，如下图所示：当我们在 <b>线性地址</b> 的高 10-bits 中给出指向页目录第 4092 条表项的时候，我们就能够获得获得页目录的物理地址，接着就能够把页目录当作页表来使用；然后我们会在 <b>线性地址</b> 的中间 10-bits 再次给出第 4092 条表项的偏移量，这时候我们就能够 "在名义上" 正式获得页目录所在的物理页的物理地址；再利用我们在 <b>线性地址</b> 的低 12-bits 中给出的页内偏移地址，我们就能够访问页目录中我们想要修改的表项。

  <div align="center">
    <img src="./pic/pdt_explaination.png" width=600px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;不得不承认，这确实比较绕。不过我们观察到，当我们给出一个高 20-bits 都为 1 的 <b>线性地址</b> 时 (i.e. 0xFFFFFxxx)，我们其实访问的就是页目录本身，我们只需要把页目录内的偏移体现在低 12-bits 就可以了。回到我们的代码，在 Line 965 的位置，首先设置了线性地址的高 20-bits 的值，在 Line 966~968 的位置，我们计算出了我们想要修改的 <b>线性地址</b> 为 0x80000000 所对应的页目录表项的偏移量：首先将 0x80000000 右移 22 位，仅保留高 10-bits，然后将这高 10-bits 左移 2 位，相当于 `\times 4` (i.e. 一个页目录表项为 4 Bytes)。最后，在 Line 969 的位置，我们将我们在 Line 935 设置过的 "页目录项<->页表" 映射关系重新设置在了新的页目录项位置上。这样一来，我们就完成了页部件的映射关系，对以 0x80000000 为起始地址的 <b>线性地址空间</b> 的访问将能访问到内核相关程序。接下来，我们要做的工作是修改相关的段描述符，使得这些内核程序的段描述符的起始地址正确的处在新的高端 <b>线性地址空间</b> 中。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Line 973~986 的位置，我们在 GDT 中重新设置了内核程序各个段的起始地址：在 Line 973 我们使用了 sgdt 指令将 GDTR 寄存器中存储的 GDT 32-bits <b>线性基地址</b>和 16-bits 段边界存储到了 pgdt 标号所指示的内核数据段中的相应位置上。注意到此时的 32-bits GDT <b>线性基地址</b> 填写的还是 1MB 内的低端 <b>线性基地址</b>，我们在 Line 984 的位置修正了这个值至高端的线性空间中，最后在 Line 986 的地方将更新过后的 GDT 信息更新回了 GDTR 中。回到 Line 975，我们将从 GDTR 中读出的低端 <b>线性基地址</b> 暂时保存到了 ebx 寄存器中，然后在 Line 977~982 中我们修改了各个段描述符的段基地址。这样一来，我们就完成了对段部件输出的地址的修正。

  <div class="div_learning_post_background">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;综上的工作，我们把内核程序搬迁到了以 0x80000000 为起始地址的 <b>线性地址空间</b> 上。可以发现，在引入分页机制后，对于修改一个段在线性空间中的位置这件事情，我们一共有两个步骤：
    <ol>
      <li>修改相应页目录表项和页表表项中的内容，使得能够将新的 <b>线性空间地址</b> 映射到正确的物理页上</li>
      <li>修改 GDT/LDT 中的段描述符，使得段基地址处在正确的新的 <b>线性空间基地址</b> 上</li>
    </ol>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里有一个小细节：我们在修改 GDTR 以及 GDT 中的段描述符的时候，是不会影响程序正常的对内存的访问的，原因是因为处理器只有在 "引用" 一个段的时候，才会去访问 GDT 中存储的描述符，其余时候访问内存使用的都是段描述符高速缓存器中的内容。因此我们上文在修改 GDTR 以及 GDT 中的内容的时候，是不会导致故障发生的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当我们完成段部件和页部件的修正后，我们在 Line 988 的地方使用了 jmp 指令，刷新了 CS 寄存器的描述符高速缓存器中的内容，切换为我们刚刚更新的高端地址。同样的，在 Line 991~992 & Line 994~995 的位置，我们重新装载了 DS 和 SS 寄存器描述符高速缓存器的内容。这样一来，我们就正式把内核的程序移到了内核任务中 <b>线性地址空间</b> 的高端的位置上了。

  <h3><a name="2_example_3">2.3 创建内核任务</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;事实上，到目前为止，我们还没有像我们在上一篇文章中做的那样 —— 将我们的内核程序创建为一个任务。为了创建我们的内核任务，经过前几篇文章的叙述，我们知道最重要的就是要创建出对应于内核任务的 TSS 结构。然而，在本文中，我们已经使能了分页机制。因此，在分页机制下为一个任务分配内存区域的工作不在仅仅局限于 <font color="blue">"段部件-><b>物理地址空间</b>"</font> 上的操作，而是应该考虑 <font color="blue">"段部件-><b>线性地址空间</b>->页部件-><b>物理地址空间</b>"</font> 的流程。因此，我们下面将以为内核任务创建 TSS 这个场景，来展示我们是如何在分页机制下为任务分配内存空间的，在分配好内存空间后，我们将创建内核任务的 TSS 结构，由此完成对内核任务的创建。

  <h5><a name="2_example_3_1">(1) 分页机制下的虚拟空间分配</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们现在要应对的有 <b>线性地址空间</b> 和 <b>物理地址空间</b> 的内存分配。下面我们来看我们在代码中是如何进行实现的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 <b>线性地址空间</b> 上，我们在内核数据段 Line 525 的位置声明了一个标号 core_next_laddr，用于存储内核空间中下一个可分配的线性地址。在完成一次 <b>线性地址空间内存</b> 的分配后，这个标号 core_next_laddr 所存储的值将会被更新为连续的下一个可以被用于分配的 <b>线性地址空间地址</b>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;而对于 <b>物理地址空间</b> 来说，来到内核代码段的 Line 1022~2024，我们拿到标号 core_next_laddr 位置所存储的 <b>线性地址空间地址</b> ，并且将其存储在 ebx 寄存器后，我们会调用内核例程 alloc_inst_a_page 为我们找到一个可用的物理页，并且安装在我们想要填写的 <b>线性空间地址</b> 对应的页目录项和页表项中。例程 alloc_inst_a_page 是在 Line 354 定义的，下面我们对该过程的逻辑进行分析。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;首先，alloc_inst_a_page 会检查与目标线性地址对应的页目录表项是否存在：在 Line 366，我们把目标线性地址做了一份拷贝，存储在 esi 寄存器中；Line 367 保留了目标线性地址的高 10 位，其它各位清零；Line 368 相当于做了 "shr esi, 22" 和 "shl esi, 2" 两步，首先是将高 10 位移到了最低的位置，然后又乘以 4，这样相当于算出了目标线性地址在页目录表项中的偏移量。Line 369 复用了我们在 <a href="2_example_2">全局空间和局部空间</a> 中得到的结论：在分页机制下给出 "0xFFFFFxxx" 的线性地址就可以访问页目录的表项。因此，我们把我们的偏移量和 0xFFFFF000 相或，就在 esi 寄存器中得到了我们能够用于最终访问目的页目录表项的线性地址。在 Line 371，我们检查了对应页目录表项的 P 位：为 1 代表对应的页表已经存在；为 0 说明对应的页表尚未被创建。如果页表尚未被创建，我们就会执行 Line 375~377 的代码，其中会调用到 allocate_a_4k_page 过程，以分配得到一个 4KB 的物理页作为页表，然后把这个页表的物理地址登记到对应的页表项中。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在关注 allocate_a_4k_page 过程之前，我们先来看我们是怎么找到一个空闲的物理页的。假设我们在 32 位机上真的拥有了 4GB 的物理内存，那么我们将拥有 `2^20`=1048576 个物理页。简单起见，我们可以设置以 1 个 bit 对应一个物理页的方式，来记录一个物理页是否空闲。这样一来，我们就需要在内核数据段中设置 1048576=128KB 的 <font color="blue">页映射位串</font>。比特在位串中的位置，决定了它所映射的页在哪里。位 0 对应的是物理地址为 0x00000000 的页；位 1 对应的是物理地址为 0x00001000 的页，以此类推。理论上来说，我们应该能在内存条上的某个 ROM 上读取到总的物理内存大小，以方便内核分配相应大小的页映射位串空间，但是在本文展示的代码中，我们没有这么做，我们简单地假设我们只有 2MB 的内存可用，因此我们一共拥有 512 个物理页可用，因此就只需要 512 bits 的页映射位串。在 Line 461 所对应的内核程序数据段的标号为 page_bit_map 的位置上，我们定义了 512 bits = 64 Bytes 的区域，用于存储页映射位串。观察已经初始化好的值：前 32 字节所对应的页映射位串，对应了低端 1MB 物理内存的页，这些分页已经被用于存储内核程序，因此它们被初始化为 0xFF 的值。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;来看 allocate_a_4k_page 过程，在 Line 333~337 中，我们尝试找到页映射位串中的一个尚未被置位的比特。在 Line 333 中，我们使用了 <font color="blue">bts (bit test and set)</font> 指令。该指令的作用是测试目的操作数中某个偏移位置的比特：取出该比特赋值给 EFLAGS 寄存器的 CF 位，然后将该比特置位。当我们找出这样一个空闲的比特位后，我们就跳转到了 Line 343 的 .b2 标号处，我们将该物理页的标号乘以 4KB，我们在 eax 寄存器中就得到了实际的物理页的物理地址，这样一来，我们就成功地在物理内存中找到了一个空闲的页。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们的初衷是把这个物理页当作一个页表来使用，因此接下来的工作是把这个物理页相关的信息填写到页目录中。在 allocate_a_4k_page 过程返回后，来到 Line 391，我们在保留 eax 的高 20-bits 物理地址的情况下，在低 12-bits 上或上了 0x00000007 的值，这个值也即该页表的属性。这个属性代表了：US=1, RW=1, P=1。为什么把 US 设置为 1，也即允许特权级为 3 的程序来访问这个页呢？原因是 alloc_inst_a_page 这个例程既会被用于为内核任务分配页面，也会被用于为用户任务分配页面。为了不复杂化代码，我们就统一把页目录表项的 US 字段统统设置为 1。然后在 Line 377 中，我们将其登记在了页目录相应的表项中。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;完成了页表在页目录的登记之后，我们就要着手物理页在页表中的登记了。其实逻辑很简单，无非就是再找一个空闲的物理页，然后根据我们给出的目的线性地址，把它登记在相应的页表项中。但是，又来了，在分页机制开启的条件下，我们要访问页表，本身就得通过页表来访问。因此如何访问到页表，是我们这一步的关键。

  <div align="center">
    <img src="./pic/pdt_explaination_2.png" width=600px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;为了访问到页表，我们需要给出一个线性地址，这个线性地址 <font color="blue">把页表当成物理页，把页目录表当成页表</font>。因此，如上图所示，和我们在上面访问页目录本身使用一样的逻辑，我们首先将线性地址的高 10-bits 设置为在页目录中找到最后一个表项，也即指向页目录本身，以此把页目录表当成页表；然后把中间 10-bits 设置为指向我们上面刚刚添加到页目录表的，指向我们的页表的页目录表项，也即把页表当成物理页；最后在低 12-bits 给出页表内的偏移，我们就能够访问我们刚刚创建的页表了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;回到我们的代码，我们在 Line 380~384 的地方组合出了我们上面所述的，对应着能够访问到最终页表物理页的线性起始地址，我们将它放在 esi 寄存器中；在 ebx 寄存器中则存放着调用 alloc_inst_a_page 过程时传入的要为其分配页目录/页表项的线性地址，我们在 Line 387 中保留了中间的 10-bits，然后在 Line 388 中右移了 10-bits (i.e. 相当于先右移 12 bits，把中间 10 bits 搬到低位，然后再左移 2 bits，相当于乘以 4，也即一个页表项的长度)，我们在 ebx 中就获得了目的页表项在页表中的偏移量，我们在 Line 391 将这个偏移量和上面拿到的线性起始地址一相与，就获得了最终我们能用于访问目的页表项的线性地址。我们在 Line 390 调用了 allocate_a_4k_page 拿到了一个空闲的物理页，然后在 Line 391 设置了该物理页对应的页表项，在 Line 392 将该条页表项存入了页表中。

  <h5><a name="2_example_3_2">(2) 创建 TSS</a></h5>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在完成页部件的各项准备工作后，alloc_inst_a_page 过程就返回了。下面我们就可以开始在我们创建的空间上安排 TSS 的相关内容了。来到代码的 Line 1027~1034 的位置，我们在这里填写了 TSS 的各项静态内容，在 Line 1037~1042，我们在 GDT 中为我们刚刚创建的 TSS 创建了描述符，在Line 1046 的地方，我们把 TSS 的描述符传递到 TR 寄存器中，此时我们就完成了内核任务的创建，并且进入到了内核任务中。

  <h3><a name="2_example_4">2.4 创建一个用户任务</a></h3>

  <h5><a name="2_example_4_1">(1) 多段模型 与 平坦模型</a></h5>

  <div class="div_concurrent_img">
    <img src="./pic/multi_segment_1.png" width=400px>
    <img src="./pic/multi_segment_2.png" width=400px>
    <img src="./pic/multi_segment_3.png" width=400px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上第一个图所示，我们在启用分页机制之前，我们会将我们分段的程序安装到物理内存中空闲的连续的空间中，并在 GDT/LDT 中登记相关的段描述符，以此来对这些段发起访问；在使能分页机制后，基于我们上面的理解，如上第二张图所示，我们是在一个线性地址空间中安装我们的段，然后再利用页目录/页表来将我们的线性地址空间映射到物理地址空间上去。我们把上面两种情况称作为 <font color="blue">多段模型 (Multi-Segment Model)</font>。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;分段最开始的 Motivtaion 是用于解决 16 位处理器对 1M 内存的访问的问题，并且在 32 位处理器还依然保持分段模型的很重要的原因就是它可以为我们提供特权级保护机制，这使得在一个任务内部，程序之间的访问的合法性可以被保证。在引入分页机制之后，我们发现分段和分页机制在一定程度上加重了编译器生成用户程序的复杂程度，我们其实完全没有必要把程序在线性地址空间中分散成好几个段来进行管理。如今的主流操作系统更 prefer 的是 <font color="blue">平坦模型 (Flat  Model)</font>，也即整个任务只使用一个段，相应地，在切换到一个任务上去执行时，CS、DS、ES 和 SS 等段基址寄存器指向的都是同样的段基址，段界限也是一样的，不同的是它们对于这段线性地址空间的各种属性。这样一来，通过单段分页的机制，我们的系统同样能够很好地把程序分散在物理内存中的不同位置中，并且实现特权级保护等功能。

  <h5><a name="2_example_4_2">(2) 加载用户程序</a></h5>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;来到代码中，首先我们会创建任务对应的 TCB。读者应该意识到，在分页机制的背景下，一个用户任务的 TCB 应该被存储在内核的线性地址空间中，因为如果是在用户任务的线性地址空间中，那么内核任务中将不会有相应的页目录项和页表项，自然也就无法对 TCB 进行访问。Line 1051~1053 在内核任务的线性地址空间中分配 4KB 的空间，然后在 Line 1065~1058，我们完成了用户任务 TCB 内容的填写，我们本文所涉及到的 TCB 的格式如下所示：

  <div align="center">
    <img src="./pic/tcb.png" width=400px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在创建完 TCB 后，下一步就是调用 load_relocate_program 过程来加载用户任务了。这里涉及一个问题：当内核任务在加载一个用户程序的时候，它需要帮助用户任务把程序在用户任务自己的线性地址空间中进行安装。在分页机制的背景下，势必也需要帮助这个用户任务创建相应的页目录。问题是：处在内核任务中，如何访问得到用户任务的页目录呢？采用我们上面投机取巧的，在页目录最后一条表项中填入页目录本身，来访问页目录的方法不可能使用到用户任务上。解决办法可以是：我们可以暂时先复用内核任务正在使用的页目录。为什么可以复用？原因是内核程序本身存在于线性地址空间的高 2GB 的区间中，而我们前面约定用户程序会被安装到线性地址空间的低 2GB 区间中，所以我们可以先复用内核任务的页目录，先把用户程序安装到物理页中，创建好相应的页目录表项和页表。完成之后，我们再把内核任务的页目录 copy 一份。这样一来，我们既不会影响内核任务的正常运行，又可以创建出用户任务的页目录来，一举两得。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;说到这里，读者可以思考一下，TCB 到底有什么意义。回忆我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_10_Task_And_Privilege/index.html#3_example_2_1">任务控制块 (Task Control Block, TCB)</a> 中讨论的 TCB 的内容于其格式，在引入分页机制之前，读者可能会疑惑：TCB 的意义究竟是什么呢？它其中记录的一部分内容，都已经在 TSS 中有所记录了，似乎 TCB 的记录是多此一举。答案是：在引入分页机制后，当内核在加载一个用户任务的时候，由于还没有切换到用户任务中，所以内核任务不可能真正的在用户任务的线性地址空间中安装相关的程序，但是它又必须得干这个事情，所以内核任务就引入了 TCB。TCB 被用于在内核任务加载用户程序的阶段，记录像 LDT、各级堆栈等等这些最终会被安装到用户任务私有线性地址空间中的段的基地址、段界限的信息。在依次创建各个私有线性地址空间段时，TCB 还会被用于记录可被分配的线性地址空间。在这个过程中，正如我们上面所述的，内核任务同时会帮助用户程序填写页目录中的各条表项的内容。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在理解之后，让我们来看代码中是怎么处理的。load_relocate_program 过程定义在了 Line 577 的地方，在 Line 592~598 的地方，我们清空了当前内核任务使用的页目录的对应低 2GB 线性地址的表项。清空的原因是我们希望复制到用户任务页目录的时候，这部分是留给用户任务使用的。如代码所示，我们一共处理了 512 条页目录表项。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Line 601~614，我们通过读取程序头部的第一个字节，拿到了程序一共的长度信息，然后将其 Cast 为 4KB 对齐的形式，这样我们就得到了 4KB 对齐下程序需要使用的线性内存空间。在 Line 616~617，我们通过将线性内存空间除以 4096，就得到了这个程序需要占用的物理页的个数。在 Line 624~637，我们设计了一个嵌套循环：外循环负责为用户任务分配 4KB 物理页，内循环负责从磁盘读取用户程序，放置到相应的区域。一次外循环对应八次内循环，这是因为一次外循环能分配 4KB 的物理页，而一次内循环只能从磁盘中读取一个扇区的内容，也即 512B，因此需要读 8 次才能将一个物理页面填满。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在传统的多段模型中，由于将程序进行了分段，所以不论我们将程序安装在线性地址空间中的什么位置，我们都可以实现对程序的重定位；在平坦模型下，由于各个段基地址寄存器都指向了 0x00000000 的线性地址空间的起始位置，所以我们在安装程序的时候就需要将其安装在以 0x00000000 为起始地址的位置，而不能随意选择安装位置，这个值得注意。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Line 640~648 完成了在内核线性地址空间中对用户程序 TSS 的创建，并且将相关信息登记到了 TCB 中；Line 651~654 完成了在用户私有线性地址空间中的 LDT 的创建；Line 657~681 完成了用户任务代码段和数据段的描述符在 LDT 中的创建：它们都以 0x00000000 为基地址，4KB 为粒度，4GB 为段界限，不同的是段的 "代码段/数据段" 属性。它们分别对应了 CS 寄存器和 DS、ES、FS、GS 寄存器中加载的值。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Line 684~691 创建了用户任务的固有 3 特权级堆栈，大小为 4KB。Line 684 首先从 TCB 中获取了线性地址空间中下一个可以被使用的线性地址，然后调用了 alloc_inst_a_page 过程，分配一个相应的物理页，并且创建相应的页目录表项和页表。最后再把 SS 和 ESP 的值填充到 TSS 中：值得注意的是，SS 寄存器选择子复用了上面我们创建数据段描述符时使用的选择子；由于初始状态栈空，所以 ESP 寄存器指向了 TCB 中记录的下一个可以被分配的线性地址。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Line 693~745 创建了 0、1、2 特权级的堆栈，不再赘述。在安装完成后，用户私有地址空间的安装情况如下所示：

  <div align="center">
    <img src="./pic/user_task.png" width=400px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;Line 749~790 替换了用户程序 “内核例程名称 <-> 调用门” 的映射表，Line 793~799 将 LDT 的描述符安装到了 GDT 中，Line 801~816 填充了 TSS 中剩余的字段，Line 819~824 在 GDT 中安装了 TSS 的描述符。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;最后，我们需要把我们借用的内核页目录拷贝一份出来，作为真正的用户任务页目录。我们调用的是 create_copy_cur_pdi 例程。这个例程是在 Line 402 被定义的：我们首先在 Line 416 调用了 allocate_a_4k_page，拿到了一个物理页面，其物理地址被存储在 eax 寄存器中。为了让我们在后续能够访问到该物理页，我们需要将它的物理地址登记到当前的页目录中去。Line 418 组合出了相应的页目录表项，注意到我们将该页目录表项的属性设置为了 US=1、RW=1 和 P=1。Line 419 我们将它安装到了页目录中，此处我们又复用了 <a href="2_example_2">全局空间和局部空间</a> 中的结论：当我们给出 "0xFFFFFxxx" 的线性地址时，我们就可以访问到页目录自身，代码中给出的地址是 0xFFFFFFF8，也即把刚才创建好的页目录扔到了页目录的倒数第二条表项中去。在 Line 421，我们把当前内核任务的页目录自身的线性地址 0xFFFFF000 放到了 esi 寄存器中，在 Line 422 把用户任务的页目录线性地址放到了 edi 寄存器中，然后将循环拷贝次数在 ecx 中设置为 1024 次 (i.e. 一次传送一个双字，即一条页目录表项)，Line 424 设置了拷贝的方向，Line 425 发起拷贝。在拷贝完成之后，我们就从 create_copy_cur_pdi 例程中返回了。在返回后，Line 829~830 中，我们把我们创建好的页目录的物理地址填写到了 TSS 中。这样一来，我们的用户任务就算加载完成了。在开启分页机制的多任务背景下，我们现在的系统设置如下图所示：

  <div align="center">
    <img src="./pic/page_model.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在任务加载完成后，回到位于 Line 1068 的主程序，我们在使用 call 指令进行了任务切换后，我们就切换到了用户任务中了，内核程序的工作也就结束了。
</div>

<!--ref-->
<!--
<h2>附录：参考源</h2>
<div class="div_learning_post">
<p>

1. golang.org, <a target="_blank" rel="noopener" href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable">GOPATH environment variable</a>
</p>
</div>-->

</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/">TECH_OS_AND_LINUX_KERNEL</a></li>
          <li>X86_ISA_12_PAGE</li>
        
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.weibo.com/u/2861056530" title="Weibo → https:&#x2F;&#x2F;www.weibo.com&#x2F;u&#x2F;2861056530" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/HwangZobin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;HwangZobin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021044371号 </a>
  </div>

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-guitar"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'y8LMT8RtOsi4JsbYHtNm2J7U-gzGzoHsz',
      appKey     : 'Q0cSe4rR8Iwr0Gs60rwWBsYa',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
