[{"post_class":"system-knowledge","post_class_tag":"Technical Posts","modules":[{"post_module_name":"Linux 内核相关","post_module_url_prefix":"Linux_Kernel","posts":[{"post_name_url":"RCU/index.html","external_link":"","post_title":"Read-Copy Update (RCU) 同步机制","post_brief":"分析了针对读多写少场景进行优化的同步机制 Read-Copy Update (RCU)","keyword":["linux","内核","kernel","中断","同步","synchronization","rcu"]},{"post_name_url":"Network_Packet_Driver_Recv/index.html","external_link":"","post_title":"Linux 驱动收包流程","post_brief":"结合源码，介绍了数据包在进入内核协议栈处理之前，底层的驱动收包流程","origin":true,"keyword":["linux","kernel","interrrupt","network","napi","packet","skb","driver","module","recv","receive"]}]},{"post_module_name":"x86 指令集架构","post_module_url_prefix":"x86_ISA","posts":[{"post_name_url":"2_Computer_Arch/index.html","external_link":"","post_title":"学习汇编之前需要理解的计算机组成原理","post_brief":"为了能够使用汇编程序操作各种计算机底层原理，我们在开始分析汇编程序之前必须先理解一些基础的计算机底层的原理","keyword":["汇编语言","底层","架构","磁盘","内存映射","BIOS","MBR"]},{"post_name_url":"3_How_CPU_Execute/index.html","external_link":"","post_title":"CPU 是如何与内存和外围设备交互的？程序又是如何运行的？","post_brief":"详细学习了 CPU 与内存交互、运行指令、读取数据 和 访问 I/O 设备寄存器的原理和方法","keyword":["汇编语言","指令集架构","实模式","指令","I/O","内存访问","外设访问","寄存器","16位"]},{"post_name_url":"4_Segment/index.html","external_link":"","post_title":"再谈分段：为了内存重定位","post_brief":"从程序在内存中实现重定位的角度出发，描述将程序进行分段的 Motivation","keyword":["汇编语言","指令集架构","内存分段","实模式","16位"]},{"post_name_url":"5_Internal_Interrupt/index.html","external_link":"","post_title":"内中断","post_brief":"理解 8086 CPU 中的内中断原理以及相关指令","keyword":["汇编语言","指令集架构","实模式","中断","16位"]},{"post_name_url":"6_Outside_Interrupt/index.html","external_link":"","post_title":"外中断","post_brief":"理解 8086 CPU 中的外中断原理以及相关指令","keyword":["汇编语言","指令集架构","实模式","中断","16位"]},{"post_name_url":"7_Intel_32_CPU_And_IA_32/index.html","external_link":"","post_title":"Intel 32 位处理器以及 IS-32 指令集架构","post_brief":"在指令集架构的层面上，介绍了 Intel 32 处理器的内部资源，以及相关的 IA-32 指令","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","寄存器"]},{"post_name_url":"8_Protect_Mode/index.html","external_link":"","post_title":"Intel 32 位处理器保护模式","post_brief":"介绍了 32 位处理器从实模式跑向保护模式的详细过程，并且介绍了处理器在保护模式下对访问内存和修改寄存器等操作所进行的保护","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","MBR","选择子","寄存器","GDT","描述符"]},{"post_name_url":"9_Simple_Kernel/index.html","external_link":"","post_title":"引导加载并运行一个简单的内核","post_brief":"使用了一个具体的例子，演示了从 MBR 到内核，再到用户程序的过程","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","寄存器","MBR","内核","描述符","选择子","GDT"]},{"post_name_url":"10_Task_And_Privilege/index.html","external_link":"","post_title":"任务和特权级别","post_brief":"深刻剖析了 32 位处理器的特权级机制，演示了在特权级和多任务背景下加载任务的全过程","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","寄存器","MBR","内核","任务","特权","描述符","选择子","内核","GDT","GDTR","TSS","LDT","LDTR","TR"]},{"post_name_url":"11_Task_Switch/index.html","external_link":"","post_title":"任务切换","post_brief":"分析了 32 位处理器进行任务切换的具体过程","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","寄存器","MBR","内核","任务","特权","描述符","选择子","GDT","GDTR","TSS","LDT","LDTR","TR","任务切换"]},{"post_name_url":"12_Page/index.html","external_link":"","post_title":"分页机制和动态页面分配","post_brief":"分析了处理器基于分页机制的内存访问方法；","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","寄存器","内核","任务","特权","描述符","选择子","GDT","GDTR","TSS","LDT","LDTR","TR","任务切换","分页","平坦","多段"]},{"post_name_url":"13_Interrupt/index.html","external_link":"","post_title":"中断和异常的处理与抢占式多任务","post_brief":"介绍了 32 位处理器的中断和异常机制","keyword":["汇编语言","指令集架构","保护模式","指令集架构","32位","IA-32","指令","内存访问","寄存器","内核","任务","特权","描述符","选择子","GDT","GDTR","TSS","LDT","LDTR","中断门","任务门","陷阱门","IDT","IDTR","任务切换","中断","异常"]}]},{"post_module_name":"x86 硬件平台","post_module_url_prefix":"x86_HW","posts":[{"post_name_url":"Interrupt/index.html","external_link":"","post_title":"x86 硬件平台中断机制自底向顶理解","post_brief":"自底向顶介绍了 x86 平台下中断机制","origin":true,"keyword":["linux","kernel","interrrupt","x86","apic","irq","中断","内核"]}]},{"post_module_name":"ARM 指令集架构","post_module_url_prefix":"ARM_ISA","posts":[{"post_name_url":"ARM_concept_and_version/index.html","external_link":"","post_title":"ARM 的概念与版本","post_brief":"这篇文章为读者区分了 ARM 指令集和 ARM 处理器的概念","origin":true,"keyword":["arm","arch","version","版本","64","32","isa","处理器","cpu"]}]},{"post_module_name":"CUDA","post_module_url_prefix":"CUDA","post_module_label":"cuda","posts":[{"post_name_url":"Profiling/index.html","external_link":"","post_title":"CUDA Profiling","post_brief":"介绍了如和基于 NVIDIA Nsight System 和 Nsight Compute 完成对 GPU 系统性能的 Profiling","origin":true,"keyword":["nvidia","cuda","nsight","compute","system","profile","profiling","gpu","performance","系统"]},{"post_name_url":"1_Vector_Addition/index.html","external_link":"","post_title":"Vector Addition","post_brief":"基于向量加法的例子作为 CUDA programming 的入门","origin":true,"keyword":["cuda","gpu","gpgpu","programming","编程","并行"]},{"post_name_url":"2_Matrix_Multiplication/index.html","external_link":"","post_title":"Matrix Multiplication","post_brief":"介绍了如何基于 CUDA 实现矩阵乘法","origin":true,"keyword":["matrix","multiplication","multiply","矩阵","乘法","cuda","tile","tiling"]},{"post_name_url":"Memory_Management/index.html","external_link":"","post_title":"CUDA 内存管理","post_brief":"介绍了 CUDA 内存管理的集中方式，包括 Pageable Memory, Pinned Memory, UVA 和 UMA 等","origin":true,"keyword":["cuda","memory","manage","内存","管理","page","pin","uva","uma"]},{"post_name_url":"NVCC_Compilation/index.html","external_link":"","post_title":"简单理解 nvcc 编译过程","post_brief":"记录了对 nvcc 编译过程的学习","origin":true,"date":"Sept.13, 2023","language":"cn","keyword":["nvcc","gpu","cuda","compiler","compile"]}]}]},{"post_class":"non-archived-knowledge","post_class_tag":"Non-archived Posts","modules":[{"post_module_name":"未归档文章","post_module_url_prefix":"Non_Archived","posts":[{"post_name_url":"Segment_And_Section/index.html","external_link":"","post_title":"Section 与 Segment：从 链接器 到 Runtime 的角度出发","post_brief":"简单分析了 Section (节) 和 Segment (段) 的区别，很多情况下它们被混为一谈，以至于造成混淆","keyword":["gcc","汇编","section","segment","elf","目标文件","链接","节","段"]}]}]}]