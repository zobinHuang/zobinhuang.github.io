<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Exo 2:300,300italic,400,400italic,700,700italic|Caveat:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zobinhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":180,"display":"post","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:type" content="website">
<meta property="og:title" content="Intel 32 位处理器保护模式">
<meta property="og:url" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/index.html">
<meta property="og:site_name" content="Zobin">
<meta property="og:description" content="img{margin-left: 20px; margin-right: 20px;}     #table th{text-align:center;}     #table td{text-align:center;}     p{margin-left: 15px; margin-right: 15px;}     .div_concurrent_img{padding: 10p">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/xxx.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/gdt.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/segment_length.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/gdt.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/a20_1.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/a20_2.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/protection_segment_reg.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/load_selector.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/protection_mode_memory_access.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/protection_mode_load_instruction.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/protection_mode_stack.png">
<meta property="og:image" content="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/pic/protection_mode_stack_2.png">
<meta property="article:published_time" content="2022-02-10T14:39:11.128Z">
<meta property="article:modified_time" content="2021-11-02T02:35:32.000Z">
<meta property="article:author" content="Zhuobin Huang">
<meta property="article:tag" content="Zobin">
<meta property="article:tag" content="黄卓彬">
<meta property="article:tag" content="zobinHuang">
<meta property="article:tag" content="网络工程">
<meta property="article:tag" content="Networking Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png">

<link rel="canonical" href="https://zobinhuang.github.io/sec_learning/Tech_OS_And_Linux_Kernel/x86_ISA_8_Protect_Mode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Intel 32 位处理器保护模式 | Zobin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Zobin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zobin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lovin' Tech with Tea</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about-me-(关于我)">

    <a href="/sec_about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me (关于我)</a>

  </li>
        <li class="menu-item menu-item-library-(知识库)">

    <a href="/sec_learning/" rel="section"><i class="fa fa-duotone fa-book fa-fw"></i>Library (知识库)</a>

  </li>
        <li class="menu-item menu-item-music-(独立音乐人)">

    <a href="/sec_music/" rel="section"><i class="fa fa-music fa-fw"></i>Music (独立音乐人)</a>

  </li>
        <li class="menu-item menu-item-thoughts-(想法)">

    <a href="/sec_thoughts/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Thoughts (想法)</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Intel 32 位处理器保护模式
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/">TECH_OS_AND_LINUX_KERNEL</a></li>
          <li>X86_ISA_8_PROTECT_MODE</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <head>
<style>
    img{margin-left: 20px; margin-right: 20px;}
    #table th{text-align:center;}
    #table td{text-align:center;}
    p{margin-left: 15px; margin-right: 15px;}
    .div_concurrent_img{padding: 10px 10px; display: flex; align-items:center; justify-content:center;}
    @media(max-width: 768px) {
      .div_concurrent_img{flex-direction: column;}
    }
    .div_catalogue{padding: 10px 10px; font-size: 16px; background-color: #E0E0E0; word-spacing:0px;  border:1px solid black; border-radius: 10px;}
    .div_licence{font-size: 16px; word-spacing:0px; border:1px solid black;}
    .div_learning_post{font-size: 16px; word-spacing:0px;}
    .div_indicate_source{font-size: 18px; word-spacing:0px; background-color: #E0E0E0;}
    .div_learning_post_boder{
      background-color:#E3E2E2;
      padding: 10px 10px; 
      font-size: 16px;
      word-spacing:0px;  
      border-radius: 15px;
      padding: 8px;
      margin-bottom: 5px;
    }
    .div_learning_post_boder p{
      margin: 0px;
    }
</style>

<!--支持网页公式显示-->    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
<!--支持矩阵显示-->
<script type="text/javascript">
  run_maths = function() {
    if (document.querySelector('[class*="cmath"]') !== null) {
      if (typeof (mjax_path)=='undefined') { mjax_path='https://cdn.jsdelivr.net/npm/mathjax@2'; }
      if (typeof (mjax_config)=='undefined') { mjax_config='AM_CHTML'; }
      smjax = document.createElement ('script');
      smjax.setAttribute('src',`${mjax_path}/MathJax.js?config=${mjax_config}`);
      smjax.setAttribute('async',true);
      document.getElementsByTagName('head')[0].appendChild(smjax);
    }
  };
  if (document.readyState === 'loading') {  
    window.addEventListener('DOMContentLoaded', run_maths); 
  } else { 
    run_maths(); 
  }
</script>
</head>

<body>

<div align="center" class="div_indicate_source">
  <h4>⚠ 转载请注明出处：<font color="red"><i>作者：ZobinHuang，更新日期：Aug.11 2021</i></font></h4>
</div>

<div class="div_licence">
  <br>
  <div align="center">
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0; margin-left: 20px; margin-right: 20px;" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
  </div>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由 <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><b>ZobinHuang</b></span> 采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><font color="red">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</font></a> 进行许可，在进行使用或分享前请查看权限要求。若发现侵权行为，会采取法律手段维护作者正当合法权益，谢谢配合。
  </p>
</div>

<!--表格-->
<!--
<table border="1" align="center" bgcolor="#FFFFFF">
  <caption>表格</caption>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>C</th>
  </tr>
  <tr>
    <td>xxx</td>
    <td>xxx</td>
    <td>xxx</td>
  </tr>
</table>
-->

<!--矩阵公式-->
<!--
<div class="cmath" align="center">
  `((1, 0),(1, 0))`
</div>
-->

<!--图片-->
<!--
<div align="center">
  <img src="./pic/xxx.png" width=30%>
</div>
-->

<!--正文-->
<!--
<p>
&nbsp;&nbsp;&nbsp;&nbsp;公式：<span>`\overline{A}\overline{B}`</span>
</p>
-->

<br>

<div class="div_catalogue">
  <div align="center">
    <h2> 目录 </h2>
    <p>
    <font size="2px">有特定需要的内容直接跳转到相关章节查看即可。</font>
  </div>
  <div class="div_learning_post_boder">
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 1. <a href="#1_gdt"><font color="blue"><b>全局描述符表</b></font></a>：介绍了用于存储段描述符的 GDT
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#1_gdt_1"><font color="blue">Motivation</font></a>：介绍了保护模式的 Motivation；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2 <a href="#1_gdt_2"><font color="blue">全局描述符表</font></a>：介绍了 GDT 的内容以及初始化过程；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3 <a href="#1_gdt_3"><font color="blue">段描述符</font></a>：详细介绍了段描述符的格式；
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 2. <a href="#2_load_protection"><font color="blue"><b>实例：进入保护模式</b></font></a>：详细介绍了 CPU 从实模式跑向保护模式的过程；
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#2_load_protection_1"><font color="blue">设置堆栈段和栈指针</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#2_load_protection_2"><font color="blue">计算 GDT 所在的位置</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#2_load_protection_3"><font color="blue">安装段描述符</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#2_load_protection_4"><font color="blue">似乎是题外话：A20 地址线趣谈</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#2_load_protection_5"><font color="blue">正式进入保护模式</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#2_load_protection_6"><font color="blue">在保护模式中访问内存</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.7 <a href="#2_load_protection_7"><font color="blue">保护模式下的堆栈</font></a>
    <p>
    &nbsp;&nbsp;&nbsp;&nbsp;Section 3. <a href="#3_protect_memory_access"><font color="blue"><b>保护模式下对访问内存的保护</b></font></a>：重新强调了在保护模式下处理器对访问内存、修改段基址寄存器操作的检查
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#3_protect_memory_access_1"><font color="blue">对修改段基址寄存器的保护</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#3_protect_memory_access_2"><font color="blue">地址转换时的保护</font></a>
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#3_protect_memory_access_3"><font color="blue">别名</font></a>
  </div>
</div>

<!--标题-->
<h2><a name="1_gdt">1. 全局描述符表</a></h2>
<div class="div_learning_post">
  <h3><a name="1_gdt_1">1.1 Motivation</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_7_Intel_32_CPU_And_IA_32/index.html#1_reg_2">段地址和段内偏移寄存器</a> 一节中，在介绍 32 位处理器段地址和段内偏移寄存器和 16 位处理器不同的地方时，曾经介绍过保护模式的意义。简而言之，为了避免程序段发起对内存中其它位置的程序段的不安全访问，保护模式可以用来约束程序段的访问行为。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;为了实现上面的功能， CPU 在内存中存放了用于记录各个段性质的描述数据 —— <font color="blue">全局描述符表 (Global Descriptor Table, GDT)</font>。下面我们展开介绍。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在这里我们先进行约定：由于我们还没有引入分页机制的介绍，因此我们在本文中讨论的线性地址和物理地址这两者尚且是等价的。

  <h3><a name="1_gdt_2">1.2 全局描述符表</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;顾名思义，全局描述符表是一张表，用于存储段描述符。段描述符用于描述各个段的属性，这样处理器在运行各个段的代码的时候就可以根据描述符中描述的信息来约束程序的行为。我们在后面将会介绍段描述符的格式和对应的功能，首先我们先来关心这张全局描述符表是如何被初始化的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在系统上电之后，CPU 是处于实模式下的，即仍然是使用 "段基地址寄存器 + 段内偏移寄存器" 的方式来访问内存。因此系统能访问的内存仅有 1MB，就像我们在 8086 中那样。而在进入保护模式之前，我们又必须初始化这张表，将它放在内存中的特定位置，这样进入保护模式之后，CPU 才能够根据这张表来运行程序。这样一来，全局描述符表就只能放在内存中低 1 MB 的空间中了。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 32 位处理器中有一个特殊的 48 位寄存器 —— <font color="blue">全局描述符表寄存器 (GDTR)</font>，用于追踪内存中的 GDT。其格式如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td width="60%">GDT 线性基地址 (32-bits)</td>
      <td width="40%">GDT 边界 (16-bits)</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;其中，<font color="blue">GDT 线性基地址</font> 用于描述 GDT 在内存中的其实位置，<font color="blue">GDT 边界</font> 用于描述 GDT 的长度。可见 GDT 最长可为 `2^16 = 64KB`。而我们在后面会看到，每条段描述符的长度为 8 Bytes，因此 GDT 最多可以装载 8192 条段描述符。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;现在我们来看一下 GDT 的初始化过程。我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_2_Computer_Arch/index.html#1_comp_component_3">BIOS ROM</a> 曾经介绍过，系统上电之后，在 BIOS ROM 中会把 MBR 程序从磁盘的 0 面 0 道 1 扇区读取到内存中的 0x0000:0x7c00 处，而 MBR 程序会占据 512(0x200) Bytes 的空间，因此相当于 0x00007C00 ~ 0x00007E00 是 MBR 的地盘，而 0x00000000 ~ 0x00007BFF 通常是 MBR 的堆栈的位置。因此我们可以把 GDT 放在 0x00007E00 开始的位置，并且结合我们上文讨论过的 GDT 的最长长度，它最长将延伸到 0x00017DFF 的位置，如下图所示。

  <div align="center">
    <img src="./pic/gdt.png" width=500px>
  </div>

  <h3><a name="1_gdt_3">1.3 段描述符</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在理解了 GDT 以及它在内存中的位置后，我们现在来关心 GDT 的表项 —— <font color="blue">段描述符</font>。正如上面所述，一条段描述符的大小为 8 bytes，即 64 bits，其格式如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td width="10%">长度</td>
      <td width="24%">8b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="3%">1b</td>
      <td width="12%">4b</td>
      <td width="3%">1b</td>
      <td width="6%">2b</td>
      <td width="3%">1b</td>
      <td colspan="4" width="12%">4b</td>
      <td width="24%">8b</td>
    </tr>
    <tr>
      <td rowspan="2" width="10%">含义</td>
      <td rowspan="2" width="24%">段基地址<br>[bit 31 ~ 24]</td>
      <td rowspan="2" width="3%">G</td>
      <td rowspan="2" width="3%">D/B</td>
      <td rowspan="2" width="3%">L</td>
      <td rowspan="2" width="3%">AVL</td>
      <td rowspan="2" width="12%">段界限<br>[bit 19 ~ 16]</td>
      <td rowspan="2" width="3%">P</td>
      <td rowspan="2" width="6%">DPL</td>
      <td rowspan="2" width="3%">S</td>
      <td colspan="4" width="12%">TYPE</td>
      <td rowspan="2" width="24%">段基地址<br>[bit 23 ~ 16]</td>
    </tr>
    <tr>
      <td>X</td>
      <td>E/C</td>
      <td>W/R</td>
      <td>A</td>
    </tr>
  </table>

  <table>
    <tr>
      <td width="10%">长度</td>
      <td>16b</td>
      <td>16b</td>
    </tr>
    <tr>
      <td width="10%">含义</td>
      <td>段基地址<br>[bit 15 ~ 0]</td>
      <td>段界限<br>[bit 15 ~ 0]</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;下面我们对上面的字段分别进行说明：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在段描述符中，我们首先看到了用于描述段在内存中起始位置和长度的  32-bits <font color="blue">段基地址</font> 和 20-bits <font color="blue">段界限</font>。这里的段基地址是 32-bits 的线性地址，仍然值得说明的是，由于还未引入分页机制，这里的线性地址我们暂时直接等同于物理内存地址。而段界限用于限制偏移量，是一个偏移量的最值：对于向上扩展的段，如代码段和数据段来说，偏移量是从 0 开始递增，段界限决定了偏移量的最大值；对于向下扩展的段，如堆栈段来说，段界限决定了偏移量的最小值。<font color="red">段界限在数值上等于段的长度减一。</font>

  <div align="center">
    <img src="./pic/segment_length.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">G (Granularity) 位</font> 用于解释段界限的含义：当 G=0 时，段界限以字节为单位 (i.e. 段长度为 1B ~ 1MB)；当 G=1 时，段界限以 4KB 为单位 (i.e. 段长度为 4B ~ 4GB)。因此我们会得到，对于在内存空间中方向是向上扩展的数据段/代码段来说，段内偏移的最大值为："粒度`\times`段界限值"；对于在内存空间中方向是向下扩展的堆栈段来说，段内偏移的最小值为 "粒度`\times`段界限值+1"。我们在 <a href="#2_load_protection_7">保护模式下的堆栈</a> 中会详细分析向下扩展的段的界限问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">S 位</font> 用于描述描述符的类型：当 S=1 时，表示该段是一个 <font color="blue">系统段</font>；当 S=0 时，表示该段是一个 <font color="blue">代码段/数据段</font>(栈段是一种特殊的数据段)。


  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">DPL (Description Privilege Level)</font> 用于描述访问该段所必须具有的最低特权级。段的特权级别有 4 中：0、1、2、3，其中 0 级是最高特权级别。为了安全，处理器的某些指令指定必须由 0 级的程序来执行，这部分程序通常是操作系统代码；而当操作系统创建应用程序时，应用程序的代码通常运行在 3 级下。DPL 字段用于规定访问该段的另一个段必须拥有的最低特权等级。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">P (Segment Present) 位</font> 用于指示描述符所对应的段是否在内存中。当内存空间紧张时：

  <ol>
    <li>在创建新的段时，会只建立段描述符，对应的内存空间可能并不存在；</li>
    <li>操作系统会把比较少用到的段换出内存到硬盘中</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于以上这两种情况，P 位都应该被设置为 0，代表该段并不在内存中。P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果 P 位是 0，处理器就会产生一个 <font color="red">异常中断</font>。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将 P 位置 1。在多用户、多任务的系统中，这是一种常用的虚拟内存调度策略。当内存很小，运行的程序很多时，如果计算机的运行速度变慢，并伴随着繁忙的硬盘操作时，说明这种情况正在发生。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">D/B 位</font> 的设置主要是为了使得 32 位处理器上能够运行 16 位程序。对于代码段：D/B=0 表示指令中的偏移地址或者操作数是 16 位的；D/B=1 表示指令中的偏移地址或者操作数是 32 位的。对于栈段：D/B=0 表示访问栈使用的是 16-bits 寄存器 SP，栈的上部边界为 0xFFFF；D/B=1，表示访问栈使用的是 32-bits 寄存器 ESP，栈的上部边界为 0xFFFFFFFF。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">L 位</font>是 64 位代码段标志 (64-bits Code Segment)，保留此位给 64 位处理器使用。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">AVL (Available) 位</font> 是预留给操作系统使用的位，不由处理器使用。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">TYPE 字段</font>是描述符中比较重要的部分，用于描述段的类别(属性)。它一共有四位，<font color="red">对于数据段(包括栈段)来说，这四位是 X、E、W、A 位；对于代码段来说，这四位是 X、C、R、A 位。</font>下面我们分析它们的真实含义：

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于数据段和代码段都有的 <font color="blue">X 位</font>，它用于表示该段是否可以执行：数据段是不可执行的，X=0；代码段是可以执行的，X=1。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于数据段和代码段都有的 <font color="blue">A 位</font>，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置 "1"。对该位的清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率。当内存空间紧张时，可以把不经常使用的段退避到硬盘上，从而实现虚拟内存管理。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于<b>数据段</b>来说，<font color="blue">E 位</font>指示段的扩展方向。E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段；E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。<font color="blue">W 位</font>指示段的读写属性，或者说段是否可写，W＝0 的段是不允许写入的，否则会引发处理器异常中断；W＝1 的段是可以正常写入的。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于<b>代码段</b>来说，<font color="blue">C 位</font>指示段是否为特权级依从的（Conforming）。C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；C＝1 表示允许从低特权级的程序转移到该段执行。<font color="blue">R 位</font>指示代码段是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由 R 位指定。R＝0 表示不能读出，如果企图去读一个 R＝0 的代码段，会引发处理器异常中断；如果 R＝1，则代码段是可以读出的，即可以把这个段的内容当成 ROM 一样使用。<font color="red">注意！这里的是否可以读出限制的是程序的行为，比如使用 "CS:" 来把代码段当作数据读取的行为，而不是在限制处理器行为，处理器肯定得读代码段的数据，不然怎么运行程序？</font>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">TYPE 字段</font>各个位代表的含义可以总结为下表：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <caption>数据段</caption>
    <tr>
      <th>X</th>
      <th>E</th>
      <th>W</th>
      <th>A</th>
      <th>描述符类别</th>
      <th>含义</th>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>X</td>
      <td rowspan="4"><div align="center">数据</div></td>
      <td>只读</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>X</td>
      <td>读、写</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>X</td>
      <td>只读，向下扩展</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>X</td>
      <td>读、写，向下扩展</td>
    </tr>
  </table>

  <table border="1" align="center" bgcolor="#FFFFFF">
    <caption>代码段</caption>
    <tr>
      <th>X</th>
      <th>C</th>
      <th>R</th>
      <th>A</th>
      <th>描述符类别</th>
      <th>含义</th>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>X</td>
      <td rowspan="4"><div align="center">代码</div></td>
      <td>只执行</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>X</td>
      <td>执行、读</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>X</td>
      <td>只执行，依从的代码段</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>X</td>
      <td>执行、读，依从的代码段</td>
    </tr>
  </table>
</div>

<h2><a name="2_load_protection">2. 实例：进入保护模式</a></h2>
<div class="div_learning_post">

  <div align="center">
    <img src="./pic/gdt.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在本节中我们将看到一段 MBR 程序，它会设置 GDT 并将处理器设置为保护模式。我把完整的代码贴在 <a href="#source_code">附录源码</a> 中，我们在本节将把这份代码拆开分析。注意到我重新把内存低 1 MB 的分布情况贴到了本节中，方便读者观察。

  <h3><a name="2_load_protection_1">2.1 设置堆栈段和栈指针</a></h3>

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>      </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span> </span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上图所示，我们将我们的堆栈的栈顶指针设置在了 ss:0x7c00(i.e. cs:0x7c00) 的位置，实际上此时 cs=ss=0x0000。栈顶指针实际上紧邻着我们的 MBR 代码段，只不过和代码段的增长方向相反。

  <h3><a name="2_load_protection_2">2.2 计算 GDT 所在的位置</a></h3>

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">cs</span>:gdt_base+<span class="number">0x7c00</span>]        <span class="comment">;低16位 </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,[<span class="built_in">cs</span>:gdt_base+<span class="number">0x7c00</span>+<span class="number">0x02</span>]   <span class="comment">;高16位 </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">16</span>        </span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span>            </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>                          <span class="comment">;令DS指向该段以进行操作</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">dx</span>                          <span class="comment">;段内起始偏移地址</span></span><br><span class="line"></span><br><span class="line">gdt_size         <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">gdt_base         <span class="built_in">dd</span> <span class="number">0x00007e00</span>     <span class="comment">;GDT的物理地址   </span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;由于目前我们尚处实模式下，仍然是按照 16-bits "段基地址+段内偏移地址" 的方式发起对内存的访问，因此我们必须求出 GDT 最终位置的段基地址和段内偏移地址，才能装填它。如上代码所示，我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_4_Segment/index.html#3_example">实例：硬盘主引导扇区</a> 中曾经理解过 MBR 程序访问数据要注意的重定位问题，因此我们能理解 Line 2~3 代码是如何将 gdt_size 所指示的 32-bits GDT 线性地址放置到 AX 和 DX 寄存器中的。接着，我们使用了 16 位除法，将 GDT 的 32-bits 线性地址除以 16，其得到的商即 GDT 段基地址，余数即 GDT 段内偏移地址。这里的原理是利用了公式 "段基地址 x 16 + 段内偏移地址 = 逻辑地址"。随后，我们设置好 DS 和 BX 寄存器，就可以准备向 GDT 中写数据了。 

  <h3><a name="2_load_protection_3">2.3 安装段描述符</a></h3>

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;创建 #0 描述符，它是空描述符，这是处理器的要求</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x00</span>],<span class="number">0x00</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x04</span>],<span class="number">0x00</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">;创建 #1 描述符，保护模式下的代码段描述符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x08</span>],<span class="number">0x7c0001ff</span>     </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x0c</span>],<span class="number">0x00409800</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment">;创建 #2 描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x10</span>],<span class="number">0x8000ffff</span>     </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x14</span>],<span class="number">0x0040920b</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment">;创建 #3 描述符，保护模式下的堆栈段描述符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x18</span>],<span class="number">0x00007a00</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x1c</span>],<span class="number">0x00409600</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如上代码所示，我们向 GDT 中写了四个连续的段描述符，我们挨个进行分析。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;段描述符 #0 实际上是一个空描述符，这是处理器规定的，所以我们写入了全 0。这么规定的原因是因为一些程序的 bug 可能会基于寄存器/内存单元的初始化值使用全 0 来索引段描述符，因此处理器干脆就把第一个段描述符设为全 0。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;段描述符 #1 描述的是我们现在正在执行的 MBR 代码段，其拆解如下：

  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线性基地址为 0x00007C00；</span><br><span class="line">段界限为 0x001FF，粒度为字节（G＝0）；</span><br><span class="line">该段的长度为 512 字节；</span><br><span class="line">属于存储器的段（S＝1）；</span><br><span class="line">这是一个 32 位的段（D＝1）；</span><br><span class="line">该段目前位于内存中（P＝1）；</span><br><span class="line">段的特权级为 0（DPL＝00）；</span><br><span class="line">这是一个只能执行的代码段（TYPE=1000）</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;段描述符 #2 描述的是一个后面我们会用到的数据段，拆解过后我们看到了一个熟悉的线性地址 0x000B8000，这是显存的位置。整个描述符拆解如下：

  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线性基地址为 0x000B8000；</span><br><span class="line">段界限为 0x0FFFF，粒度为字节（G＝0）。即，该段的长度为 64KB；</span><br><span class="line">属于存储器的段（S＝1）；</span><br><span class="line">这是一个 32 位的段（D＝1）；</span><br><span class="line">该段目前位于内存中（P＝1）；</span><br><span class="line">段的特权级为 0（DPL＝00）；</span><br><span class="line">这是一个可读可写、向上扩展的数据段（TYPE=0010）</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;段描述符 #2 描述的是一个后面我们会用到的栈段，其拆解如下：

  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线性基地址为 0x00000000；</span><br><span class="line">段界限为 0x07A00，粒度为字节（G＝0）；</span><br><span class="line">属于存储器的段（S＝1）；</span><br><span class="line">这是一个 32 位的段（D＝1）；</span><br><span class="line">该段目前位于内存中（P＝1）；</span><br><span class="line">段的特权级为 0（DPL＝00）；</span><br><span class="line">这是一个可读可写、向下扩展的数据段，即堆栈段（TYPE=0010）</span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在安装了 4 个描述符后，是时候设置 GDTR 了：

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> [<span class="built_in">cs</span>: gdt_size+<span class="number">0x7c00</span>], <span class="number">31</span>  <span class="comment">;描述符表的界限（总字节数减一）                                     </span></span><br><span class="line"><span class="keyword">lgdt</span> [<span class="built_in">cs</span>: gdt_size+<span class="number">0x7c00</span>]</span><br><span class="line"></span><br><span class="line">gdt_size         <span class="built_in">dw</span> <span class="number">0</span>               <span class="comment">;GDT 的大小</span></span><br><span class="line">gdt_base         <span class="built_in">dd</span> <span class="number">0x00007e00</span>      <span class="comment">;GDT 的物理地址 </span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;可以看到我们将 GDT 的大小装填到了将要装入 GDTR 的 48-bits 内存空间的前 16 位中，然后使用了 lgdt 指令设置了 GDTR。

  <h3><a name="2_load_protection_4">2.4 似乎是题外话：A20 地址线趣谈</a></h3>
  <div class="div_concurrent_img">
    <img src="./pic/a20_1.png" width=400px>
    <img src="./pic/a20_2.png" width=400px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;这里讨论一个有点题外话的内容：A20 地址线的问题。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 16-bits 处理器时代，程序员在遇到 0xFFFFF 地址时，加 1 就能够返回 0x00000，这被称为循环寻址。到了 32-bits 处理器上，由于地址线变多了，这种投机取巧的方法明显就不行了。为了兼容在 16 位时代写的程序，IBM 想了个歪招。早期的歪招如上第一幅图所示，使用一个与门，利用键盘控制器的 0x60 端口来控制第 21 条地址线 A20 是开还是关。当 A20 被关掉时，上述的循环寻址就又奏效了。后来大家发现这个歪招的耗时太长了，就把歪招加到了南桥芯片的 0x92 端口上，用来控制 CPU 低电平有效的 A20M# 引脚。当这支引脚被使能时，A20 地址线就被干掉了。

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span>                         <span class="comment">;南桥芯片内的端口 </span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span>      </span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们不希望 A20 地址线被干掉，因为我们现在处理的是 32 位程序。因此在上面的代码中，我们通过向 0x92 端口的 bit 1 写入 1 来关掉这种机制。

  <h3><a name="2_load_protection_5">2.5 正式进入保护模式</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在做完所有准备工作后，我们现在准备进入保护模式一探究竟。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 Intel 32 位处理中，为了将处理器从实模式切换为保护模式，我们必须设置处理器内部的 <font color="blue">CR0 (Control Register)</font> 寄存器。CR0 寄存器的第 0 位是 <font color="blue">PE (Protection Enable)</font> 位，当我们将该位置 1 时，处理就会进入保护模式。我们看下面的代码：

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">cli</span>               <span class="comment">;保护模式下中断机制尚未建立，应禁止中断 </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">cr0</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span>,<span class="built_in">eax</span>       <span class="comment">;设置PE位  </span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;注意到我们在 Line 1 的代码中使用 cli 禁止了中断机制。这是因为在保护模式下，实模式下设置的中断向量表已经不再能使用了，因此进入保护模式后必须重新建立中断机制，在新的中断机制被建立之前，我们必须禁止所有的中断行为。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在设置完 CR0 寄存器后，事情还没有结束，虽然我们的处理器现在已经进入了 32 位保护模式，但是有残留的问题：

  <ol>
    <li>进入保护模式后，处理器对各个段基址寄存器的解释方法已经发生了变化 (我们在下一节将会看到具体的细节)，此时在实模式下设置的段基址寄存器的值已经失去了意义，应该尽快将它们设置为保护模式下的格式；</li>
    <li>在实模式的程序运行时，处理器进行了多次指令预取，流水线上残留着实模式下的预取队列，需要尽快清空</li>
  </ol>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;因此，在进入保护模式后，我们实际上还得针对上面这两个问题做处理，然后才能够开始运行我们在保护模式下的代码。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;通常来说，我们都是使用段间转移指令来处理上面的问题，因为首先段间转移指令能够用于设置 CS 和 EIP 寄存器，因此解决了上面的第一个问题；其次我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_7_Intel_32_CPU_And_IA_32/index.html#3_modern_cpu_5">分支预测</a> 中也提到过，运行段间转移指令将会清空 (Flush) 处理器的流水线，因此解决了上面的第二个问题。代码如下所示：

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="number">0x0008</span>:flush            <span class="comment">;16位的描述符选择子：32位偏移</span></span><br><span class="line">                                  <span class="comment">;清流水线并串行化处理器</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;细心的同学会开始思考：此时的 jmp 指令是运行在保护模式下的，并且由于我们还没有使用伪指令 "bits 16"，因此这条指令还是运行在 32 位处理器的 16 位模式下的。有同学会疑惑：此时为什么会是 16 位模式呢？这里稍作解释。我们在上面描述段描述符的时候有说过，<font color="red">在保护模式下，处理器辨别一个段使用的是 16 位编码还是 32 位编码判断的是段描述符的 D 位。</font>对于代码段来说 (此时运行的代码段是 MBR)，处理器实际上判断的是 CS 寄存器的 <b>描述符高速缓存器</b> 的 D 位。我们在下面还会看见，实模式下，CS 的描述符高速缓存的 D 位是 0。因此当处理器在运行这条指令时，<font color="red">它是运行在 16 位的保护模式下的。</font>所以可以预见到这条指令被编译过后将会带上 0x66 的前缀，因为它在一条 16 位的指令中使用了 32 位的立即数和操作数。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;jmp 完之后，我们现在正式进入了保护模式！

  <h3><a name="2_load_protection_6">2.6 在保护模式中访问内存</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们现在来分析一下 32 位处理器中的段基址寄存器。注意到我们在 <a href="/sec_learning/Tech_OS_And_Linux_Kernel/Assembly_7_Intel_32_CPU_And_IA_32/index.html#1_reg_2">段地址和段内偏移寄存器</a> 中曾经简单介绍了 32 位处理器和 16 位处理器在这方面的区别。我们知道在 32 位处理器下，段基址寄存器是 80 位的，包括了 16 位 和 64 位两部分，如下图所示。在保护模式下，我们把两部分分别称为 <font color="blue">段选择器</font> 和 <font color="blue">描述符高速缓存器</font>。在 实模式(16 位模式) 和 保护模式 (32 位模式) 下，段基址寄存器的用法是不同的，我们下面对此进行分析。

  <div align="center">
    <img src="./pic/protection_segment_reg.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">在实模式下</font>，32 位处理器的段基址寄存器的低 16 位与 16 位处理器的段基址寄存器的用法一样，可用于在 1 MB 的地址空间内使用 "段基址 x 16 + 段内偏移地址" 的方式进行 16 位对齐的段寻址。来看下面的代码:

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x2000</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="number">0xc0</span>], <span class="built_in">al</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;回忆一下，在 16 位的 8086 处理器中，上面的 Line 1～2 会将 0x2000 写入到 DS 寄存器中。<font color="red">在 Line 3 进行内存单元写入时</font>，处理器会首先将 DS 的内容左移 4 位，加上偏移地址，然后把数据实际写入物理地址 0x200c0。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在 32 位处理器的 实模式(16 位模式) 下，这个过程是有所不同的。<font color="red">在 Line 2 设置 DS 寄存器的时候</font> (我们把这个过程称为 <font color="blue">引用</font> 数据段)，处理器会自动的把段基地址 0x2000 左移 16 位，然后写入到段基址寄存器 DS 的描述符高速缓存器的低 20 位中。然后在 Line 3 发起对内存单元的访问的时候，处理器就会将这低 20 位当作段基地址来进行操作。这个细节是 16 位和 32 位处理器在实模式下分段机制的区别。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;而<font color="red">在保护模式下</font>，实模式下的 6 个段寄存器 CS、DS、ES、FS、GS 和 SS，在保护模式下叫做 <font color="blue">段选择器</font>。在保护模式下发起对一个段的访问的时候，传送到段选择器的内容不再是逻辑段地址，而是用于定位一个段描述符在上文介绍的描述符表中的 16-bits 段选择子。这 16-bits 的格式如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <td width="70%">描述符索引 (13-bits)</td>
      <td width="10%">TI (1-bit)</td>
      <td width="20%">RPL (2-bits)</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;第一部分是描述符的<font color="blue">索引号</font>，用来在描述符表中选择一个段描述符；<font color="blue">TI (Table Indicator)</font> 是描述符表指示器，TI＝0 时，表示描述符在 GDT 中；TI＝1 时，描述符在 LDT 中。<font color="blue">RPL</font> 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在保护模式的程序中，当处理器在执行任何<font color="red">改变</font>段选择器的指令时（e.g. pop、mov、jmp far、call far、iret、retf），就将指令中提供的索引号乘以 8 作为偏移地址 (因为在 GDT 中一个描述符的大小为 8 Bytes)，同 GDTR 中提供的线性基地址相加，以访问 GDT，即：

  <div class="div_learning_post_boder" align="center">
  <p><font color="red">段描述符地址 = GDTR 中的段基地址 + 段选择子索引号 `\times` 8</font> (ps: 段选择子索引号 `\times` 8 + 7 `\leq` GDTR 中的段界限)
  </div><br>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果没有发现什么问题（比如超出了 GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。如下图所示：

  <div align="center">
    <img src="./pic/load_selector.png" width=500px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在保护模式的程序中，当处理器在执行任何<font color="red">访问</font>内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址；处理器在去指令执行时，也是一样的道理，假设已经从描述符表中选择了一个段描述符，CS 描述符高速缓存器已经装载了正确的 32 位线性基地址，那么，当处理器取指令时，会自动用描述符高速缓存器中的 32 位线性基地址加上指令指针寄存器 EIP 中的 32 位偏移量，形成 32 位物理地址，从内存中取得执令并加以执行。如下图所示：

  <div class="div_concurrent_img">
    <img src="./pic/protection_mode_memory_access.png" width=350px>
    <img src="./pic/protection_mode_load_instruction.png" width=350px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;理解了保护模式下的内存访问方法后，我们回过头来，看我们的 MBR 代码，就能够很好理解在保护模式下访问内存的设置步骤了：

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>] </span><br><span class="line"></span><br><span class="line"><span class="symbol">flush:</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">00000000000_10_000B</span>         <span class="comment">;加载数据段选择子(0x10)</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">cx</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">;以下在屏幕上显示&quot;Protect mode OK.&quot; </span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x00</span>],<span class="string">&#x27;P&#x27;</span>  </span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x02</span>],<span class="string">&#x27;r&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x04</span>],<span class="string">&#x27;o&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x06</span>],<span class="string">&#x27;t&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x08</span>],<span class="string">&#x27;e&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x0a</span>],<span class="string">&#x27;c&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x0c</span>],<span class="string">&#x27;t&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x0e</span>],<span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x10</span>],<span class="string">&#x27;m&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x12</span>],<span class="string">&#x27;o&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x14</span>],<span class="string">&#x27;d&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x16</span>],<span class="string">&#x27;e&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x18</span>],<span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x1a</span>],<span class="string">&#x27;O&#x27;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x1c</span>],<span class="string">&#x27;K&#x27;</span> </span><br></pre></td></tr></table></figure>
  <h3><a name="2_load_protection_7">2.7 保护模式下的堆栈</a></h3>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;堆栈相关的东西，请查阅下面章节：<a href="3_protect_memory_access_2">地址转换时的保护</a>。

  <!-- <div align="center">
    <img src="./pic/protection_mode_stack.png" width=300px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们最后来关注一下保护模式下的堆栈操作。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;堆栈是向下扩展的，我们在 <a href="#1_gdt_3">段描述符</a> 中也已经介绍过了描述符中的段界限对堆栈段内偏移量大小的限制，即 "ESP`>`段界限`\times`粒度值"。我们来看下面的代码：

  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;NASM Assembly</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">00000000000_11_000B</span>         <span class="comment">;加载堆栈段选择子</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="number">0x7c00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span>                        <span class="comment">;保存堆栈指针 </span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">byte</span> <span class="string">&#x27;.&#x27;</span>                      <span class="comment">;压入立即数（字节）</span></span><br></pre></td></tr></table></figure>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在保护模式下，在对堆栈做操作的时候，同样首先会对 ESP 寄存器进行操作。如上图的 Line 7，会先将 ESP 的值自减 4，然后处理器会判断 ESP 所代表的段内偏移的值是否满足段界限所约束的范围，如果满足，则可以进行操作；如果不满足，则会引发异常中断。 -->
</div>

<h2><a name="3_protect_memory_access">3. 保护模式下对访问内存的保护</a></h2>
<div class="div_learning_post">
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;有了保护模式，最重要的就是在指令要访问内存的时候实现对内存数据的保护，即不让指令执行超过它们权限的动作，在本小节，我们将关注这一部分。

  <h3><a name="3_protect_memory_access_1">3.1 对修改段基址寄存器的保护</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们上面曾经理解过，在保护模式下，当我们使用 mov 或者 jmp 这种会直接或者间接修改段基址的指令时，我们实际上传送的是段选择子，处理器实际上是会从 GDT 中将相应段描述符读取到描述符高速缓冲器中的。在这个过程中，处理器会首先确认传送的选择子是正确的，然后才会完成传送操作。下面我们描述一下具体细节。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们在 <a href="#2_load_protection_6">在保护模式中访问内存</a> 曾经讲过在保护模式下，处理器根据段选择子从 GDT 中读取 段描述符 到 描述符高速缓存器的过程，即取指令的地址为：GDTR 中的段基地址 + 段选择子索引号 `\times` 8。在读取段描述符之前，如果处理器发现段选择子所指示的位置已经超过了 GDT 的边界，即：段选择子索引号 `\times` 8 +7 `>` GDT 段界限值，则处理器将终止处理，并且会引发异常中断 13，同时段寄存器中的原值保持不变。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;在通过了处理器的越界检查之后，处理器还会对描述符的类别进行检查：描述符类别首先必须是合法的值；其次读取的描述符类别必须和段寄存器的用途匹配，比如描述符类别是只执行的代码段的话，是不允许写到除 CS 寄存器以外的其它段寄存器中的，匹配的具体规则如下所示：

  <table border="1" align="center" bgcolor="#FFFFFF">
    <tr>
      <th rowspan="2">段寄存器</th>
      <th colspan="2">数据段 (X=0)</th>
      <th colspan="2">代码段 (X=1)</th>
    </tr>
    <tr>
      <th>只读 (W=0)</th>
      <th>读写 (W=1)</th>
      <th>只执行 (R=0)</th>
      <th>执行、读 (R=1)</th>
    </tr>
    <tr>
      <td>CS</td>
      <td>`\times`</td>
      <td>`\times`</td>
      <td>`\circ`</td>
      <td>`\circ`</td>
    </tr>
    <tr>
      <td>DS</td>
      <td>`\circ`</td>
      <td>`\circ`</td>
      <td>`\times`</td>
      <td>`\circ`</td>
    </tr>
    <tr>
      <td>ES</td>
      <td>`\circ`</td>
      <td>`\circ`</td>
      <td>`\times`</td>
      <td>`\circ`</td>
    </tr>
    <tr>
      <td>FS</td>
      <td>`\circ`</td>
      <td>`\circ`</td>
      <td>`\times`</td>
      <td>`\circ`</td>
    </tr>
    <tr>
      <td>GS</td>
      <td>`\circ`</td>
      <td>`\circ`</td>
      <td>`\times`</td>
      <td>`\circ`</td>
    </tr>
    <tr>
      <td>SS</td>
      <td>`\times`</td>
      <td>`\circ`</td>
      <td>`\times`</td>
      <td>`\times`</td>
    </tr>
  </table>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，只有可以写入的数据段才能加入到 SS 寄存器；CS 寄存器只允许加载代码段描述符；DS、ES、FS 和 GS 寄存器可以加载数值为 0 的段选择子，在加载的时候不会有任何问题，但是如果真的拿这个选择子来访问内存的话，则会引发异常中断。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;完成类别检查之后，处理器还会通过判断 P 位判断描述符对应的段是否在内存中 (我们在 <a href="#1_gdt_3">段描述符</a> 中已经描述过)，如果不在的话，则会引发异常中断 11；如果在的话，则就把描述符拷贝到描述符高速缓存器，并且在内存中将相应段描述符的 A 位置位 (我们同样在 <a href="#1_gdt_3">段描述符</a> 中已经描述过)。

  <h3><a name="3_protect_memory_access_2">3.2 地址转换时的保护</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当段描述符完整装在之后，我们就能够使用其中的段基地址发起对内存的访问。在访问的时候，处理器会检查访问的地址是否在段界限所约束的范围之内。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当 G 位为 0 的时候，段界限的值就是偏移地址的最大值。

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;当 G 位为 1 的时候，段界限的单位是 4KB (0x1000)，因此实际段界限为：

  <div class="div_learning_post_boder" align="center">
    <p><font color="red">实际段界限 = (描述符中的段界限值+1) `\times` 0x1000 - 1</font> 
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于代码段来说，处理器必须保证：

  <div class="div_learning_post_boder" align="center">
    <p><font color="red">0 `\leq` (EIP + 指令长度 - 1) `\leq` 实际段界限</font> 
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;如果超出这个区间，处理器同样将引发异常中断。

  <div align="center">
    <img src="./pic/protection_mode_stack_2.png" width=400px>
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于堆栈段来说，比较特殊，我们现在看到的堆栈段都是向下增长的。这样一来，实际上<font color="blue">段界限描述的并不是段的长度，而是段的底部和段基址的距离</font>，如上图所示。换句话说，段界限约束了堆栈段的段内<font color="red">最小</font>偏移地址；对于最大段内偏移地址，则没有约束，即最高可以是 0xFFFFFFFF。并且，在每次向堆栈中 push 数据的时候，ESP 的内容需要减去操作数的长度。因此处理器必须保证，在 push 数据时：

  <div class="div_learning_post_boder" align="center">
    <p><font color="red">实际段界限+1 `\leq` (ESP的内容－操作数的长度) `\leq` 0xFFFFFFFF</font> 
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;对于数据段来说，这里特指有别于堆栈段的向上增长的数据段。处理器必须保证：

  <div class="div_learning_post_boder" align="center">
    <p><font color="red">0 `\leq` (EA + 操作数大小 - 1) `\leq` 实际段界限</font> 
  </div>

  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;其中 EA (Effective Address) 是在指令给出的数据段内偏移地址 [EA]。

  <h3><a name="3_protect_memory_access_3">3.3 别名</a></h3>
  <p>
  &nbsp;&nbsp;&nbsp;&nbsp;我们有时候会碰到需要修改代码段的情况，比如在调试程序的时候需要加入断点指令 int 3，但是通过上文我们的阐述，代码段是可读不可写的，这怎么办呢？此时我们可以通过定义一个新的段描述符，并将其定义为一个可读可写的数据段。这样当我们需要修改代码段的时候，使用这个新定义的段描述符就可以了。这个新定义的描述符被称作 <font color="blue">别名 (alias)</font>。
</div>

<!--ref-->
<h2>附录：</h2>
<h3>1. 参考源</h3>
<div class="div_learning_post">
<p>

<ol>
<li>CSDN, <a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/190015989">实模式到保护模式:关于jmp的问题</a></p>
</div>

</li>
</ol>
<h3><a name="source_code">2. 本文分析的 MBR 完整代码</a></h3>
<div class="div_learning_post">

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">;设置堆栈段和栈指针 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">;计算GDT所在的逻辑段地址 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">cs</span>:gdt_base+<span class="number">0x7c00</span>]        <span class="comment">;低16位 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,[<span class="built_in">cs</span>:gdt_base+<span class="number">0x7c00</span>+<span class="number">0x02</span>]   <span class="comment">;高16位 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">16</span>        </span><br><span class="line">      <span class="keyword">div</span> <span class="built_in">bx</span>            </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>                          <span class="comment">;令DS指向该段以进行操作</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">dx</span>                          <span class="comment">;段内起始偏移地址 </span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">;创建0#描述符，它是空描述符，这是处理器的要求</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x00</span>],<span class="number">0x00</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x04</span>],<span class="number">0x00</span>  </span><br><span class="line"></span><br><span class="line">      <span class="comment">;创建#1描述符，保护模式下的代码段描述符</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x08</span>],<span class="number">0x7c0001ff</span>     </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x0c</span>],<span class="number">0x00409800</span>     </span><br><span class="line"></span><br><span class="line">      <span class="comment">;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x10</span>],<span class="number">0x8000ffff</span>     </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x14</span>],<span class="number">0x0040920b</span>     </span><br><span class="line"></span><br><span class="line">      <span class="comment">;创建#3描述符，保护模式下的堆栈段描述符</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x18</span>],<span class="number">0x00007a00</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dword</span> [<span class="built_in">bx</span>+<span class="number">0x1c</span>],<span class="number">0x00409600</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;初始化描述符表寄存器GDTR</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">word</span> [<span class="built_in">cs</span>: gdt_size+<span class="number">0x7c00</span>],<span class="number">31</span>  <span class="comment">;描述符表的界限（总字节数减一）   </span></span><br><span class="line">                                          </span><br><span class="line">      <span class="keyword">lgdt</span> [<span class="built_in">cs</span>: gdt_size+<span class="number">0x7c00</span>]</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span>                         <span class="comment">;南桥芯片内的端口 </span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">      <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span>                        <span class="comment">;打开A20</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">cli</span>                                <span class="comment">;保护模式下中断机制尚未建立，应 </span></span><br><span class="line">                                        <span class="comment">;禁止中断 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">cr0</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cr0</span>,<span class="built_in">eax</span>                        <span class="comment">;设置PE位</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">;以下进入保护模式... ...</span></span><br><span class="line">      <span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="number">0x0008</span>:flush             <span class="comment">;16位的描述符选择子：32位偏移</span></span><br><span class="line">                                        <span class="comment">;清流水线并串行化处理器 </span></span><br><span class="line">      [<span class="meta">bits</span> <span class="number">32</span>] </span><br><span class="line"></span><br><span class="line"><span class="symbol">flush:</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">00000000000_10_000B</span>         <span class="comment">;加载数据段选择子(0x10)</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">cx</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;以下在屏幕上显示&quot;Protect mode OK.&quot; </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x00</span>],<span class="string">&#x27;P&#x27;</span>  </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x02</span>],<span class="string">&#x27;r&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x04</span>],<span class="string">&#x27;o&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x06</span>],<span class="string">&#x27;t&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x08</span>],<span class="string">&#x27;e&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x0a</span>],<span class="string">&#x27;c&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x0c</span>],<span class="string">&#x27;t&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x0e</span>],<span class="string">&#x27; &#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x10</span>],<span class="string">&#x27;m&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x12</span>],<span class="string">&#x27;o&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x14</span>],<span class="string">&#x27;d&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x16</span>],<span class="string">&#x27;e&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x18</span>],<span class="string">&#x27; &#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x1a</span>],<span class="string">&#x27;O&#x27;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="number">0x1c</span>],<span class="string">&#x27;K&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">00000000000_11_000B</span>         <span class="comment">;加载堆栈段选择子</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="number">0x7c00</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span>                        <span class="comment">;保存堆栈指针 </span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">byte</span> <span class="string">&#x27;.&#x27;</span>                      <span class="comment">;压入立即数（字节）</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">sub</span> <span class="built_in">ebp</span>,<span class="number">4</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span>                        <span class="comment">;判断压入立即数时，ESP是否减4 </span></span><br><span class="line">      <span class="keyword">jnz</span> ghalt                          </span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">eax</span></span><br><span class="line">      <span class="keyword">mov</span> [<span class="number">0x1e</span>],<span class="built_in">al</span>                      <span class="comment">;显示句点 </span></span><br><span class="line">  </span><br><span class="line"><span class="symbol">ghalt:</span>     </span><br><span class="line">      <span class="keyword">hlt</span>                                <span class="comment">;已经禁止中断，将不会被唤醒 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">  </span><br><span class="line">      gdt_size         <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">      gdt_base         <span class="built_in">dd</span> <span class="number">0x00007e00</span>     <span class="comment">;GDT的物理地址 </span></span><br><span class="line">                          </span><br><span class="line">      <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">                      <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>
</div>
</body>
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/sec_learning/">SEC_LEARNING</a></li>
            <li><a href="/sec_learning/Tech_OS_And_Linux_Kernel/">TECH_OS_AND_LINUX_KERNEL</a></li>
          <li>X86_ISA_8_PROTECT_MODE</li>
        
  </ul>

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhuobin Huang"
      src="/images/avatar_2.png">
  <p class="site-author-name" itemprop="name">Zhuobin Huang</p>
  <div class="site-description" itemprop="description">System Engineer</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zobinHuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zobinHuang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zobin1999@gmail.com" title="E-Mail → mailto:zobin1999@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuobin Huang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
